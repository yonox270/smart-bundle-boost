import {
  __esm,
  __export,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/doc.mjs
var doc_exports = {};
__export(doc_exports, {
  builders: () => builders,
  default: () => public_exports,
  printer: () => printer,
  utils: () => utils
});
function stringOrArrayAt(index) {
  return this[index < 0 ? this.length + index : index];
}
function trimNewlinesEnd(string) {
  let end = string.length;
  for (; end > 0 && (string[end - 1] === "\r" || string[end - 1] === `
`); )
    end--;
  return end < string.length ? string.slice(0, end) : string;
}
function getDocType(doc) {
  if (typeof doc == "string")
    return DOC_TYPE_STRING;
  if (Array.isArray(doc))
    return DOC_TYPE_ARRAY;
  if (!doc)
    return;
  let { type } = doc;
  if (VALID_OBJECT_DOC_TYPES.has(type))
    return type;
}
function getDocErrorMessage(doc) {
  let type = doc === null ? "null" : typeof doc;
  if (type !== "string" && type !== "object")
    return `Unexpected doc '${type}', 
Expected it to be 'string' or 'object'.`;
  if (get_doc_type_default(doc))
    throw new Error("doc is valid.");
  let objectType = Object.prototype.toString.call(doc);
  if (objectType !== "[object Object]")
    return `Unexpected doc '${objectType}'.`;
  let EXPECTED_TYPE_VALUES = disjunctionListFormat(
    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)
  );
  return `Unexpected doc.type '${doc.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
}
function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
  let docsStack = [doc];
  for (; docsStack.length > 0; ) {
    let doc2 = docsStack.pop();
    if (doc2 === traverseDocOnExitStackMarker) {
      onExit(docsStack.pop());
      continue;
    }
    onExit && docsStack.push(doc2, traverseDocOnExitStackMarker);
    let docType = get_doc_type_default(doc2);
    if (!docType)
      throw new invalid_doc_error_default(doc2);
    if (onEnter?.(doc2) !== !1)
      switch (docType) {
        case DOC_TYPE_ARRAY:
        case DOC_TYPE_FILL: {
          let parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;
          for (let ic = parts.length, i = ic - 1; i >= 0; --i)
            docsStack.push(parts[i]);
          break;
        }
        case DOC_TYPE_IF_BREAK:
          docsStack.push(doc2.flatContents, doc2.breakContents);
          break;
        case DOC_TYPE_GROUP:
          if (shouldTraverseConditionalGroups && doc2.expandedStates)
            for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i)
              docsStack.push(doc2.expandedStates[i]);
          else
            docsStack.push(doc2.contents);
          break;
        case DOC_TYPE_ALIGN:
        case DOC_TYPE_INDENT:
        case DOC_TYPE_INDENT_IF_BREAK:
        case DOC_TYPE_LABEL:
        case DOC_TYPE_LINE_SUFFIX:
          docsStack.push(doc2.contents);
          break;
        case DOC_TYPE_STRING:
        case DOC_TYPE_CURSOR:
        case DOC_TYPE_TRIM:
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        case DOC_TYPE_LINE:
        case DOC_TYPE_BREAK_PARENT:
          break;
        default:
          throw new invalid_doc_error_default(doc2);
      }
  }
}
function mapDoc(doc, cb) {
  if (typeof doc == "string")
    return cb(doc);
  let mapped = /* @__PURE__ */ new Map();
  return rec(doc);
  function rec(doc2) {
    if (mapped.has(doc2))
      return mapped.get(doc2);
    let result = process22(doc2);
    return mapped.set(doc2, result), result;
  }
  function process22(doc2) {
    switch (get_doc_type_default(doc2)) {
      case DOC_TYPE_ARRAY:
        return cb(doc2.map(rec));
      case DOC_TYPE_FILL:
        return cb({
          ...doc2,
          parts: doc2.parts.map(rec)
        });
      case DOC_TYPE_IF_BREAK:
        return cb({
          ...doc2,
          breakContents: rec(doc2.breakContents),
          flatContents: rec(doc2.flatContents)
        });
      case DOC_TYPE_GROUP: {
        let {
          expandedStates,
          contents
        } = doc2;
        return expandedStates ? (expandedStates = expandedStates.map(rec), contents = expandedStates[0]) : contents = rec(contents), cb({
          ...doc2,
          contents,
          expandedStates
        });
      }
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
      case DOC_TYPE_LINE_SUFFIX:
        return cb({
          ...doc2,
          contents: rec(doc2.contents)
        });
      case DOC_TYPE_STRING:
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_BREAK_PARENT:
        return cb(doc2);
      default:
        throw new invalid_doc_error_default(doc2);
    }
  }
}
function findInDoc(doc, fn, defaultValue) {
  let result = defaultValue, shouldSkipFurtherProcessing = !1;
  function findInDocOnEnterFn(doc2) {
    if (shouldSkipFurtherProcessing)
      return !1;
    let maybeResult = fn(doc2);
    maybeResult !== void 0 && (shouldSkipFurtherProcessing = !0, result = maybeResult);
  }
  return traverse_doc_default(doc, findInDocOnEnterFn), result;
}
function willBreakFn(doc) {
  if (doc.type === DOC_TYPE_GROUP && doc.break || doc.type === DOC_TYPE_LINE && doc.hard || doc.type === DOC_TYPE_BREAK_PARENT)
    return !0;
}
function willBreak(doc) {
  return findInDoc(doc, willBreakFn, !1);
}
function breakParentGroup(groupStack) {
  if (groupStack.length > 0) {
    let parentGroup = method_at_default(
      /* OPTIONAL_OBJECT: false */
      0,
      groupStack,
      -1
    );
    !parentGroup.expandedStates && !parentGroup.break && (parentGroup.break = "propagated");
  }
  return null;
}
function propagateBreaks(doc) {
  let alreadyVisitedSet = /* @__PURE__ */ new Set(), groupStack = [];
  function propagateBreaksOnEnterFn(doc2) {
    if (doc2.type === DOC_TYPE_BREAK_PARENT && breakParentGroup(groupStack), doc2.type === DOC_TYPE_GROUP) {
      if (groupStack.push(doc2), alreadyVisitedSet.has(doc2))
        return !1;
      alreadyVisitedSet.add(doc2);
    }
  }
  function propagateBreaksOnExitFn(doc2) {
    doc2.type === DOC_TYPE_GROUP && groupStack.pop().break && breakParentGroup(groupStack);
  }
  traverse_doc_default(
    doc,
    propagateBreaksOnEnterFn,
    propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    !0
  );
}
function removeLinesFn(doc) {
  return doc.type === DOC_TYPE_LINE && !doc.hard ? doc.soft ? "" : " " : doc.type === DOC_TYPE_IF_BREAK ? doc.flatContents : doc;
}
function removeLines(doc) {
  return mapDoc(doc, removeLinesFn);
}
function stripTrailingHardlineFromParts(parts) {
  for (parts = [...parts]; parts.length >= 2 && method_at_default(
    /* OPTIONAL_OBJECT: false */
    0,
    parts,
    -2
  ).type === DOC_TYPE_LINE && method_at_default(
    /* OPTIONAL_OBJECT: false */
    0,
    parts,
    -1
  ).type === DOC_TYPE_BREAK_PARENT; )
    parts.length -= 2;
  if (parts.length > 0) {
    let lastPart = stripTrailingHardlineFromDoc(method_at_default(
      /* OPTIONAL_OBJECT: false */
      0,
      parts,
      -1
    ));
    parts[parts.length - 1] = lastPart;
  }
  return parts;
}
function stripTrailingHardlineFromDoc(doc) {
  switch (get_doc_type_default(doc)) {
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_GROUP:
    case DOC_TYPE_LINE_SUFFIX:
    case DOC_TYPE_LABEL: {
      let contents = stripTrailingHardlineFromDoc(doc.contents);
      return {
        ...doc,
        contents
      };
    }
    case DOC_TYPE_IF_BREAK:
      return {
        ...doc,
        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),
        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)
      };
    case DOC_TYPE_FILL:
      return {
        ...doc,
        parts: stripTrailingHardlineFromParts(doc.parts)
      };
    case DOC_TYPE_ARRAY:
      return stripTrailingHardlineFromParts(doc);
    case DOC_TYPE_STRING:
      return trimNewlinesEnd(doc);
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc);
  }
  return doc;
}
function stripTrailingHardline(doc) {
  return stripTrailingHardlineFromDoc(cleanDoc(doc));
}
function cleanDocFn(doc) {
  switch (get_doc_type_default(doc)) {
    case DOC_TYPE_FILL:
      if (doc.parts.every((part) => part === ""))
        return "";
      break;
    case DOC_TYPE_GROUP:
      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates)
        return "";
      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates)
        return doc.contents;
      break;
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_LINE_SUFFIX:
      if (!doc.contents)
        return "";
      break;
    case DOC_TYPE_IF_BREAK:
      if (!doc.flatContents && !doc.breakContents)
        return "";
      break;
    case DOC_TYPE_ARRAY: {
      let parts = [];
      for (let part of doc) {
        if (!part)
          continue;
        let [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
        typeof currentPart == "string" && typeof method_at_default(
          /* OPTIONAL_OBJECT: false */
          0,
          parts,
          -1
        ) == "string" ? parts[parts.length - 1] += currentPart : parts.push(currentPart), parts.push(...restParts);
      }
      return parts.length === 0 ? "" : parts.length === 1 ? parts[0] : parts;
    }
    case DOC_TYPE_STRING:
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_LABEL:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc);
  }
  return doc;
}
function cleanDoc(doc) {
  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));
}
function replaceEndOfLine(doc, replacement = literalline) {
  return mapDoc(doc, (currentDoc) => typeof currentDoc == "string" ? join(replacement, currentDoc.split(`
`)) : currentDoc);
}
function canBreakFn(doc) {
  if (doc.type === DOC_TYPE_LINE)
    return !0;
}
function canBreak(doc) {
  return findInDoc(doc, canBreakFn, !1);
}
function indent(contents) {
  return assertDoc(contents), { type: DOC_TYPE_INDENT, contents };
}
function align(alignType, contents) {
  return assertAlignType(alignType), assertDoc(contents), { type: DOC_TYPE_ALIGN, contents, n: alignType };
}
function dedentToRoot(contents) {
  return align(Number.NEGATIVE_INFINITY, contents);
}
function markAsRoot(contents) {
  return align({ type: "root" }, contents);
}
function dedent(contents) {
  return align(-1, contents);
}
function addAlignmentToDoc(doc, size, tabWidth) {
  assertDoc(doc);
  let aligned = doc;
  if (size > 0) {
    for (let level = 0; level < Math.floor(size / tabWidth); ++level)
      aligned = indent(aligned);
    aligned = align(size % tabWidth, aligned), aligned = align(Number.NEGATIVE_INFINITY, aligned);
  }
  return aligned;
}
function fill(parts) {
  return assertDocFillParts(parts), { type: DOC_TYPE_FILL, parts };
}
function group(contents, options8 = {}) {
  return assertDoc(contents), assertDocArray(
    options8.expandedStates,
    /* optional */
    !0
  ), {
    type: DOC_TYPE_GROUP,
    id: options8.id,
    contents,
    break: !!options8.shouldBreak,
    expandedStates: options8.expandedStates
  };
}
function conditionalGroup(states, options8) {
  return group(states[0], { ...options8, expandedStates: states });
}
function ifBreak(breakContents, flatContents = "", options8 = {}) {
  return assertDoc(breakContents), flatContents !== "" && assertDoc(flatContents), {
    type: DOC_TYPE_IF_BREAK,
    breakContents,
    flatContents,
    groupId: options8.groupId
  };
}
function indentIfBreak(contents, options8) {
  return assertDoc(contents), {
    type: DOC_TYPE_INDENT_IF_BREAK,
    contents,
    groupId: options8.groupId,
    negate: options8.negate
  };
}
function join(separator, docs) {
  assertDoc(separator), assertDocArray(docs);
  let parts = [];
  for (let i = 0; i < docs.length; i++)
    i !== 0 && parts.push(separator), parts.push(docs[i]);
  return parts;
}
function label(label2, contents) {
  return assertDoc(contents), label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;
}
function lineSuffix(contents) {
  return assertDoc(contents), { type: DOC_TYPE_LINE_SUFFIX, contents };
}
function convertEndOfLineOptionToCharacter(endOfLineOption) {
  return endOfLineOption === OPTION_CR ? CHARACTER_CR : endOfLineOption === OPTION_CRLF ? CHARACTER_CRLF : DEFAULT_EOL;
}
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
function getStringWidth(text) {
  if (!text)
    return 0;
  if (!notAsciiRegex.test(text))
    return text.length;
  text = text.replace(
    emoji_regex_default(),
    (match) => narrowEmojisSet.has(match) ? " " : "  "
  );
  let width = 0;
  for (let character of text) {
    let codePoint = character.codePointAt(0);
    codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 768 && codePoint <= 879 || codePoint >= 65024 && codePoint <= 65039 || (width += isFullWidth(codePoint) || isWide(codePoint) ? 2 : 1);
  }
  return width;
}
function generateIndent(indent22, command, options8) {
  let queue = command.type === INDENT_COMMAND_TYPE_DEDENT ? indent22.queue.slice(0, -1) : [...indent22.queue, command], value = "", length = 0, lastTabs = 0, lastSpaces = 0;
  for (let command2 of queue)
    switch (command2.type) {
      case INDENT_COMMAND_TYPE_INDENT:
        flush(), options8.useTabs ? addTabs(1) : addSpaces(options8.tabWidth);
        break;
      case INDENT_COMMAND_TYPE_STRING: {
        let { string } = command2;
        flush(), value += string, length += string.length;
        break;
      }
      case INDENT_COMMAND_TYPE_WIDTH: {
        let { width } = command2;
        lastTabs += 1, lastSpaces += width;
        break;
      }
      default:
        throw new Error(`Unexpected indent comment '${command2.type}'.`);
    }
  return flushSpaces(), { ...indent22, value, length, queue };
  function addTabs(count) {
    value += "	".repeat(count), length += options8.tabWidth * count;
  }
  function addSpaces(count) {
    value += " ".repeat(count), length += count;
  }
  function flush() {
    options8.useTabs ? flushTabs() : flushSpaces();
  }
  function flushTabs() {
    lastTabs > 0 && addTabs(lastTabs), resetLast();
  }
  function flushSpaces() {
    lastSpaces > 0 && addSpaces(lastSpaces), resetLast();
  }
  function resetLast() {
    lastTabs = 0, lastSpaces = 0;
  }
}
function makeAlign(indent22, indentOptions, options8) {
  if (!indentOptions)
    return indent22;
  if (indentOptions.type === "root")
    return { ...indent22, root: indent22 };
  if (indentOptions === Number.NEGATIVE_INFINITY)
    return indent22.root;
  let command;
  return typeof indentOptions == "number" ? indentOptions < 0 ? command = INDENT_COMMAND_DEDENT : command = { type: INDENT_COMMAND_TYPE_WIDTH, width: indentOptions } : command = { type: INDENT_COMMAND_TYPE_STRING, string: indentOptions }, generateIndent(indent22, command, options8);
}
function makeIndent(indent22, options8) {
  return generateIndent(indent22, INDENT_COMMAND_INDENT, options8);
}
function getTrailingIndentionLength(text) {
  let length = 0;
  for (let index = text.length - 1; index >= 0; index--) {
    let character = text[index];
    if (character === " " || character === "	")
      length++;
    else
      break;
  }
  return length;
}
function trimIndentation(text) {
  let length = getTrailingIndentionLength(text);
  return { text: length === 0 ? text : text.slice(0, text.length - length), count: length };
}
function fits(next, restCommands, remainingWidth, hasLineSuffix, groupModeMap, mustBeFlat) {
  if (remainingWidth === Number.POSITIVE_INFINITY)
    return !0;
  let restCommandsIndex = restCommands.length, hasPendingSpace = !1, commands = [next], output = "";
  for (; remainingWidth >= 0; ) {
    if (commands.length === 0) {
      if (restCommandsIndex === 0)
        return !0;
      commands.push(restCommands[--restCommandsIndex]);
      continue;
    }
    let {
      mode,
      doc
    } = commands.pop(), docType = get_doc_type_default(doc);
    switch (docType) {
      case DOC_TYPE_STRING:
        doc && (hasPendingSpace && (output += " ", remainingWidth -= 1, hasPendingSpace = !1), output += doc, remainingWidth -= get_string_width_default(doc));
        break;
      case DOC_TYPE_ARRAY:
      case DOC_TYPE_FILL: {
        let parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts, end = doc[DOC_FILL_PRINTED_LENGTH] ?? 0;
        for (let index = parts.length - 1; index >= end; index--)
          commands.push({
            mode,
            doc: parts[index]
          });
        break;
      }
      case DOC_TYPE_INDENT:
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
        commands.push({
          mode,
          doc: doc.contents
        });
        break;
      case DOC_TYPE_TRIM: {
        let {
          text,
          count
        } = trimIndentation(output);
        output = text, remainingWidth += count;
        break;
      }
      case DOC_TYPE_GROUP: {
        if (mustBeFlat && doc.break)
          return !1;
        let groupMode = doc.break ? MODE_BREAK : mode, contents = doc.expandedStates && groupMode === MODE_BREAK ? method_at_default(
          /* OPTIONAL_OBJECT: false */
          0,
          doc.expandedStates,
          -1
        ) : doc.contents;
        commands.push({
          mode: groupMode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_IF_BREAK: {
        let contents = (doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode) === MODE_BREAK ? doc.breakContents : doc.flatContents;
        contents && commands.push({
          mode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_LINE:
        if (mode === MODE_BREAK || doc.hard)
          return !0;
        doc.soft || (hasPendingSpace = !0);
        break;
      case DOC_TYPE_LINE_SUFFIX:
        hasLineSuffix = !0;
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        if (hasLineSuffix)
          return !1;
        break;
    }
  }
  return !1;
}
function printDocToString(doc, options8) {
  let groupModeMap = /* @__PURE__ */ Object.create(null), width = options8.printWidth, newLine = convertEndOfLineOptionToCharacter(options8.endOfLine), position = 0, commands = [{
    indent: ROOT_INDENT,
    mode: MODE_BREAK,
    doc
  }], output = "", shouldRemeasure = !1, lineSuffix22 = [], cursorPositions = [], settledOutput = [], settledCursorPositions = [], settledTextLength = 0;
  for (propagateBreaks(doc); commands.length > 0; ) {
    let {
      indent: indent22,
      mode,
      doc: doc2
    } = commands.pop();
    switch (get_doc_type_default(doc2)) {
      case DOC_TYPE_STRING: {
        let formatted2 = newLine !== `
` ? method_replace_all_default(
          /* OPTIONAL_OBJECT: false */
          0,
          doc2,
          `
`,
          newLine
        ) : doc2;
        formatted2 && (output += formatted2, commands.length > 0 && (position += get_string_width_default(formatted2)));
        break;
      }
      case DOC_TYPE_ARRAY:
        for (let index = doc2.length - 1; index >= 0; index--)
          commands.push({
            indent: indent22,
            mode,
            doc: doc2[index]
          });
        break;
      case DOC_TYPE_CURSOR:
        if (cursorPositions.length >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        cursorPositions.push(settledTextLength + output.length);
        break;
      case DOC_TYPE_INDENT:
        commands.push({
          indent: makeIndent(indent22, options8),
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_ALIGN:
        commands.push({
          indent: makeAlign(indent22, doc2.n, options8),
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_TRIM:
        trim2();
        break;
      case DOC_TYPE_GROUP:
        switch (mode) {
          case MODE_FLAT:
            if (!shouldRemeasure) {
              commands.push({
                indent: indent22,
                mode: doc2.break ? MODE_BREAK : MODE_FLAT,
                doc: doc2.contents
              });
              break;
            }
          // fallthrough
          case MODE_BREAK: {
            shouldRemeasure = !1;
            let next = {
              indent: indent22,
              mode: MODE_FLAT,
              doc: doc2.contents
            }, remainingWidth = width - position, hasLineSuffix = lineSuffix22.length > 0;
            if (!doc2.break && fits(next, commands, remainingWidth, hasLineSuffix, groupModeMap))
              commands.push(next);
            else if (doc2.expandedStates) {
              let mostExpanded = method_at_default(
                /* OPTIONAL_OBJECT: false */
                0,
                doc2.expandedStates,
                -1
              );
              if (doc2.break) {
                commands.push({
                  indent: indent22,
                  mode: MODE_BREAK,
                  doc: mostExpanded
                });
                break;
              } else
                for (let index = 1; index < doc2.expandedStates.length + 1; index++)
                  if (index >= doc2.expandedStates.length) {
                    commands.push({
                      indent: indent22,
                      mode: MODE_BREAK,
                      doc: mostExpanded
                    });
                    break;
                  } else {
                    let state = doc2.expandedStates[index], cmd = {
                      indent: indent22,
                      mode: MODE_FLAT,
                      doc: state
                    };
                    if (fits(cmd, commands, remainingWidth, hasLineSuffix, groupModeMap)) {
                      commands.push(cmd);
                      break;
                    }
                  }
            } else
              commands.push({
                indent: indent22,
                mode: MODE_BREAK,
                doc: doc2.contents
              });
            break;
          }
        }
        doc2.id && (groupModeMap[doc2.id] = method_at_default(
          /* OPTIONAL_OBJECT: false */
          0,
          commands,
          -1
        ).mode);
        break;
      // Fills each line with as much code as possible before moving to a new
      // line with the same indentation.
      //
      // Expects doc.parts to be an array of alternating content and
      // whitespace. The whitespace contains the linebreaks.
      //
      // For example:
      //   ["I", line, "love", line, "monkeys"]
      // or
      //   [{ type: group, ... }, softline, { type: group, ... }]
      //
      // It uses this parts structure to handle three main layout cases:
      // * The first two content items fit on the same line without
      //   breaking
      //   -> output the first content item and the whitespace "flat".
      // * Only the first content item fits on the line without breaking
      //   -> output the first content item "flat" and the whitespace with
      //   "break".
      // * Neither content item fits on the line without breaking
      //   -> output the first content item and the whitespace with "break".
      case DOC_TYPE_FILL: {
        let remainingWidth = width - position, offset = doc2[DOC_FILL_PRINTED_LENGTH] ?? 0, {
          parts
        } = doc2, length = parts.length - offset;
        if (length === 0)
          break;
        let content = parts[offset + 0], whitespace = parts[offset + 1], contentFlatCommand = {
          indent: indent22,
          mode: MODE_FLAT,
          doc: content
        }, contentBreakCommand = {
          indent: indent22,
          mode: MODE_BREAK,
          doc: content
        }, contentFits = fits(contentFlatCommand, [], remainingWidth, lineSuffix22.length > 0, groupModeMap, !0);
        if (length === 1) {
          contentFits ? commands.push(contentFlatCommand) : commands.push(contentBreakCommand);
          break;
        }
        let whitespaceFlatCommand = {
          indent: indent22,
          mode: MODE_FLAT,
          doc: whitespace
        }, whitespaceBreakCommand = {
          indent: indent22,
          mode: MODE_BREAK,
          doc: whitespace
        };
        if (length === 2) {
          contentFits ? commands.push(whitespaceFlatCommand, contentFlatCommand) : commands.push(whitespaceBreakCommand, contentBreakCommand);
          break;
        }
        let secondContent = parts[offset + 2], remainingCommand = {
          indent: indent22,
          mode,
          doc: {
            ...doc2,
            [DOC_FILL_PRINTED_LENGTH]: offset + 2
          }
        }, firstAndSecondContentFits = fits({
          indent: indent22,
          mode: MODE_FLAT,
          doc: [content, whitespace, secondContent]
        }, [], remainingWidth, lineSuffix22.length > 0, groupModeMap, !0);
        commands.push(remainingCommand), firstAndSecondContentFits ? commands.push(whitespaceFlatCommand, contentFlatCommand) : contentFits ? commands.push(whitespaceBreakCommand, contentFlatCommand) : commands.push(whitespaceBreakCommand, contentBreakCommand);
        break;
      }
      case DOC_TYPE_IF_BREAK:
      case DOC_TYPE_INDENT_IF_BREAK: {
        let groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;
        if (groupMode === MODE_BREAK) {
          let breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);
          breakContents && commands.push({
            indent: indent22,
            mode,
            doc: breakContents
          });
        }
        if (groupMode === MODE_FLAT) {
          let flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;
          flatContents && commands.push({
            indent: indent22,
            mode,
            doc: flatContents
          });
        }
        break;
      }
      case DOC_TYPE_LINE_SUFFIX:
        lineSuffix22.push({
          indent: indent22,
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        lineSuffix22.length > 0 && commands.push({
          indent: indent22,
          mode,
          doc: hardlineWithoutBreakParent
        });
        break;
      case DOC_TYPE_LINE:
        switch (mode) {
          case MODE_FLAT:
            if (doc2.hard)
              shouldRemeasure = !0;
            else {
              doc2.soft || (output += " ", position += 1);
              break;
            }
          // fallthrough
          case MODE_BREAK:
            if (lineSuffix22.length > 0) {
              commands.push({
                indent: indent22,
                mode,
                doc: doc2
              }, ...lineSuffix22.reverse()), lineSuffix22.length = 0;
              break;
            }
            doc2.literal ? (output += newLine, position = 0, indent22.root && (indent22.root.value && (output += indent22.root.value), position = indent22.root.length)) : (trim2(), output += newLine + indent22.value, position = indent22.length);
            break;
        }
        break;
      case DOC_TYPE_LABEL:
        commands.push({
          indent: indent22,
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc2);
    }
    commands.length === 0 && lineSuffix22.length > 0 && (commands.push(...lineSuffix22.reverse()), lineSuffix22.length = 0);
  }
  let formatted = settledOutput.join("") + output, finalCursorPositions = [...settledCursorPositions, ...cursorPositions];
  if (finalCursorPositions.length !== 2)
    return {
      formatted
    };
  let cursorNodeStart = finalCursorPositions[0];
  return {
    formatted,
    cursorNodeStart,
    cursorNodeText: formatted.slice(cursorNodeStart, method_at_default(
      /* OPTIONAL_OBJECT: false */
      0,
      finalCursorPositions,
      -1
    ))
  };
  function trim2() {
    let {
      text: trimmed,
      count
    } = trimIndentation(output);
    trimmed && (settledOutput.push(trimmed), settledTextLength += trimmed.length), output = "", position -= count, cursorPositions.length > 0 && (settledCursorPositions.push(...cursorPositions.map((position2) => Math.min(position2, settledTextLength))), cursorPositions.length = 0);
  }
}
var __defProp, __export2, public_exports, OPTIONAL_OBJECT, createMethodShim, at, method_at_default, noop, noop_default, DOC_TYPE_STRING, DOC_TYPE_ARRAY, DOC_TYPE_CURSOR, DOC_TYPE_INDENT, DOC_TYPE_ALIGN, DOC_TYPE_TRIM, DOC_TYPE_GROUP, DOC_TYPE_FILL, DOC_TYPE_IF_BREAK, DOC_TYPE_INDENT_IF_BREAK, DOC_TYPE_LINE_SUFFIX, DOC_TYPE_LINE_SUFFIX_BOUNDARY, DOC_TYPE_LINE, DOC_TYPE_LABEL, DOC_TYPE_BREAK_PARENT, VALID_OBJECT_DOC_TYPES, get_doc_type_default, disjunctionListFormat, InvalidDocError, invalid_doc_error_default, traverseDocOnExitStackMarker, traverse_doc_default, assertDoc, assertDocArray, assertDocFillParts, assertAlignType, breakParent, cursor, line, softline, hardlineWithoutBreakParent, hardline, literallineWithoutBreakParent, literalline, lineSuffixBoundary, trim, stringReplaceAll, replaceAll, method_replace_all_default, OPTION_CR, OPTION_CRLF, CHARACTER_CR, CHARACTER_CRLF, CHARACTER_LF, DEFAULT_EOL, emoji_regex_default, narrow_emojis_evaluate_default, notAsciiRegex, narrowEmojisSet, get_string_width_default, INDENT_COMMAND_TYPE_INDENT, INDENT_COMMAND_TYPE_DEDENT, INDENT_COMMAND_TYPE_WIDTH, INDENT_COMMAND_TYPE_STRING, INDENT_COMMAND_INDENT, INDENT_COMMAND_DEDENT, ROOT_INDENT, MODE_BREAK, MODE_FLAT, DOC_FILL_PRINTED_LENGTH, builders, printer, utils, init_doc = __esm({
  "../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/doc.mjs"() {
    init_cjs_shims();
    __defProp = Object.defineProperty, __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: !0 });
    }, public_exports = {};
    __export2(public_exports, {
      builders: () => builders,
      printer: () => printer,
      utils: () => utils
    });
    OPTIONAL_OBJECT = 1, createMethodShim = (methodName, getImplementation) => (flags, object, ...arguments_) => flags | OPTIONAL_OBJECT && object == null ? void 0 : (getImplementation.call(object) ?? object[methodName]).apply(object, arguments_);
    at = createMethodShim("at", function() {
      if (Array.isArray(this) || typeof this == "string")
        return stringOrArrayAt;
    }), method_at_default = at, noop = () => {
    }, noop_default = noop, DOC_TYPE_STRING = /** @type {const} */
    "string", DOC_TYPE_ARRAY = /** @type {const} */
    "array", DOC_TYPE_CURSOR = /** @type {const} */
    "cursor", DOC_TYPE_INDENT = /** @type {const} */
    "indent", DOC_TYPE_ALIGN = /** @type {const} */
    "align", DOC_TYPE_TRIM = /** @type {const} */
    "trim", DOC_TYPE_GROUP = /** @type {const} */
    "group", DOC_TYPE_FILL = /** @type {const} */
    "fill", DOC_TYPE_IF_BREAK = /** @type {const} */
    "if-break", DOC_TYPE_INDENT_IF_BREAK = /** @type {const} */
    "indent-if-break", DOC_TYPE_LINE_SUFFIX = /** @type {const} */
    "line-suffix", DOC_TYPE_LINE_SUFFIX_BOUNDARY = /** @type {const} */
    "line-suffix-boundary", DOC_TYPE_LINE = /** @type {const} */
    "line", DOC_TYPE_LABEL = /** @type {const} */
    "label", DOC_TYPE_BREAK_PARENT = /** @type {const} */
    "break-parent", VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
      DOC_TYPE_CURSOR,
      DOC_TYPE_INDENT,
      DOC_TYPE_ALIGN,
      DOC_TYPE_TRIM,
      DOC_TYPE_GROUP,
      DOC_TYPE_FILL,
      DOC_TYPE_IF_BREAK,
      DOC_TYPE_INDENT_IF_BREAK,
      DOC_TYPE_LINE_SUFFIX,
      DOC_TYPE_LINE_SUFFIX_BOUNDARY,
      DOC_TYPE_LINE,
      DOC_TYPE_LABEL,
      DOC_TYPE_BREAK_PARENT
    ]);
    get_doc_type_default = getDocType, disjunctionListFormat = (list) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list);
    InvalidDocError = class extends Error {
      name = "InvalidDocError";
      constructor(doc) {
        super(getDocErrorMessage(doc)), this.doc = doc;
      }
    }, invalid_doc_error_default = InvalidDocError, traverseDocOnExitStackMarker = {};
    traverse_doc_default = traverseDoc;
    assertDoc = noop_default, assertDocArray = noop_default, assertDocFillParts = noop_default, assertAlignType = noop_default;
    breakParent = { type: DOC_TYPE_BREAK_PARENT }, cursor = { type: DOC_TYPE_CURSOR };
    line = { type: DOC_TYPE_LINE }, softline = { type: DOC_TYPE_LINE, soft: !0 }, hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: !0 }, hardline = [hardlineWithoutBreakParent, breakParent], literallineWithoutBreakParent = {
      type: DOC_TYPE_LINE,
      hard: !0,
      literal: !0
    }, literalline = [literallineWithoutBreakParent, breakParent];
    lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY }, trim = { type: DOC_TYPE_TRIM }, stringReplaceAll = String.prototype.replaceAll ?? function(pattern, replacement) {
      return pattern.global ? this.replace(pattern, replacement) : this.split(pattern).join(replacement);
    }, replaceAll = createMethodShim("replaceAll", function() {
      if (typeof this == "string")
        return stringReplaceAll;
    }), method_replace_all_default = replaceAll, OPTION_CR = "cr", OPTION_CRLF = "crlf", CHARACTER_CR = "\r", CHARACTER_CRLF = `\r
`, CHARACTER_LF = `
`, DEFAULT_EOL = CHARACTER_LF;
    emoji_regex_default = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    narrow_emojis_evaluate_default = "\xA9\xAE\u203C\u2049\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21A9\u21AA\u2328\u23CF\u23F1\u23F2\u23F8\u23F9\u23FA\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600\u2601\u2602\u2603\u2604\u260E\u2611\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638\u2639\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694\u2695\u2696\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F1\u26F7\u26F8\u26F9\u2702\u2708\u2709\u270C\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u2764\u27A1\u2934\u2935\u2B05\u2B06\u2B07", notAsciiRegex = /[^\x20-\x7F]/u, narrowEmojisSet = new Set(narrow_emojis_evaluate_default);
    get_string_width_default = getStringWidth, INDENT_COMMAND_TYPE_INDENT = 0, INDENT_COMMAND_TYPE_DEDENT = 1, INDENT_COMMAND_TYPE_WIDTH = 2, INDENT_COMMAND_TYPE_STRING = 3, INDENT_COMMAND_INDENT = { type: INDENT_COMMAND_TYPE_INDENT }, INDENT_COMMAND_DEDENT = { type: INDENT_COMMAND_TYPE_DEDENT }, ROOT_INDENT = {
      value: "",
      length: 0,
      queue: [],
      get root() {
        return ROOT_INDENT;
      }
    };
    MODE_BREAK = Symbol("MODE_BREAK"), MODE_FLAT = Symbol("MODE_FLAT"), DOC_FILL_PRINTED_LENGTH = Symbol("DOC_FILL_PRINTED_LENGTH");
    builders = {
      join,
      line,
      softline,
      hardline,
      literalline,
      group,
      conditionalGroup,
      fill,
      lineSuffix,
      lineSuffixBoundary,
      cursor,
      breakParent,
      ifBreak,
      trim,
      indent,
      indentIfBreak,
      align,
      addAlignmentToDoc,
      markAsRoot,
      dedentToRoot,
      dedent,
      hardlineWithoutBreakParent,
      literallineWithoutBreakParent,
      label,
      // TODO: Remove this in v4
      concat: (parts) => parts
    }, printer = { printDocToString }, utils = {
      willBreak,
      traverseDoc: traverse_doc_default,
      findInDoc,
      mapDoc,
      removeLines,
      stripTrailingHardline,
      replaceEndOfLine,
      canBreak
    };
  }
});

// ../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/index.mjs
import { createRequire as __prettierCreateRequire } from "module";
import { fileURLToPath as __prettierFileUrlToPath } from "url";
import { dirname as __prettierDirname } from "path";
import path10 from "path";
import * as path from "path";
import * as url from "url";
import path5 from "path";
import * as path4 from "path";
import * as fs from "fs/promises";
import * as path2 from "path";
import process2 from "process";
import * as path3 from "path";
import process3 from "process";
import path9 from "path";
import { pathToFileURL as pathToFileURL2 } from "url";
import fs2 from "fs/promises";
import path8 from "path";
import { pathToFileURL as pathToFileURL4 } from "url";
import assert3 from "assert";
import { statSync, realpathSync } from "fs";
import process4 from "process";
import { fileURLToPath as fileURLToPath4, pathToFileURL as pathToFileURL3 } from "url";
import path7 from "path";
import { builtinModules } from "module";
import { fileURLToPath as fileURLToPath3 } from "url";
import fs3 from "fs";
import path6 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import v8 from "v8";
import assert2 from "assert";
import { format, inspect } from "util";
import { createRequire } from "module";
import { ok, strictEqual } from "assert";
import path11 from "path";
import { fileURLToPath as fileURLToPath5 } from "url";
import path13 from "path";
import { pathToFileURL as pathToFileURL5 } from "url";
import path12 from "path";
import path14 from "path";
import url2 from "url";
function diffLines(oldStr, newStr, options8) {
  return lineDiff.diff(oldStr, newStr, options8);
}
function tokenize(value, options8) {
  options8.stripTrailingCr && (value = value.replace(/\r\n/g, `
`));
  let retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
  for (let i = 0; i < linesAndNewlines.length; i++) {
    let line3 = linesAndNewlines[i];
    i % 2 && !options8.newlineIsToken ? retLines[retLines.length - 1] += line3 : retLines.push(line3);
  }
  return retLines;
}
function diffArrays(oldArr, newArr, options8) {
  return arrayDiff.diff(oldArr, newArr, options8);
}
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options8) {
  let optionsObj;
  options8 ? typeof options8 == "function" ? optionsObj = { callback: options8 } : optionsObj = options8 : optionsObj = {}, typeof optionsObj.context > "u" && (optionsObj.context = 4);
  let context = optionsObj.context;
  if (optionsObj.newlineIsToken)
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  if (optionsObj.callback) {
    let { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {
      let patch = diffLinesResultToPatch(diff);
      callback(patch);
    } }));
  } else
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  function diffLinesResultToPatch(diff) {
    if (!diff)
      return;
    diff.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    let hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i = 0; i < diff.length; i++) {
      let current = diff[i], lines = current.lines || splitLines(current.value);
      if (current.lines = lines, current.added || current.removed) {
        if (!oldRangeStart) {
          let prev = diff[i - 1];
          oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
        }
        for (let line3 of lines)
          curRange.push((current.added ? "+" : "-") + line3);
        current.added ? newLine += lines.length : oldLine += lines.length;
      } else {
        if (oldRangeStart)
          if (lines.length <= context * 2 && i < diff.length - 2)
            for (let line3 of contextLines(lines))
              curRange.push(line3);
          else {
            let contextSize = Math.min(lines.length, context);
            for (let line3 of contextLines(lines.slice(0, contextSize)))
              curRange.push(line3);
            let hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
          }
        oldLine += lines.length, newLine += lines.length;
      }
    }
    for (let hunk of hunks)
      for (let i = 0; i < hunk.lines.length; i++)
        hunk.lines[i].endsWith(`
`) ? hunk.lines[i] = hunk.lines[i].slice(0, -1) : (hunk.lines.splice(i + 1, 0, "\\ No newline at end of file"), i++);
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch) {
  if (Array.isArray(patch))
    return patch.map(formatPatch).join(`
`);
  let ret = [];
  patch.oldFileName == patch.newFileName && ret.push("Index: " + patch.oldFileName), ret.push("==================================================================="), ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader > "u" ? "" : "	" + patch.oldHeader)), ret.push("+++ " + patch.newFileName + (typeof patch.newHeader > "u" ? "" : "	" + patch.newHeader));
  for (let i = 0; i < patch.hunks.length; i++) {
    let hunk = patch.hunks[i];
    hunk.oldLines === 0 && (hunk.oldStart -= 1), hunk.newLines === 0 && (hunk.newStart -= 1), ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (let line3 of hunk.lines)
      ret.push(line3);
  }
  return ret.join(`
`) + `
`;
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options8) {
  if (typeof options8 == "function" && (options8 = { callback: options8 }), options8?.callback) {
    let { callback } = options8;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options8), { callback: (patchObj) => {
      callback(patchObj ? formatPatch(patchObj) : void 0);
    } }));
  } else {
    let patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options8);
    return patchObj ? formatPatch(patchObj) : void 0;
  }
}
function splitLines(text) {
  let hasTrailingNl = text.endsWith(`
`), result = text.split(`
`).map((line3) => line3 + `
`);
  return hasTrailingNl ? result.pop() : result.push(result.pop().slice(0, -1)), result;
}
function leven(first, second, options8) {
  if (first === second)
    return 0;
  let maxDistance = options8?.maxDistance, swap = first;
  first.length > second.length && (first = second, second = swap);
  let firstLength = first.length, secondLength = second.length;
  for (; firstLength > 0 && first.charCodeAt(~-firstLength) === second.charCodeAt(~-secondLength); )
    firstLength--, secondLength--;
  let start = 0;
  for (; start < firstLength && first.charCodeAt(start) === second.charCodeAt(start); )
    start++;
  if (firstLength -= start, secondLength -= start, maxDistance !== void 0 && secondLength - firstLength > maxDistance)
    return maxDistance;
  if (firstLength === 0)
    return maxDistance !== void 0 && secondLength > maxDistance ? maxDistance : secondLength;
  let bCharacterCode, result, temporary, temporary2, index = 0, index2 = 0;
  for (; index < firstLength; )
    characterCodeCache[index] = first.charCodeAt(start + index), array[index] = ++index;
  for (; index2 < secondLength; ) {
    for (bCharacterCode = second.charCodeAt(start + index2), temporary = index2++, result = index2, index = 0; index < firstLength; index++)
      temporary2 = bCharacterCode === characterCodeCache[index] ? temporary : temporary + 1, temporary = array[index], result = array[index] = temporary > result ? temporary2 > result ? result + 1 : temporary2 : temporary2 > temporary ? temporary + 1 : temporary2;
    if (maxDistance !== void 0) {
      let rowMinimum = result;
      for (index = 0; index < firstLength; index++)
        array[index] < rowMinimum && (rowMinimum = array[index]);
      if (rowMinimum > maxDistance)
        return maxDistance;
    }
  }
  return array.length = firstLength, characterCodeCache.length = firstLength, maxDistance !== void 0 && result > maxDistance ? maxDistance : result;
}
function closestMatch(target, candidates, options8) {
  if (!Array.isArray(candidates) || candidates.length === 0)
    return;
  let userMax = options8?.maxDistance, targetLength = target.length;
  for (let candidate of candidates)
    if (candidate === target)
      return candidate;
  if (userMax === 0)
    return;
  let best, bestDist = Number.POSITIVE_INFINITY, seen = /* @__PURE__ */ new Set();
  for (let candidate of candidates) {
    if (seen.has(candidate))
      continue;
    seen.add(candidate);
    let lengthDiff = Math.abs(candidate.length - targetLength);
    if (lengthDiff >= bestDist || userMax !== void 0 && lengthDiff > userMax)
      continue;
    let cap = Number.isFinite(bestDist) ? userMax === void 0 ? bestDist : Math.min(bestDist, userMax) : userMax, distance = cap === void 0 ? leven(target, candidate) : leven(target, candidate, { maxDistance: cap });
    if (userMax !== void 0 && distance > userMax)
      continue;
    let actualD = distance;
    if (cap !== void 0 && distance === cap && cap === userMax && (actualD = leven(target, candidate)), actualD < bestDist && (bestDist = actualD, best = candidate, bestDist === 0))
      break;
  }
  if (!(userMax !== void 0 && bestDist > userMax))
    return best;
}
function getDescription(key2, value, expected, descriptor) {
  return [
    `Invalid ${import_picocolors2.default.red(descriptor.key(key2))} value.`,
    `Expected ${import_picocolors2.default.blue(expected)},`,
    `but received ${value === VALUE_NOT_EXIST ? import_picocolors2.default.gray("nothing") : import_picocolors2.default.red(descriptor.value(value))}.`
  ].join(" ");
}
function getListDescription({ text, list }, printWidth) {
  let descriptions = [];
  return text && descriptions.push(`- ${import_picocolors2.default.blue(text)}`), list && descriptions.push([`- ${import_picocolors2.default.blue(list.title)}:`].concat(list.values.map((valueDescription) => getListDescription(valueDescription, printWidth - INDENTATION.length).replace(/^|\n/g, `$&${INDENTATION}`))).join(`
`)), chooseDescription(descriptions, printWidth);
}
function chooseDescription(descriptions, printWidth) {
  if (descriptions.length === 1)
    return descriptions[0];
  let [firstDescription, secondDescription] = descriptions, [firstWidth, secondWidth] = descriptions.map((description) => description.split(`
`, 1)[0].length);
  return firstWidth > printWidth && firstWidth > secondWidth ? secondDescription : firstDescription;
}
function createSchema(SchemaConstructor, parameters) {
  let schema = new SchemaConstructor(parameters), subSchema = Object.create(schema);
  for (let handlerKey of HANDLER_KEYS)
    handlerKey in parameters && (subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length));
  return subSchema;
}
function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
  return typeof handler == "function" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;
}
function wrapTransferResult({ from, to }) {
  return { from: [from], to };
}
function recordFromArray(array2, mainKey) {
  let record = /* @__PURE__ */ Object.create(null);
  for (let value of array2) {
    let key2 = value[mainKey];
    if (record[key2])
      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);
    record[key2] = value;
  }
  return record;
}
function mapFromArray(array2, mainKey) {
  let map = /* @__PURE__ */ new Map();
  for (let value of array2) {
    let key2 = value[mainKey];
    if (map.has(key2))
      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);
    map.set(key2, value);
  }
  return map;
}
function createAutoChecklist() {
  let map = /* @__PURE__ */ Object.create(null);
  return (id) => {
    let idString = JSON.stringify(id);
    return map[idString] ? !0 : (map[idString] = !0, !1);
  };
}
function partition(array2, predicate) {
  let trueArray = [], falseArray = [];
  for (let value of array2)
    predicate(value) ? trueArray.push(value) : falseArray.push(value);
  return [trueArray, falseArray];
}
function isInt(value) {
  return value === Math.floor(value);
}
function comparePrimitive(a, b) {
  if (a === b)
    return 0;
  let typeofA = typeof a, typeofB = typeof b, orders = [
    "undefined",
    "object",
    // null
    "boolean",
    "number",
    "string"
  ];
  return typeofA !== typeofB ? orders.indexOf(typeofA) - orders.indexOf(typeofB) : typeofA !== "string" ? Number(a) - Number(b) : a.localeCompare(b);
}
function normalizeInvalidHandler(invalidHandler) {
  return (...args) => {
    let errorMessageOrError = invalidHandler(...args);
    return typeof errorMessageOrError == "string" ? new Error(errorMessageOrError) : errorMessageOrError;
  };
}
function normalizeDefaultResult(result) {
  return result === void 0 ? {} : result;
}
function normalizeExpectedResult(result) {
  if (typeof result == "string")
    return { text: result };
  let { text, list } = result;
  return assert((text || list) !== void 0, "Unexpected `expected` result, there should be at least one field."), list ? {
    text,
    list: {
      title: list.title,
      values: list.values.map(normalizeExpectedResult)
    }
  } : { text };
}
function normalizeValidateResult(result, value) {
  return result === !0 ? !0 : result === !1 ? { value } : result;
}
function normalizeDeprecatedResult(result, value, doNotNormalizeTrue = !1) {
  return result === !1 ? !1 : result === !0 ? doNotNormalizeTrue ? !0 : [{ value }] : "value" in result ? [result] : result.length === 0 ? !1 : result;
}
function normalizeTransferResult(result, value) {
  return typeof result == "string" || "key" in result ? { from: value, to: result } : "from" in result ? { from: result.from, to: result.to } : { from: value, to: result.to };
}
function normalizeForwardResult(result, value) {
  return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];
}
function normalizeRedirectResult(result, value) {
  let redirect = normalizeForwardResult(typeof result == "object" && "redirect" in result ? result.redirect : result, value);
  return redirect.length === 0 ? { remain: value, redirect } : typeof result == "object" && "remain" in result ? { remain: result.remain, redirect } : { redirect };
}
function assert(isValid, message) {
  if (!isValid)
    throw new Error(message);
}
function createMockable(implementations) {
  let mocked = {
    ...implementations
  }, mockImplementation = (functionality, implementation) => {
    if (!Object.prototype.hasOwnProperty.call(implementations, functionality))
      throw new Error(`Unexpected mock '${functionality}'.`);
    mocked[functionality] = implementation;
  };
  return {
    mocked,
    implementations,
    mockImplementation,
    mockImplementations: (overrideImplementations) => {
      for (let [functionality, implementation] of Object.entries(overrideImplementations))
        mockImplementation(functionality, implementation);
    },
    mockRestore: () => {
      Object.assign(mocked, implementations);
    }
  };
}
function partition2(array2, predicate) {
  let result = [[], []];
  for (let value of array2)
    result[predicate(value) ? 0 : 1].push(value);
  return result;
}
async function findInDirectory(nameOrNames, { typeCheck, cwd, allowSymlinks = !0, filter: filter2 }) {
  let directory = toAbsolutePath(cwd) ?? process2.cwd(), names = Array.isArray(nameOrNames) ? nameOrNames : [nameOrNames];
  for (let name of names) {
    let fileOrDirectory = path2.join(directory, name), stats = await safeStat(fileOrDirectory, allowSymlinks);
    if (await typeCheck(stats) && (!filter2 || await filter2({ name, path: fileOrDirectory, stats })))
      return fileOrDirectory;
  }
}
async function safeStat(path15, allowSymlinks = !0) {
  try {
    return await (allowSymlinks ? fs.stat : fs.lstat)(path15);
  } catch {
  }
}
function findFile(nameOrNames, options8) {
  return findInDirectory(nameOrNames, { ...options8, typeCheck: isFile });
}
function findDirectory(nameOrNames, options8) {
  return findInDirectory(nameOrNames, { ...options8, typeCheck: isDirectory });
}
function* iterateDirectoryUp(from, to) {
  let directory = toAbsolutePath(from) ?? process3.cwd(), stopDirectory = toAbsolutePath(to);
  if (stopDirectory) {
    let relation = path3.relative(stopDirectory, directory);
    if (relation[0] === "." || relation === directory)
      return;
  }
  for (stopDirectory = stopDirectory ? directory.slice(0, stopDirectory.length) : path3.parse(directory).root; directory !== stopDirectory; )
    yield directory, directory = path3.dirname(directory);
  yield stopDirectory;
}
async function findProjectRoot(startDirectory, options8) {
  searcher ?? (searcher = new DirectorySearcher(DIRECTORIES, { allowSymlinks: !1 }));
  let directory = await searcher.search(startDirectory, {
    cache: options8.shouldCache
  });
  return directory ? path4.dirname(directory) : void 0;
}
function clearFindProjectRootCache() {
  searcher?.clearCache();
}
function editorConfigToPrettier(editorConfig) {
  if (!editorConfig)
    return;
  let result = {}, {
    indent_style,
    indent_size,
    tab_width,
    max_line_length,
    quote_type,
    end_of_line
  } = editorConfig;
  if (indent_style === "space" ? result.useTabs = !1 : (indent_style === "tab" || indent_size === "tab") && (result.useTabs = !0), result.useTabs === !1 && isPositiveInteger(indent_size) ? result.tabWidth = indent_size : isPositiveInteger(tab_width) && (result.tabWidth = tab_width), max_line_length === "off" ? result.printWidth = Number.POSITIVE_INFINITY : isPositiveInteger(max_line_length) && (result.printWidth = max_line_length), quote_type === "single" ? result.singleQuote = !0 : quote_type === "double" && (result.singleQuote = !1), (end_of_line === "lf" || end_of_line === "crlf" || end_of_line === "cr") && (result.endOfLine = end_of_line), Object.keys(result).length !== 0)
    return result;
}
function clearEditorconfigCache() {
  clearFindProjectRootCache(), editorconfigCache.clear();
}
async function loadEditorconfigInternal(file, { shouldCache }) {
  let directory = path5.dirname(file), root2 = await findProjectRoot(directory, { shouldCache }), editorConfig = await import_editorconfig.default.parse(file, { root: root2 });
  return editorconfig_to_prettier_default(editorConfig);
}
function loadEditorconfig(file, { shouldCache }) {
  return file = path5.resolve(file), (!shouldCache || !editorconfigCache.has(file)) && editorconfigCache.set(
    file,
    loadEditorconfigInternal(file, { shouldCache })
  ), editorconfigCache.get(file);
}
function internalize(holder, name, reviver) {
  let value = holder[name];
  if (value != null && typeof value == "object")
    if (Array.isArray(value))
      for (let i = 0; i < value.length; i++) {
        let key2 = String(i), replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (let key2 in value) {
        let replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return reviver.call(holder, name, value);
}
function lex() {
  for (lexState = "default", buffer = "", doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    let token2 = lexStates[lexState]();
    if (token2)
      return token2;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  let c2 = peek();
  return c2 === `
` ? (line2++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
}
function newToken(type, value) {
  return {
    type,
    value,
    line: line2,
    column
  };
}
function literal(s) {
  for (let c2 of s) {
    if (peek() !== c2)
      throw invalidChar(read());
    read();
  }
}
function escape() {
  switch (peek()) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "", c2 = peek();
  if (!util.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util.isHexDigit(c2)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "", count = 4;
  for (; count-- > 0; ) {
    let c2 = peek();
    if (!util.isHexDigit(c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0)
    root = value;
  else {
    let parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
      value,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (value !== null && typeof value == "object")
    stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    let current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  let current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c2) {
  return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line2}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line2}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line2}:${column}`);
}
function invalidIdentifier() {
  return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line2}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  let replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2])
    return replacements[c2];
  if (c2 < " ") {
    let hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  let err = new SyntaxError(message);
  return err.lineNumber = line2, err.columnNumber = column, err;
}
function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isKeyword(word) {
  return keywords.has(word);
}
function isColorSupported() {
  return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : import_picocolors4.default.isColorSupported;
}
function buildDefs(colors) {
  return {
    keyword: colors.cyan,
    capitalized: colors.yellow,
    jsxIdentifier: colors.yellow,
    punctuator: colors.yellow,
    number: colors.magenta,
    string: colors.green,
    regex: colors.magenta,
    comment: colors.gray,
    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
    gutter: colors.gray,
    marker: compose(colors.red, colors.bold),
    message: compose(colors.red, colors.bold),
    reset: colors.reset
  };
}
function getDefs(enabled) {
  return enabled ? defsOn : defsOff;
}
function highlight(text) {
  if (text === "") return "";
  let defs = getDefs(!0), highlighted = "";
  for (let {
    type,
    value
  } of tokenize2(text))
    type in defs ? highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join(`
`) : highlighted += value;
  return highlighted;
}
function getMarkerLines(loc, source2, opts) {
  let startLoc = Object.assign({
    column: 0,
    line: -1
  }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {
    linesAbove = 2,
    linesBelow = 3
  } = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column, start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source2.length, endLine + linesBelow);
  startLine === -1 && (start = 0), endLine === -1 && (end = source2.length);
  let lineDiff2 = endLine - startLine, markerLines = {};
  if (lineDiff2)
    for (let i = 0; i <= lineDiff2; i++) {
      let lineNumber = i + startLine;
      if (!startColumn)
        markerLines[lineNumber] = !0;
      else if (i === 0) {
        let sourceLength = source2[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i === lineDiff2)
        markerLines[lineNumber] = [0, endColumn];
      else {
        let sourceLength = source2[lineNumber - i].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  else
    startColumn === endColumn ? startColumn ? markerLines[startLine] = [startColumn, 0] : markerLines[startLine] = !0 : markerLines[startLine] = [startColumn, endColumn - startColumn];
  return {
    start,
    end,
    markerLines
  };
}
function codeFrameColumns(rawLines, loc, opts = {}) {
  let shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode, defs = getDefs(shouldHighlight), lines = rawLines.split(NEWLINE), {
    start,
    end,
    markerLines
  } = getMarkerLines(loc, lines, opts), hasColumns = loc.start && typeof loc.start.column == "number", numberMaxWidth = String(end).length, frame = (shouldHighlight ? highlight(rawLines) : rawLines).split(NEWLINE, end).slice(start, end).map((line3, index) => {
    let number = start + 1 + index, gutter = ` ${` ${number}`.slice(-numberMaxWidth)} |`, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
    if (hasMarker) {
      let markerLine = "";
      if (Array.isArray(hasMarker)) {
        let markerSpacing = line3.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
        markerLine = [`
 `, defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join(""), lastMarkerLine && opts.message && (markerLine += " " + defs.message(opts.message));
      }
      return [defs.marker(">"), defs.gutter(gutter), line3.length > 0 ? ` ${line3}` : "", markerLine].join("");
    } else
      return ` ${defs.gutter(gutter)}${line3.length > 0 ? ` ${line3}` : ""}`;
  }).join(`
`);
  return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`), shouldHighlight ? defs.reset(frame) : frame;
}
function getPosition(text, textIndex, options8) {
  let lineBreakBefore = textIndex === 0 ? -1 : text.lastIndexOf(`
`, textIndex - 1), [lineOffset, columnOffset] = getOffsets(options8);
  return {
    line: lineBreakBefore === -1 ? lineOffset : text.slice(0, lineBreakBefore + 1).match(/\n/g).length + lineOffset,
    column: textIndex - lineBreakBefore - 1 + columnOffset
  };
}
function indexToPosition(text, textIndex, options8) {
  if (typeof text != "string")
    throw new TypeError("Text parameter should be a string");
  if (!Number.isInteger(textIndex))
    throw new TypeError("Index parameter should be an integer");
  if (textIndex < 0 || textIndex > text.length)
    throw new RangeError("Index out of bounds");
  return getPosition(text, textIndex, options8);
}
function parseJson(string, reviver, fileName) {
  typeof reviver == "string" && (fileName = reviver, reviver = void 0);
  try {
    return JSON.parse(string, reviver);
  } catch (error) {
    throw new JSONError({
      jsonParseError: error,
      fileName,
      input: string
    });
  }
}
function getLineColFromPtr(string, ptr) {
  let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
  return [lines.length, lines.pop().length + 1];
}
function makeCodeBlock(string, line3, column2) {
  let lines = string.split(/\r\n|\n|\r/g), codeblock = "", numberLen = (Math.log10(line3 + 1) | 0) + 1;
  for (let i = line3 - 1; i <= line3 + 1; i++) {
    let l = lines[i - 1];
    l && (codeblock += i.toString().padEnd(numberLen, " "), codeblock += ":  ", codeblock += l, codeblock += `
`, i === line3 && (codeblock += " ".repeat(numberLen + column2 + 2), codeblock += `^
`));
  }
  return codeblock;
}
function isEscaped(str, ptr) {
  let i = 0;
  for (; str[ptr - ++i] === "\\"; )
    ;
  return --i && i % 2;
}
function indexOfNewline(str, start = 0, end = str.length) {
  let idx = str.indexOf(`
`, start);
  return str[idx - 1] === "\r" && idx--, idx <= end ? idx : -1;
}
function skipComment(str, ptr) {
  for (let i = ptr; i < str.length; i++) {
    let c2 = str[i];
    if (c2 === `
`)
      return i;
    if (c2 === "\r" && str[i + 1] === `
`)
      return i + 1;
    if (c2 < " " && c2 !== "	" || c2 === "\x7F")
      throw new TomlError("control characters are not allowed in comments", {
        toml: str,
        ptr
      });
  }
  return str.length;
}
function skipVoid(str, ptr, banNewLines, banComments) {
  let c2;
  for (; (c2 = str[ptr]) === " " || c2 === "	" || !banNewLines && (c2 === `
` || c2 === "\r" && str[ptr + 1] === `
`); )
    ptr++;
  return banComments || c2 !== "#" ? ptr : skipVoid(str, skipComment(str, ptr), banNewLines);
}
function skipUntil(str, ptr, sep, end, banNewLines = !1) {
  if (!end)
    return ptr = indexOfNewline(str, ptr), ptr < 0 ? str.length : ptr;
  for (let i = ptr; i < str.length; i++) {
    let c2 = str[i];
    if (c2 === "#")
      i = indexOfNewline(str, i);
    else {
      if (c2 === sep)
        return i + 1;
      if (c2 === end || banNewLines && (c2 === `
` || c2 === "\r" && str[i + 1] === `
`))
        return i;
    }
  }
  throw new TomlError("cannot find end of structure", {
    toml: str,
    ptr
  });
}
function getStringEnd(str, seek) {
  let first = str[seek], target = first === str[seek + 1] && str[seek + 1] === str[seek + 2] ? str.slice(seek, seek + 3) : first;
  seek += target.length - 1;
  do
    seek = str.indexOf(target, ++seek);
  while (seek > -1 && first !== "'" && isEscaped(str, seek));
  return seek > -1 && (seek += target.length, target.length > 1 && (str[seek] === first && seek++, str[seek] === first && seek++)), seek;
}
function parseString(str, ptr = 0, endPtr = str.length) {
  let isLiteral = str[ptr] === "'", isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];
  isMultiline && (endPtr -= 2, str[ptr += 2] === "\r" && ptr++, str[ptr] === `
` && ptr++);
  let tmp = 0, isEscape, parsed = "", sliceStart = ptr;
  for (; ptr < endPtr - 1; ) {
    let c2 = str[ptr++];
    if (c2 === `
` || c2 === "\r" && str[ptr] === `
`) {
      if (!isMultiline)
        throw new TomlError("newlines are not allowed in strings", {
          toml: str,
          ptr: ptr - 1
        });
    } else if (c2 < " " && c2 !== "	" || c2 === "\x7F")
      throw new TomlError("control characters are not allowed in strings", {
        toml: str,
        ptr: ptr - 1
      });
    if (isEscape) {
      if (isEscape = !1, c2 === "u" || c2 === "U") {
        let code = str.slice(ptr, ptr += c2 === "u" ? 4 : 8);
        if (!ESCAPE_REGEX.test(code))
          throw new TomlError("invalid unicode escape", {
            toml: str,
            ptr: tmp
          });
        try {
          parsed += String.fromCodePoint(parseInt(code, 16));
        } catch {
          throw new TomlError("invalid unicode escape", {
            toml: str,
            ptr: tmp
          });
        }
      } else if (isMultiline && (c2 === `
` || c2 === " " || c2 === "	" || c2 === "\r")) {
        if (ptr = skipVoid(str, ptr - 1, !0), str[ptr] !== `
` && str[ptr] !== "\r")
          throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
            toml: str,
            ptr: tmp
          });
        ptr = skipVoid(str, ptr);
      } else if (c2 in ESC_MAP)
        parsed += ESC_MAP[c2];
      else
        throw new TomlError("unrecognized escape sequence", {
          toml: str,
          ptr: tmp
        });
      sliceStart = ptr;
    } else !isLiteral && c2 === "\\" && (tmp = ptr - 1, isEscape = !0, parsed += str.slice(sliceStart, tmp));
  }
  return parsed + str.slice(sliceStart, endPtr - 1);
}
function parseValue(value, toml, ptr, integersAsBigInt) {
  if (value === "true")
    return !0;
  if (value === "false")
    return !1;
  if (value === "-inf")
    return -1 / 0;
  if (value === "inf" || value === "+inf")
    return 1 / 0;
  if (value === "nan" || value === "+nan" || value === "-nan")
    return NaN;
  if (value === "-0")
    return integersAsBigInt ? 0n : 0;
  let isInt2 = INT_REGEX.test(value);
  if (isInt2 || FLOAT_REGEX.test(value)) {
    if (LEADING_ZERO.test(value))
      throw new TomlError("leading zeroes are not allowed", {
        toml,
        ptr
      });
    value = value.replace(/_/g, "");
    let numeric = +value;
    if (isNaN(numeric))
      throw new TomlError("invalid number", {
        toml,
        ptr
      });
    if (isInt2) {
      if ((isInt2 = !Number.isSafeInteger(numeric)) && !integersAsBigInt)
        throw new TomlError("integer value cannot be represented losslessly", {
          toml,
          ptr
        });
      (isInt2 || integersAsBigInt === !0) && (numeric = BigInt(value));
    }
    return numeric;
  }
  let date = new TomlDate(value);
  if (!date.isValid())
    throw new TomlError("invalid value", {
      toml,
      ptr
    });
  return date;
}
function sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {
  let value = str.slice(startPtr, endPtr), commentIdx = value.indexOf("#");
  commentIdx > -1 && (skipComment(str, commentIdx), value = value.slice(0, commentIdx));
  let trimmed = value.trimEnd();
  if (!allowNewLines) {
    let newlineIdx = value.indexOf(`
`, trimmed.length);
    if (newlineIdx > -1)
      throw new TomlError("newlines are not allowed in inline tables", {
        toml: str,
        ptr: startPtr + newlineIdx
      });
  }
  return [trimmed, commentIdx];
}
function extractValue(str, ptr, end, depth, integersAsBigInt) {
  if (depth === 0)
    throw new TomlError("document contains excessively nested structures. aborting.", {
      toml: str,
      ptr
    });
  let c2 = str[ptr];
  if (c2 === "[" || c2 === "{") {
    let [value, endPtr2] = c2 === "[" ? parseArray(str, ptr, depth, integersAsBigInt) : parseInlineTable(str, ptr, depth, integersAsBigInt), newPtr = end ? skipUntil(str, endPtr2, ",", end) : endPtr2;
    if (endPtr2 - newPtr && end === "}") {
      let nextNewLine = indexOfNewline(str, endPtr2, newPtr);
      if (nextNewLine > -1)
        throw new TomlError("newlines are not allowed in inline tables", {
          toml: str,
          ptr: nextNewLine
        });
    }
    return [value, newPtr];
  }
  let endPtr;
  if (c2 === '"' || c2 === "'") {
    endPtr = getStringEnd(str, ptr);
    let parsed = parseString(str, ptr, endPtr);
    if (end) {
      if (endPtr = skipVoid(str, endPtr, end !== "]"), str[endPtr] && str[endPtr] !== "," && str[endPtr] !== end && str[endPtr] !== `
` && str[endPtr] !== "\r")
        throw new TomlError("unexpected character encountered", {
          toml: str,
          ptr: endPtr
        });
      endPtr += +(str[endPtr] === ",");
    }
    return [parsed, endPtr];
  }
  endPtr = skipUntil(str, ptr, ",", end);
  let slice = sliceAndTrimEndOf(str, ptr, endPtr - +(str[endPtr - 1] === ","), end === "]");
  if (!slice[0])
    throw new TomlError("incomplete key-value declaration: no value specified", {
      toml: str,
      ptr
    });
  return end && slice[1] > -1 && (endPtr = skipVoid(str, ptr + slice[1]), endPtr += +(str[endPtr] === ",")), [
    parseValue(slice[0], str, ptr, integersAsBigInt),
    endPtr
  ];
}
function parseKey(str, ptr, end = "=") {
  let dot = ptr - 1, parsed = [], endPtr = str.indexOf(end, ptr);
  if (endPtr < 0)
    throw new TomlError("incomplete key-value: cannot find end of key", {
      toml: str,
      ptr
    });
  do {
    let c2 = str[ptr = ++dot];
    if (c2 !== " " && c2 !== "	")
      if (c2 === '"' || c2 === "'") {
        if (c2 === str[ptr + 1] && c2 === str[ptr + 2])
          throw new TomlError("multiline strings are not allowed in keys", {
            toml: str,
            ptr
          });
        let eos = getStringEnd(str, ptr);
        if (eos < 0)
          throw new TomlError("unfinished string encountered", {
            toml: str,
            ptr
          });
        dot = str.indexOf(".", eos);
        let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot), newLine = indexOfNewline(strEnd);
        if (newLine > -1)
          throw new TomlError("newlines are not allowed in keys", {
            toml: str,
            ptr: ptr + dot + newLine
          });
        if (strEnd.trimStart())
          throw new TomlError("found extra tokens after the string part", {
            toml: str,
            ptr: eos
          });
        if (endPtr < eos && (endPtr = str.indexOf(end, eos), endPtr < 0))
          throw new TomlError("incomplete key-value: cannot find end of key", {
            toml: str,
            ptr
          });
        parsed.push(parseString(str, ptr, eos));
      } else {
        dot = str.indexOf(".", ptr);
        let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
        if (!KEY_PART_RE.test(part))
          throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: str,
            ptr
          });
        parsed.push(part.trimEnd());
      }
  } while (dot + 1 && dot < endPtr);
  return [parsed, skipVoid(str, endPtr + 1, !0, !0)];
}
function parseInlineTable(str, ptr, depth, integersAsBigInt) {
  let res = {}, seen = /* @__PURE__ */ new Set(), c2, comma = 0;
  for (ptr++; (c2 = str[ptr++]) !== "}" && c2; ) {
    let err = { toml: str, ptr: ptr - 1 };
    if (c2 === `
`)
      throw new TomlError("newlines are not allowed in inline tables", err);
    if (c2 === "#")
      throw new TomlError("inline tables cannot contain comments", err);
    if (c2 === ",")
      throw new TomlError("expected key-value, found comma", err);
    if (c2 !== " " && c2 !== "	") {
      let k, t = res, hasOwn = !1, [key2, keyEndPtr] = parseKey(str, ptr - 1);
      for (let i = 0; i < key2.length; i++) {
        if (i && (t = hasOwn ? t[k] : t[k] = {}), k = key2[i], (hasOwn = Object.hasOwn(t, k)) && (typeof t[k] != "object" || seen.has(t[k])))
          throw new TomlError("trying to redefine an already defined value", {
            toml: str,
            ptr
          });
        !hasOwn && k === "__proto__" && Object.defineProperty(t, k, { enumerable: !0, configurable: !0, writable: !0 });
      }
      if (hasOwn)
        throw new TomlError("trying to redefine an already defined value", {
          toml: str,
          ptr
        });
      let [value, valueEndPtr] = extractValue(str, keyEndPtr, "}", depth - 1, integersAsBigInt);
      seen.add(value), t[k] = value, ptr = valueEndPtr, comma = str[ptr - 1] === "," ? ptr - 1 : 0;
    }
  }
  if (comma)
    throw new TomlError("trailing commas are not allowed in inline tables", {
      toml: str,
      ptr: comma
    });
  if (!c2)
    throw new TomlError("unfinished table encountered", {
      toml: str,
      ptr
    });
  return [res, ptr];
}
function parseArray(str, ptr, depth, integersAsBigInt) {
  let res = [], c2;
  for (ptr++; (c2 = str[ptr++]) !== "]" && c2; ) {
    if (c2 === ",")
      throw new TomlError("expected value, found comma", {
        toml: str,
        ptr: ptr - 1
      });
    if (c2 === "#")
      ptr = skipComment(str, ptr);
    else if (c2 !== " " && c2 !== "	" && c2 !== `
` && c2 !== "\r") {
      let e = extractValue(str, ptr - 1, "]", depth - 1, integersAsBigInt);
      res.push(e[0]), ptr = e[1];
    }
  }
  if (!c2)
    throw new TomlError("unfinished array encountered", {
      toml: str,
      ptr
    });
  return [res, ptr];
}
function peekTable(key2, table, meta, type) {
  let t = table, m = meta, k, hasOwn = !1, state;
  for (let i = 0; i < key2.length; i++) {
    if (i) {
      if (t = hasOwn ? t[k] : t[k] = {}, m = (state = m[k]).c, type === 0 && (state.t === 1 || state.t === 2))
        return null;
      if (state.t === 2) {
        let l = t.length - 1;
        t = t[l], m = m[l].c;
      }
    }
    if (k = key2[i], (hasOwn = Object.hasOwn(t, k)) && m[k]?.t === 0 && m[k]?.d)
      return null;
    hasOwn || (k === "__proto__" && (Object.defineProperty(t, k, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(m, k, { enumerable: !0, configurable: !0, writable: !0 })), m[k] = {
      t: i < key2.length - 1 && type === 2 ? 3 : type,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (state = m[k], state.t !== type && !(type === 1 && state.t === 3) || (type === 2 && (state.d || (state.d = !0, t[k] = []), t[k].push(t = {}), state.c[state.i++] = state = { t: 1, d: !1, i: 0, c: {} }), state.d))
    return null;
  if (state.d = !0, type === 1)
    t = hasOwn ? t[k] : t[k] = {};
  else if (type === 0 && hasOwn)
    return null;
  return [k, t, state.c];
}
function parse4(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
  let res = {}, meta = {}, tbl = res, m = meta;
  for (let ptr = skipVoid(toml, 0); ptr < toml.length; ) {
    if (toml[ptr] === "[") {
      let isTableArray = toml[++ptr] === "[", k = parseKey(toml, ptr += +isTableArray, "]");
      if (isTableArray) {
        if (toml[k[1] - 1] !== "]")
          throw new TomlError("expected end of table declaration", {
            toml,
            ptr: k[1] - 1
          });
        k[1]++;
      }
      let p = peekTable(
        k[0],
        res,
        meta,
        isTableArray ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!p)
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      m = p[2], tbl = p[1], ptr = k[1];
    } else {
      let k = parseKey(toml, ptr), p = peekTable(
        k[0],
        tbl,
        m,
        0
        /* Type.DOTTED */
      );
      if (!p)
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
      p[1][p[0]] = v[0], ptr = v[1];
    }
    if (ptr = skipVoid(toml, ptr, !0), toml[ptr] && toml[ptr] !== `
` && toml[ptr] !== "\r")
      throw new TomlError("each key-value declaration must be followed by an end-of-line", {
        toml,
        ptr
      });
    ptr = skipVoid(toml, ptr);
  }
  return res;
}
async function readFile(file) {
  isUrlString(file) && (file = new URL(file));
  try {
    return await fs2.readFile(file, "utf8");
  } catch (error) {
    if (error.code === "ENOENT")
      return;
    throw new Error(`Unable to read '${file}': ${error.message}`);
  }
}
async function readJson(file) {
  let content = await read_file_default(file);
  try {
    return parseJson(content);
  } catch (error) {
    throw error.message = `JSON Error in ${file}:
${error.message}`, error;
  }
}
async function importModuleDefault(file) {
  return (await import(pathToFileURL2(file).href)).default;
}
async function readBunPackageJson(file) {
  try {
    return await readJson(file);
  } catch (error) {
    try {
      return await importModuleDefault(file);
    } catch {
    }
    throw error;
  }
}
async function loadConfigFromPackageYaml(file) {
  let { prettier } = await loadYaml(file);
  return prettier;
}
async function loadYaml(file) {
  let content = await read_file_default(file);
  parseYaml || ({ __parsePrettierYamlConfig: parseYaml } = await import("./yaml-6GALFXQY.js"));
  try {
    return parseYaml(content);
  } catch (error) {
    throw error.message = `YAML Error in ${file}:
${error.message}`, error;
  }
}
async function loadToml(file) {
  let content = await read_file_default(file);
  try {
    return parse4(content);
  } catch (error) {
    throw error.message = `TOML Error in ${file}:
${error.message}`, error;
  }
}
async function loadJson5(file) {
  let content = await read_file_default(file);
  try {
    return dist_default.parse(content);
  } catch (error) {
    throw error.message = `JSON5 Error in ${file}:
${error.message}`, error;
  }
}
async function filter({ name, path: file }) {
  if (name === "package.json")
    try {
      return !!await loadConfigFromPackageJson(file);
    } catch {
      return !1;
    }
  if (name === "package.yaml")
    try {
      return !!await loadConfigFromPackageYaml(file);
    } catch {
      return !1;
    }
  return !0;
}
function getSearcher(stopDirectory) {
  return new FileSearcher(CONFIG_FILE_NAMES, { filter, stopDirectory });
}
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
}
function createError(sym, value, constructor) {
  return messages.set(sym, value), makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key2) {
  return NodeError;
  function NodeError(...parameters) {
    let limit = Error.stackTraceLimit;
    isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
    let error = new Base();
    isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = limit);
    let message = getMessage(key2, parameters, error);
    return Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: !1,
        writable: !0,
        configurable: !0
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key2}]: ${this.message}`;
        },
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), captureLargerStackTrace(error), error.code = key2, error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot())
      return !1;
  } catch {
  }
  let desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  return desc === void 0 ? Object.isExtensible(Error) : own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  let hidden = nodeInternalPrefix + wrappedFunction.name;
  return Object.defineProperty(wrappedFunction, "name", { value: hidden }), wrappedFunction;
}
function getMessage(key2, parameters, self) {
  let message = messages.get(key2);
  if (assert2.ok(message !== void 0, "expected `message` to be found"), typeof message == "function")
    return assert2.ok(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key2}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    ), Reflect.apply(message, self, parameters);
  let regex = /%[dfijoOs]/g, expectedLength = 0;
  for (; regex.exec(message) !== null; ) expectedLength++;
  return assert2.ok(
    expectedLength === parameters.length,
    `Code: ${key2}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  ), parameters.length === 0 ? message : (parameters.unshift(message), Reflect.apply(format, null, parameters));
}
function determineSpecificType(value) {
  if (value == null)
    return String(value);
  if (typeof value == "function" && value.name)
    return `function ${value.name}`;
  if (typeof value == "object")
    return value.constructor && value.constructor.name ? `an instance of ${value.constructor.name}` : `${inspect(value, { depth: -1 })}`;
  let inspected = inspect(value, { colors: !1 });
  return inspected.length > 28 && (inspected = `${inspected.slice(0, 25)}...`), `type ${typeof value} (${inspected})`;
}
function read2(jsonPath, { base, specifier }) {
  let existing = cache.get(jsonPath);
  if (existing)
    return existing;
  let string;
  try {
    string = fs3.readFileSync(path6.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    let exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code !== "ENOENT")
      throw exception;
  }
  let result = {
    exists: !1,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      let cause = (
        /** @type {ErrnoException} */
        error_
      ), error = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + fileURLToPath2(base || specifier),
        cause.message
      );
      throw error.cause = cause, error;
    }
    result.exists = !0, hasOwnProperty.call(parsed, "name") && typeof parsed.name == "string" && (result.name = parsed.name), hasOwnProperty.call(parsed, "main") && typeof parsed.main == "string" && (result.main = parsed.main), hasOwnProperty.call(parsed, "exports") && (result.exports = parsed.exports), hasOwnProperty.call(parsed, "imports") && (result.imports = parsed.imports), hasOwnProperty.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module") && (result.type = parsed.type);
  }
  return cache.set(jsonPath, result), result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  for (; !packageJSONUrl.pathname.endsWith("node_modules/package.json"); ) {
    let packageConfig = read2(fileURLToPath2(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists)
      return packageConfig;
    let lastPackageJSONUrl = packageJSONUrl;
    if (packageJSONUrl = new URL("../package.json", packageJSONUrl), packageJSONUrl.pathname === lastPackageJSONUrl.pathname)
      break;
  }
  return {
    pjsonPath: fileURLToPath2(packageJSONUrl),
    exists: !1,
    type: "none"
  };
}
function getPackageType(url3) {
  return getPackageScopeConfig(url3).type;
}
function mimeToFormat(mime) {
  return mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime) ? "module" : mime === "application/json" ? "json" : null;
}
function getDataProtocolModuleFormat(parsed) {
  let { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url3) {
  let pathname = url3.pathname, index = pathname.length;
  for (; index--; ) {
    let code = pathname.codePointAt(index);
    if (code === 47)
      return "";
    if (code === 46)
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
  }
  return "";
}
function getFileProtocolModuleFormat(url3, _context, ignoreErrors) {
  let value = extname(url3);
  if (value === ".js") {
    let packageType = getPackageType(url3);
    return packageType !== "none" ? packageType : "commonjs";
  }
  if (value === "") {
    let packageType = getPackageType(url3);
    return packageType === "none" || packageType === "commonjs" ? "commonjs" : "module";
  }
  let format3 = extensionFormatMap[value];
  if (format3) return format3;
  if (ignoreErrors)
    return;
  let filepath = fileURLToPath3(url3);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url3, context) {
  let protocol = url3.protocol;
  return hasOwnProperty2.call(protocolHandlers, protocol) && protocolHandlers[protocol](url3, context, !0) || null;
}
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions))
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (process4.noDeprecation)
    return;
  let pjsonPath = fileURLToPath4(packageJsonUrl), double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process4.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath4(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url3, packageJsonUrl, base, main) {
  if (process4.noDeprecation || defaultGetFormatWithoutErrors(url3, { parentURL: base.href }) !== "module") return;
  let urlPath = fileURLToPath4(url3.href), packagePath = fileURLToPath4(new URL(".", packageJsonUrl)), basePath = fileURLToPath4(base);
  main ? path7.resolve(packagePath, main) !== urlPath && process4.emitWarning(
    `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
      packagePath.length
    )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
    "DeprecationWarning",
    "DEP0151"
  ) : process4.emitWarning(
    `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
      packagePath.length
    )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
    "DeprecationWarning",
    "DEP0151"
  );
}
function tryStatSync(path15) {
  try {
    return statSync(path15);
  } catch {
  }
}
function fileExists(url3) {
  let stats = statSync(url3, { throwIfNoEntry: !1 }), isFile2 = stats ? stats.isFile() : void 0;
  return isFile2 ?? !1;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    if (guess = new URL(packageConfig.main, packageJsonUrl), fileExists(guess)) return guess;
    let tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ], i2 = -1;
    for (; ++i2 < tries2.length && (guess = new URL(tries2[i2], packageJsonUrl), !fileExists(guess)); )
      guess = void 0;
    if (guess)
      return emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      ), guess;
  }
  let tries = ["./index.js", "./index.json", "./index.node"], i = -1;
  for (; ++i < tries.length && (guess = new URL(tries[i], packageJsonUrl), !fileExists(guess)); )
    guess = void 0;
  if (guess)
    return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
  throw new ERR_MODULE_NOT_FOUND(
    fileURLToPath4(new URL(".", packageJsonUrl)),
    fileURLToPath4(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      fileURLToPath4(base)
    );
  let filePath;
  try {
    filePath = fileURLToPath4(resolved);
  } catch (error) {
    let cause = (
      /** @type {ErrnoException} */
      error
    );
    throw Object.defineProperty(cause, "input", { value: String(resolved) }), Object.defineProperty(cause, "module", { value: String(base) }), cause;
  }
  let stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats && stats.isDirectory()) {
    let error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath4(base));
    throw error.url = String(resolved), error;
  }
  if (!stats || !stats.isFile()) {
    let error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && fileURLToPath4(base),
      !0
    );
    throw error.url = String(resolved), error;
  }
  if (!preserveSymlinks) {
    let real = realpathSync(filePath), { search, hash } = resolved;
    resolved = pathToFileURL3(real + (filePath.endsWith(path7.sep) ? "/" : "")), resolved.search = search, resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && fileURLToPath4(new URL(".", packageJsonUrl)),
    fileURLToPath4(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    fileURLToPath4(new URL(".", packageJsonUrl)),
    subpath,
    base && fileURLToPath4(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  let reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath4(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && fileURLToPath4(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  return target = typeof target == "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET(
    fileURLToPath4(new URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && fileURLToPath4(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL2 = !1;
      try {
        new URL(target), isURL2 = !0;
      } catch {
      }
      if (!isURL2) {
        let exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null)
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        let request = pattern ? match.replace("*", () => subpath) : match + subpath, resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          !0
        );
      }
    } else
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  let resolved = new URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    let request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        let resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          !1
        );
      }
    } else
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
  }
  return pattern ? new URL(
    RegExpPrototypeSymbolReplace.call(
      patternRegEx,
      resolved.href,
      () => subpath
    )
  ) : new URL(subpath, resolved);
}
function isArrayIndex(key2) {
  let keyNumber = Number(key2);
  return `${keyNumber}` !== key2 ? !1 : keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target == "string")
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  if (Array.isArray(target)) {
    let targetList = target;
    if (targetList.length === 0) return null;
    let lastException, i = -1;
    for (; ++i < targetList.length; ) {
      let targetItem = targetList[i], resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        let exception = (
          /** @type {ErrnoException} */
          error
        );
        if (lastException = exception, exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult !== void 0) {
        if (resolveResult === null) {
          lastException = null;
          continue;
        }
        return resolveResult;
      }
    }
    if (lastException == null)
      return null;
    throw lastException;
  }
  if (typeof target == "object" && target !== null) {
    let keys = Object.getOwnPropertyNames(target), i = -1;
    for (; ++i < keys.length; ) {
      let key2 = keys[i];
      if (isArrayIndex(key2))
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          fileURLToPath4(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
    }
    for (i = -1; ++i < keys.length; ) {
      let key2 = keys[i];
      if (key2 === "default" || conditions && conditions.has(key2)) {
        let conditionalTarget = (
          /** @type {unknown} */
          target[key2]
        ), resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null)
    return null;
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports == "string" || Array.isArray(exports)) return !0;
  if (typeof exports != "object" || exports === null) return !1;
  let keys = Object.getOwnPropertyNames(exports), isConditionalSugar = !1, i = 0, keyIndex = -1;
  for (; ++keyIndex < keys.length; ) {
    let key2 = keys[keyIndex], currentIsConditionalSugar = key2 === "" || key2[0] !== ".";
    if (i++ === 0)
      isConditionalSugar = currentIsConditionalSugar;
    else if (isConditionalSugar !== currentIsConditionalSugar)
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        fileURLToPath4(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (process4.noDeprecation)
    return;
  let pjsonPath = fileURLToPath4(pjsonUrl);
  emittedPackageWarnings.has(pjsonPath + "|" + match) || (emittedPackageWarnings.add(pjsonPath + "|" + match), process4.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath4(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  ));
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base) && (exports = { ".": exports }), own2.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    let target = exports[packageSubpath], resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      !1,
      !1,
      !1,
      conditions
    );
    if (resolveResult == null)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    return resolveResult;
  }
  let bestMatch = "", bestMatchSubpath = "", keys = Object.getOwnPropertyNames(exports), i = -1;
  for (; ++i < keys.length; ) {
    let key2 = keys[i], patternIndex = key2.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key2.slice(0, patternIndex))) {
      packageSubpath.endsWith("/") && emitTrailingSlashPatternDeprecation(
        packageSubpath,
        packageJsonUrl,
        base
      );
      let patternTrailer = key2.slice(patternIndex + 1);
      packageSubpath.length >= key2.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex && (bestMatch = key2, bestMatchSubpath = packageSubpath.slice(
        patternIndex,
        packageSubpath.length - patternTrailer.length
      ));
    }
  }
  if (bestMatch) {
    let target = (
      /** @type {unknown} */
      exports[bestMatch]
    ), resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      !0,
      !1,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult == null)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  let aPatternIndex = a.indexOf("*"), bPatternIndex = b.indexOf("*"), baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1, baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  return baseLengthA > baseLengthB ? -1 : baseLengthB > baseLengthA || aPatternIndex === -1 ? 1 : bPatternIndex === -1 || a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    let reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath4(base));
  }
  let packageJsonUrl, packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = pathToFileURL3(packageConfig.pjsonPath);
    let imports = packageConfig.imports;
    if (imports)
      if (own2.call(imports, name) && !name.includes("*")) {
        let resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          !1,
          !0,
          !1,
          conditions
        );
        if (resolveResult != null)
          return resolveResult;
      } else {
        let bestMatch = "", bestMatchSubpath = "", keys = Object.getOwnPropertyNames(imports), i = -1;
        for (; ++i < keys.length; ) {
          let key2 = keys[i], patternIndex = key2.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key2.slice(0, -1))) {
            let patternTrailer = key2.slice(patternIndex + 1);
            name.length >= key2.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex && (bestMatch = key2, bestMatchSubpath = name.slice(
              patternIndex,
              name.length - patternTrailer.length
            ));
          }
        }
        if (bestMatch) {
          let target = imports[bestMatch], resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            !0,
            !0,
            !1,
            conditions
          );
          if (resolveResult != null)
            return resolveResult;
        }
      }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/"), validPackageName = !0, isScoped = !1;
  specifier[0] === "@" && (isScoped = !0, separatorIndex === -1 || specifier.length === 0 ? validPackageName = !1 : separatorIndex = specifier.indexOf("/", separatorIndex + 1));
  let packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null && (validPackageName = !1), !validPackageName)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      fileURLToPath4(base)
    );
  let packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (builtinModules.includes(specifier))
    return new URL("node:" + specifier);
  let { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  ), packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    let packageJsonUrl2 = pathToFileURL3(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
  }
  let packageJsonUrl = new URL(
    "./node_modules/" + packageName + "/package.json",
    base
  ), packageJsonPath = fileURLToPath4(packageJsonUrl), lastPath;
  do {
    let stat2 = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat2 || !stat2.isDirectory()) {
      lastPath = packageJsonPath, packageJsonUrl = new URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      ), packageJsonPath = fileURLToPath4(packageJsonUrl);
      continue;
    }
    let packageConfig2 = read2(packageJsonPath, { base, specifier });
    return packageConfig2.exports !== void 0 && packageConfig2.exports !== null ? packageExportsResolve(
      packageJsonUrl,
      packageSubpath,
      packageConfig2,
      base,
      conditions
    ) : packageSubpath === "." ? legacyMainResolve(packageJsonUrl, packageConfig2, base) : new URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath4(base), !1);
}
function isRelativeSpecifier(specifier) {
  return specifier[0] === "." && (specifier.length === 1 || specifier[1] === "/" || specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/"));
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  return specifier === "" ? !1 : specifier[0] === "/" ? !0 : isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  conditions === void 0 && (conditions = getConditionsSet());
  let protocol = base.protocol, isRemote = protocol === "data:" || protocol === "http:" || protocol === "https:", resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier))
    try {
      resolved = new URL(specifier, base);
    } catch (error_) {
      let error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      throw error.cause = error_, error;
    }
  else if (protocol === "file:" && specifier[0] === "#")
    resolved = packageImportsResolve(specifier, base, conditions);
  else
    try {
      resolved = new URL(specifier);
    } catch (error_) {
      if (isRemote && !builtinModules.includes(specifier)) {
        let error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        throw error.cause = error_, error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  return assert3.ok(resolved !== void 0, "expected to be defined"), resolved.protocol !== "file:" ? resolved : finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    let parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === "http:" || parentProtocol === "https:") {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        let parsedProtocol = parsed?.protocol;
        if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:")
          throw new ERR_NETWORK_IMPORT_DISALLOWED(
            specifier,
            parsedParentURL,
            "remote imports cannot import from a local location."
          );
        return { url: parsed?.href || "" };
      }
      throw builtinModules.includes(specifier) ? new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "remote imports cannot import from a local location."
      ) : new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "only relative and absolute specifiers are supported."
      );
    }
  }
}
function isURL(self) {
  return !!(self && typeof self == "object" && "href" in self && typeof self.href == "string" && "protocol" in self && typeof self.protocol == "string" && self.href && self.protocol);
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL !== void 0 && typeof parentURL != "string" && !isURL(parentURL))
    throw new codes.ERR_INVALID_ARG_TYPE(
      "parentURL",
      ["string", "URL"],
      parentURL
    );
}
function defaultResolve(specifier, context = {}) {
  let { parentURL } = context;
  assert3.ok(parentURL !== void 0, "expected `parentURL` to be defined"), throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL)
    try {
      parsedParentURL = new URL(parentURL);
    } catch {
    }
  let parsed, protocol;
  try {
    if (parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new URL(specifier, parsedParentURL) : new URL(specifier), protocol = parsed.protocol, protocol === "data:")
      return { url: parsed.href, format: null };
  } catch {
  }
  let maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn) return maybeReturn;
  if (protocol === void 0 && parsed && (protocol = parsed.protocol), protocol === "node:")
    return { url: specifier };
  if (parsed && parsed.protocol === "node:") return { url: specifier };
  let conditions = getConditionsSet(context.conditions), url3 = moduleResolve(specifier, new URL(parentURL), conditions, !1);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url3.href,
    format: defaultGetFormatWithoutErrors(url3, { parentURL })
  };
}
function resolve2(specifier, parent) {
  if (!parent)
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    let exception = (
      /** @type {ErrnoException} */
      error
    );
    if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url == "string")
      return exception.url;
    throw error;
  }
}
function importFromFile(specifier, parent) {
  return import(resolve2(specifier, pathToFileURL4(parent).href));
}
function requireFromFile(id, parent) {
  return createRequire(parent)(id);
}
async function loadExternalConfig(externalConfig, configFile) {
  try {
    let required = require_from_file_default(externalConfig, configFile);
    return process.features.require_module && required.__esModule ? required.default : required;
  } catch (error) {
    if (!requireErrorCodesShouldBeIgnored.has(error?.code))
      throw error;
  }
  return (await import_from_file_default(externalConfig, configFile)).default;
}
async function loadConfig(configFile) {
  let { base: fileName, ext: extension } = path8.parse(configFile), load = fileName === "package.json" ? loadConfigFromPackageJson : fileName === "package.yaml" ? loadConfigFromPackageYaml : loaders_default[extension];
  if (!load)
    throw new Error(
      `No loader specified for extension "${extension || "noExt"}"`
    );
  let config = await load(configFile);
  if (config) {
    if (typeof config == "string" && (config = await load_external_config_default(config, configFile)), typeof config != "object")
      throw new TypeError(
        `Config is only allowed to be an object, but received ${typeof config} in "${configFile}"`
      );
    return delete config.$schema, config;
  }
}
function clearPrettierConfigCache() {
  loadCache.clear(), searchCache.clear();
}
function loadPrettierConfig(configFile, { shouldCache }) {
  return configFile = path9.resolve(configFile), (!shouldCache || !loadCache.has(configFile)) && loadCache.set(configFile, load_config_default(configFile)), loadCache.get(configFile);
}
function getSearchFunction(stopDirectory) {
  if (stopDirectory = stopDirectory ? path9.resolve(stopDirectory) : void 0, !searchCache.has(stopDirectory)) {
    let searcher2 = config_searcher_default(stopDirectory), searchFunction = searcher2.search.bind(searcher2);
    searchCache.set(stopDirectory, searchFunction);
  }
  return searchCache.get(stopDirectory);
}
function searchPrettierConfig(startDirectory, options8 = {}) {
  startDirectory = startDirectory ? path9.resolve(startDirectory) : process.cwd();
  let stopDirectory = mockable_default.getPrettierConfigSearchStopDirectory();
  return getSearchFunction(stopDirectory)(startDirectory, { cache: options8.shouldCache });
}
function clearCache() {
  clearPrettierConfigCache(), clearEditorconfigCache();
}
function loadEditorconfig2(file, options8) {
  if (!file || !options8.editorconfig)
    return;
  let shouldCache = options8.useCache;
  return loadEditorconfig(file, { shouldCache });
}
async function loadPrettierConfig2(file, options8) {
  let shouldCache = options8.useCache, configFile = options8.config;
  if (!configFile) {
    let directory = file ? path10.dirname(path10.resolve(file)) : void 0;
    configFile = await searchPrettierConfig(directory, { shouldCache });
  }
  return configFile ? (configFile = toPath(configFile), { config: await loadPrettierConfig(configFile, { shouldCache }), configFile }) : void 0;
}
async function resolveConfig(fileUrlOrPath, options8) {
  options8 = { useCache: !0, ...options8 };
  let filePath = toPath(fileUrlOrPath), [result, editorConfigured] = await Promise.all([
    loadPrettierConfig2(filePath, options8),
    loadEditorconfig2(filePath, options8)
  ]);
  if (!result && !editorConfigured)
    return null;
  let merged = {
    ...editorConfigured,
    ...mergeOverrides(result, filePath)
  };
  return Array.isArray(merged.plugins) && (merged.plugins = merged.plugins.map(
    (value) => typeof value == "string" && value.startsWith(".") ? path10.resolve(path10.dirname(result.configFile), value) : value
  )), merged;
}
async function resolveConfigFile(fileUrlOrPath) {
  let directory = fileUrlOrPath ? path10.dirname(path10.resolve(toPath(fileUrlOrPath))) : void 0;
  return await searchPrettierConfig(directory, { shouldCache: !1 }) ?? null;
}
function mergeOverrides(configResult, filePath) {
  let { config, configFile } = configResult || {}, { overrides, ...options8 } = config || {};
  if (filePath && overrides) {
    let relativeFilePath = path10.relative(path10.dirname(configFile), filePath);
    for (let override of overrides)
      pathMatchesGlobs(
        relativeFilePath,
        override.files,
        override.excludeFiles
      ) && Object.assign(options8, override.options);
  }
  return options8;
}
function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
  let patternList = Array.isArray(patterns) ? patterns : [patterns], [withSlashes, withoutSlashes] = partition_default(
    patternList,
    (pattern) => pattern.includes("/")
  );
  return import_micromatch.default.isMatch(filePath, withoutSlashes, {
    ignore: excludedPatterns,
    basename: !0,
    dot: !0
  }) || import_micromatch.default.isMatch(filePath, withSlashes, {
    ignore: excludedPatterns,
    basename: !1,
    dot: !0
  });
}
function guessEndOfLine(text) {
  let index = text.indexOf(CHARACTER_CR2);
  return index !== -1 ? text.charAt(index + 1) === CHARACTER_LF2 ? OPTION_CRLF2 : OPTION_CR2 : DEFAULT_OPTION;
}
function convertEndOfLineOptionToCharacter2(endOfLineOption) {
  return endOfLineOption === OPTION_CR2 ? CHARACTER_CR2 : endOfLineOption === OPTION_CRLF2 ? CHARACTER_CRLF2 : DEFAULT_EOL2;
}
function countEndOfLineCharacters(text, endOfLineCharacter) {
  let regex = regexps.get(endOfLineCharacter);
  return text.match(regex)?.length ?? 0;
}
function normalizeEndOfLine(text) {
  return method_replace_all_default2(
    /* OPTIONAL_OBJECT: false */
    0,
    text,
    END_OF_LINE_REGEXP,
    CHARACTER_LF2
  );
}
function stringOrArrayAt2(index) {
  return this[index < 0 ? this.length + index : index];
}
function inheritLabel(doc2, fn) {
  return doc2.type === DOC_TYPE_LABEL2 ? {
    ...doc2,
    contents: fn(doc2.contents)
  } : fn(doc2);
}
function flattenDoc(doc2) {
  if (!doc2)
    return "";
  if (Array.isArray(doc2)) {
    let res = [];
    for (let part of doc2)
      if (Array.isArray(part))
        res.push(...flattenDoc(part));
      else {
        let flattened = flattenDoc(part);
        flattened !== "" && res.push(flattened);
      }
    return res;
  }
  return doc2.type === DOC_TYPE_IF_BREAK2 ? {
    ...doc2,
    breakContents: flattenDoc(doc2.breakContents),
    flatContents: flattenDoc(doc2.flatContents)
  } : doc2.type === DOC_TYPE_GROUP2 ? {
    ...doc2,
    contents: flattenDoc(doc2.contents),
    expandedStates: doc2.expandedStates?.map(flattenDoc)
  } : doc2.type === DOC_TYPE_FILL2 ? { type: "fill", parts: doc2.parts.map(flattenDoc) } : doc2.contents ? { ...doc2, contents: flattenDoc(doc2.contents) } : doc2;
}
function printDocToDebug(doc2) {
  let printedSymbols = /* @__PURE__ */ Object.create(null), usedKeysForSymbols = /* @__PURE__ */ new Set();
  return printDoc(flattenDoc(doc2));
  function printDoc(doc3, index, parentParts) {
    if (typeof doc3 == "string")
      return JSON.stringify(doc3);
    if (Array.isArray(doc3)) {
      let printed = doc3.map(printDoc).filter(Boolean);
      return printed.length === 1 ? printed[0] : `[${printed.join(", ")}]`;
    }
    if (doc3.type === DOC_TYPE_LINE2) {
      let withBreakParent = parentParts?.[index + 1]?.type === DOC_TYPE_BREAK_PARENT2;
      return doc3.literal ? withBreakParent ? "literalline" : "literallineWithoutBreakParent" : doc3.hard ? withBreakParent ? "hardline" : "hardlineWithoutBreakParent" : doc3.soft ? "softline" : "line";
    }
    if (doc3.type === DOC_TYPE_BREAK_PARENT2)
      return parentParts?.[index - 1]?.type === DOC_TYPE_LINE2 && parentParts[index - 1].hard ? void 0 : "breakParent";
    if (doc3.type === DOC_TYPE_TRIM2)
      return "trim";
    if (doc3.type === DOC_TYPE_INDENT2)
      return "indent(" + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_ALIGN2)
      return doc3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + printDoc(doc3.contents) + ")" : doc3.n < 0 ? "dedent(" + printDoc(doc3.contents) + ")" : doc3.n.type === "root" ? "markAsRoot(" + printDoc(doc3.contents) + ")" : "align(" + JSON.stringify(doc3.n) + ", " + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_IF_BREAK2)
      return "ifBreak(" + printDoc(doc3.breakContents) + (doc3.flatContents ? ", " + printDoc(doc3.flatContents) : "") + (doc3.groupId ? (doc3.flatContents ? "" : ', ""') + `, { groupId: ${printGroupId(doc3.groupId)} }` : "") + ")";
    if (doc3.type === DOC_TYPE_INDENT_IF_BREAK2) {
      let optionsParts = [];
      doc3.negate && optionsParts.push("negate: true"), doc3.groupId && optionsParts.push(`groupId: ${printGroupId(doc3.groupId)}`);
      let options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(", ")} }` : "";
      return `indentIfBreak(${printDoc(doc3.contents)}${options8})`;
    }
    if (doc3.type === DOC_TYPE_GROUP2) {
      let optionsParts = [];
      doc3.break && doc3.break !== "propagated" && optionsParts.push("shouldBreak: true"), doc3.id && optionsParts.push(`id: ${printGroupId(doc3.id)}`);
      let options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(", ")} }` : "";
      return doc3.expandedStates ? `conditionalGroup([${doc3.expandedStates.map((part) => printDoc(part)).join(",")}]${options8})` : `group(${printDoc(doc3.contents)}${options8})`;
    }
    if (doc3.type === DOC_TYPE_FILL2)
      return `fill([${doc3.parts.map((part) => printDoc(part)).join(", ")}])`;
    if (doc3.type === DOC_TYPE_LINE_SUFFIX2)
      return "lineSuffix(" + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_LINE_SUFFIX_BOUNDARY2)
      return "lineSuffixBoundary";
    if (doc3.type === DOC_TYPE_LABEL2)
      return `label(${JSON.stringify(doc3.label)}, ${printDoc(doc3.contents)})`;
    if (doc3.type === DOC_TYPE_CURSOR2)
      return "cursor";
    throw new Error("Unknown doc type " + doc3.type);
  }
  function printGroupId(id) {
    if (typeof id != "symbol")
      return JSON.stringify(String(id));
    if (id in printedSymbols)
      return printedSymbols[id];
    let prefix = id.description || "symbol";
    for (let counter = 0; ; counter++) {
      let key2 = prefix + (counter > 0 ? ` #${counter}` : "");
      if (!usedKeysForSymbols.has(key2))
        return usedKeysForSymbols.add(key2), printedSymbols[id] = `Symbol.for(${JSON.stringify(key2)})`;
    }
  }
}
function isFullWidth2(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide2(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
function getStringWidth2(text) {
  if (!text)
    return 0;
  if (!notAsciiRegex2.test(text))
    return text.length;
  text = text.replace(
    emoji_regex_default2(),
    (match) => narrowEmojisSet2.has(match) ? " " : "  "
  );
  let width = 0;
  for (let character of text) {
    let codePoint = character.codePointAt(0);
    codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 768 && codePoint <= 879 || codePoint >= 65024 && codePoint <= 65039 || (width += isFullWidth2(codePoint) || isWide2(codePoint) ? 2 : 1);
  }
  return width;
}
function getAlignmentSize(text, tabWidth, startIndex = 0) {
  let size = 0;
  for (let i = startIndex; i < text.length; ++i)
    text[i] === "	" ? size = size + tabWidth - size % tabWidth : size++;
  return size;
}
function isObject(object) {
  return object !== null && typeof object == "object";
}
function skip(characters) {
  return (text, startIndex, options8) => {
    let backwards = !!options8?.backwards;
    if (startIndex === !1)
      return !1;
    let { length } = text, cursor22 = startIndex;
    for (; cursor22 >= 0 && cursor22 < length; ) {
      let character = text.charAt(cursor22);
      if (characters instanceof RegExp) {
        if (!characters.test(character))
          return cursor22;
      } else if (!characters.includes(character))
        return cursor22;
      backwards ? cursor22-- : cursor22++;
    }
    return cursor22 === -1 || cursor22 === length ? cursor22 : !1;
  };
}
function skipNewline(text, startIndex, options8) {
  let backwards = !!options8?.backwards;
  if (startIndex === !1)
    return !1;
  let character = text.charAt(startIndex);
  if (backwards) {
    if (text.charAt(startIndex - 1) === "\r" && character === `
`)
      return startIndex - 2;
    if (isNewlineCharacter(character))
      return startIndex - 1;
  } else {
    if (character === "\r" && text.charAt(startIndex + 1) === `
`)
      return startIndex + 2;
    if (isNewlineCharacter(character))
      return startIndex + 1;
  }
  return startIndex;
}
function hasNewline(text, startIndex, options8 = {}) {
  let idx = skipSpaces(
    text,
    options8.backwards ? startIndex - 1 : startIndex,
    options8
  ), idx2 = skip_newline_default(text, idx, options8);
  return idx !== idx2;
}
function isNonEmptyArray(object) {
  return Array.isArray(object) && object.length > 0;
}
function* getChildren(node, options8) {
  let { getVisitorKeys, filter: filter2 = () => !0 } = options8, isMatchedNode = (node2) => is_object_default(node2) && filter2(node2);
  for (let key2 of getVisitorKeys(node)) {
    let value = node[key2];
    if (Array.isArray(value))
      for (let child of value)
        isMatchedNode(child) && (yield child);
    else isMatchedNode(value) && (yield value);
  }
}
function* getDescendants(node, options8) {
  let queue = [node];
  for (let index = 0; index < queue.length; index++) {
    let node2 = queue[index];
    for (let child of getChildren(node2, options8))
      yield child, queue.push(child);
  }
}
function isLeaf(node, options8) {
  return getChildren(node, options8).next().done;
}
function getSortedChildNodes(node, ancestors, options8) {
  let { cache: childNodesCache2 } = options8;
  if (childNodesCache2.has(node))
    return childNodesCache2.get(node);
  let { filter: filter2 } = options8;
  if (!filter2)
    return [];
  let childAncestors, childNodes = (options8.getChildren?.(node, options8) ?? [
    ...getChildren(node, { getVisitorKeys: options8.getVisitorKeys })
  ]).flatMap((child) => (childAncestors ?? (childAncestors = [node, ...ancestors]), filter2(child, childAncestors) ? [child] : getSortedChildNodes(child, childAncestors, options8))), { locStart, locEnd } = options8;
  return childNodes.sort(
    (nodeA, nodeB) => locStart(nodeA) - locStart(nodeB) || locEnd(nodeA) - locEnd(nodeB)
  ), childNodesCache2.set(node, childNodes), childNodes;
}
function describeNodeForDebugging(node) {
  let nodeType = node.type || node.kind || "(unknown type)", nodeName = String(
    node.name || node.id && (typeof node.id == "object" ? node.id.name : node.id) || node.key && (typeof node.key == "object" ? node.key.name : node.key) || node.value && (typeof node.value == "object" ? "" : String(node.value)) || node.operator || ""
  );
  return nodeName.length > 20 && (nodeName = nodeName.slice(0, 19) + "\u2026"), nodeType + (nodeName ? " " + nodeName : "");
}
function addCommentHelper(node, comment) {
  (node.comments ?? (node.comments = [])).push(comment), comment.printed = !1, comment.nodeDescription = describeNodeForDebugging(node);
}
function addLeadingComment(node, comment) {
  comment.leading = !0, comment.trailing = !1, addCommentHelper(node, comment);
}
function addDanglingComment(node, comment, marker) {
  comment.leading = !1, comment.trailing = !1, marker && (comment.marker = marker), addCommentHelper(node, comment);
}
function addTrailingComment(node, comment) {
  comment.leading = !1, comment.trailing = !0, addCommentHelper(node, comment);
}
function decorateComment(node, comment, options8, enclosingNode, ancestors = []) {
  let { locStart, locEnd } = options8, commentStart = locStart(comment), commentEnd = locEnd(comment), childNodes = get_sorted_child_nodes_default(node, ancestors, {
    cache: childNodesCache,
    locStart,
    locEnd,
    getVisitorKeys: options8.getVisitorKeys,
    filter: options8.printer.canAttachComment,
    getChildren: options8.printer.getCommentChildNodes
  }), precedingNode, followingNode, left = 0, right = childNodes.length;
  for (; left < right; ) {
    let middle = left + right >> 1, child = childNodes[middle], start = locStart(child), end = locEnd(child);
    if (start <= commentStart && commentEnd <= end)
      return decorateComment(child, comment, options8, child, [
        child,
        ...ancestors
      ]);
    if (end <= commentStart) {
      precedingNode = child, left = middle + 1;
      continue;
    }
    if (commentEnd <= start) {
      followingNode = child, right = middle;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if (enclosingNode?.type === "TemplateLiteral") {
    let { quasis } = enclosingNode, commentIndex = findExpressionIndexForComment(
      quasis,
      comment,
      options8
    );
    precedingNode && findExpressionIndexForComment(quasis, precedingNode, options8) !== commentIndex && (precedingNode = null), followingNode && findExpressionIndexForComment(quasis, followingNode, options8) !== commentIndex && (followingNode = null);
  }
  return { enclosingNode, precedingNode, followingNode };
}
function attachComments(ast, options8) {
  let { comments } = ast;
  if (delete ast.comments, !is_non_empty_array_default(comments) || !options8.printer.canAttachComment)
    return;
  let tiesToBreak = [], {
    printer: {
      features: { experimental_avoidAstMutation: avoidAstMutation },
      handleComments = {}
    },
    originalText: text
  } = options8, {
    ownLine: handleOwnLineComment = returnFalse,
    endOfLine: handleEndOfLineComment = returnFalse,
    remaining: handleRemainingComment = returnFalse
  } = handleComments, decoratedComments = comments.map((comment, index) => ({
    ...decorateComment(ast, comment, options8),
    comment,
    text,
    options: options8,
    ast,
    isLastComment: comments.length - 1 === index
  }));
  for (let [index, context] of decoratedComments.entries()) {
    let {
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text: text2,
      options: options9,
      ast: ast2,
      isLastComment
    } = context, args;
    if (avoidAstMutation ? args = [context] : (comment.enclosingNode = enclosingNode, comment.precedingNode = precedingNode, comment.followingNode = followingNode, args = [comment, text2, options9, ast2, isLastComment]), isOwnLineComment(text2, options9, decoratedComments, index))
      comment.placement = "ownLine", handleOwnLineComment(...args) || (followingNode ? addLeadingComment(followingNode, comment) : precedingNode ? addTrailingComment(precedingNode, comment) : addDanglingComment(enclosingNode || ast2, comment));
    else if (isEndOfLineComment(text2, options9, decoratedComments, index))
      comment.placement = "endOfLine", handleEndOfLineComment(...args) || (precedingNode ? addTrailingComment(precedingNode, comment) : followingNode ? addLeadingComment(followingNode, comment) : addDanglingComment(enclosingNode || ast2, comment));
    else if (comment.placement = "remaining", !handleRemainingComment(...args))
      if (precedingNode && followingNode) {
        let tieCount = tiesToBreak.length;
        tieCount > 0 && tiesToBreak[tieCount - 1].followingNode !== followingNode && breakTies(tiesToBreak, options9), tiesToBreak.push(context);
      } else precedingNode ? addTrailingComment(precedingNode, comment) : followingNode ? addLeadingComment(followingNode, comment) : addDanglingComment(enclosingNode || ast2, comment);
  }
  if (breakTies(tiesToBreak, options8), !avoidAstMutation)
    for (let comment of comments)
      delete comment.precedingNode, delete comment.enclosingNode, delete comment.followingNode;
}
function isOwnLineComment(text, options8, decoratedComments, commentIndex) {
  let { comment, precedingNode } = decoratedComments[commentIndex], { locStart, locEnd } = options8, start = locStart(comment);
  if (precedingNode)
    for (let index = commentIndex - 1; index >= 0; index--) {
      let { comment: comment2, precedingNode: currentCommentPrecedingNode } = decoratedComments[index];
      if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment2), start)))
        break;
      start = locStart(comment2);
    }
  return has_newline_default(text, start, { backwards: !0 });
}
function isEndOfLineComment(text, options8, decoratedComments, commentIndex) {
  let { comment, followingNode } = decoratedComments[commentIndex], { locStart, locEnd } = options8, end = locEnd(comment);
  if (followingNode)
    for (let index = commentIndex + 1; index < decoratedComments.length; index++) {
      let { comment: comment2, followingNode: currentCommentFollowingNode } = decoratedComments[index];
      if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment2))))
        break;
      end = locEnd(comment2);
    }
  return has_newline_default(text, end);
}
function breakTies(tiesToBreak, options8) {
  let tieCount = tiesToBreak.length;
  if (tieCount === 0)
    return;
  let { precedingNode, followingNode } = tiesToBreak[0], gapEndPos = options8.locStart(followingNode), indexOfFirstLeadingComment;
  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
    let {
      comment,
      precedingNode: currentCommentPrecedingNode,
      followingNode: currentCommentFollowingNode
    } = tiesToBreak[indexOfFirstLeadingComment - 1];
    strictEqual(currentCommentPrecedingNode, precedingNode), strictEqual(currentCommentFollowingNode, followingNode);
    let gap = options8.originalText.slice(options8.locEnd(comment), gapEndPos);
    if (options8.printer.isGap?.(gap, options8) ?? /^[\s(]*$/u.test(gap))
      gapEndPos = options8.locStart(comment);
    else
      break;
  }
  for (let [i, { comment }] of tiesToBreak.entries())
    i < indexOfFirstLeadingComment ? addTrailingComment(precedingNode, comment) : addLeadingComment(followingNode, comment);
  for (let node of [precedingNode, followingNode])
    node.comments && node.comments.length > 1 && node.comments.sort((a, b) => options8.locStart(a) - options8.locStart(b));
  tiesToBreak.length = 0;
}
function findExpressionIndexForComment(quasis, comment, options8) {
  let startPos = options8.locStart(comment) - 1;
  for (let i = 1; i < quasis.length; ++i)
    if (startPos < options8.locStart(quasis[i]))
      return i - 1;
  return 0;
}
function isPreviousLineEmpty(text, startIndex) {
  let idx = startIndex - 1;
  idx = skipSpaces(text, idx, { backwards: !0 }), idx = skip_newline_default(text, idx, { backwards: !0 }), idx = skipSpaces(text, idx, { backwards: !0 });
  let idx2 = skip_newline_default(text, idx, { backwards: !0 });
  return idx !== idx2;
}
function printComment(path15, options8) {
  let comment = path15.node;
  return comment.printed = !0, options8.printer.printComment(path15, options8);
}
function printLeadingComment(path15, options8) {
  let comment = path15.node, parts = [printComment(path15, options8)], {
    printer: printer2,
    originalText,
    locStart,
    locEnd
  } = options8;
  if (printer2.isBlockComment?.(comment)) {
    let lineBreak = has_newline_default(originalText, locEnd(comment)) ? has_newline_default(originalText, locStart(comment), {
      backwards: !0
    }) ? hardline2 : line22 : " ";
    parts.push(lineBreak);
  } else
    parts.push(hardline2);
  let index = skip_newline_default(originalText, skipSpaces(originalText, locEnd(comment)));
  return index !== !1 && has_newline_default(originalText, index) && parts.push(hardline2), parts;
}
function printTrailingComment(path15, options8, previousComment) {
  let comment = path15.node, printed = printComment(path15, options8), {
    printer: printer2,
    originalText,
    locStart
  } = options8, isBlock = printer2.isBlockComment?.(comment);
  if (previousComment?.hasLineSuffix && !previousComment?.isBlock || has_newline_default(originalText, locStart(comment), {
    backwards: !0
  })) {
    let isLineBeforeEmpty = is_previous_line_empty_default(originalText, locStart(comment));
    return {
      doc: lineSuffix2([hardline2, isLineBeforeEmpty ? hardline2 : "", printed]),
      isBlock,
      hasLineSuffix: !0
    };
  }
  return !isBlock || previousComment?.hasLineSuffix ? {
    doc: [lineSuffix2([" ", printed]), breakParent2],
    isBlock,
    hasLineSuffix: !0
  } : {
    doc: [" ", printed],
    isBlock,
    hasLineSuffix: !1
  };
}
function printCommentsSeparately(path15, options8) {
  let value = path15.node;
  if (!value)
    return {};
  let ignored = options8[Symbol.for("printedComments")];
  if ((value.comments || []).filter((comment) => !ignored.has(comment)).length === 0)
    return {
      leading: "",
      trailing: ""
    };
  let leadingParts = [], trailingParts = [], printedTrailingComment;
  return path15.each(() => {
    let comment = path15.node;
    if (ignored?.has(comment))
      return;
    let {
      leading,
      trailing
    } = comment;
    leading ? leadingParts.push(printLeadingComment(path15, options8)) : trailing && (printedTrailingComment = printTrailingComment(path15, options8, printedTrailingComment), trailingParts.push(printedTrailingComment.doc));
  }, "comments"), {
    leading: leadingParts,
    trailing: trailingParts
  };
}
function printComments(path15, doc2, options8) {
  let {
    leading,
    trailing
  } = printCommentsSeparately(path15, options8);
  return !leading && !trailing ? doc2 : inheritLabel(doc2, (doc3) => [leading, doc3, trailing]);
}
function ensureAllCommentsPrinted(options8) {
  let {
    [Symbol.for("comments")]: comments,
    [Symbol.for("printedComments")]: printedComments
  } = options8;
  for (let comment of comments) {
    if (!comment.printed && !printedComments.has(comment))
      throw new Error('Comment "' + comment.value.trim() + '" was not printed. Please report this error!');
    delete comment.printed;
  }
}
function getSupportInfo({
  plugins = [],
  showDeprecated = !1
} = {}) {
  let languages2 = plugins.flatMap((plugin) => plugin.languages ?? []), options8 = [];
  for (let option of normalizeOptionSettings(Object.assign({}, ...plugins.map(({
    options: options9
  }) => options9), core_options_evaluate_default)))
    !showDeprecated && option.deprecated || (Array.isArray(option.choices) && (showDeprecated || (option.choices = option.choices.filter((choice) => !choice.deprecated)), option.name === "parser" && (option.choices = [...option.choices, ...collectParsersFromLanguages(option.choices, languages2, plugins)])), option.pluginDefaults = Object.fromEntries(plugins.filter((plugin) => plugin.defaultOptions?.[option.name] !== void 0).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])), options8.push(option));
  return {
    languages: languages2,
    options: options8
  };
}
function* collectParsersFromLanguages(parserChoices, languages2, plugins) {
  let existingParsers = new Set(parserChoices.map((choice) => choice.value));
  for (let language of languages2)
    if (language.parsers) {
      for (let parserName of language.parsers)
        if (!existingParsers.has(parserName)) {
          existingParsers.add(parserName);
          let plugin = plugins.find((plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName)), description = language.name;
          plugin?.name && (description += ` (plugin: ${plugin.name})`), yield {
            value: parserName,
            description
          };
        }
    }
}
function normalizeOptionSettings(settings) {
  let options8 = [];
  for (let [name, originalOption] of Object.entries(settings)) {
    let option = {
      name,
      ...originalOption
    };
    Array.isArray(option.default) && (option.default = method_at_default2(
      /* OPTIONAL_OBJECT: false */
      0,
      option.default,
      -1
    ).value), options8.push(option);
  }
  return options8;
}
function getInterpreter(file) {
  try {
    let liner = new import_n_readlines.default(file), firstLineBuffer = liner.next();
    if (firstLineBuffer === !1)
      return;
    liner.close();
    let firstLine = firstLineBuffer.toString("utf8"), m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/u);
    if (m1)
      return m1[1];
    let m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/u);
    if (m2)
      return m2[1];
  } catch {
  }
}
function getLanguageByFileName(languages2, file) {
  if (!file)
    return;
  let basename = getFileBasename(file).toLowerCase();
  return languages2.find(({
    filenames
  }) => filenames?.some((name) => name.toLowerCase() === basename)) ?? languages2.find(({
    extensions
  }) => extensions?.some((extension) => basename.endsWith(extension)));
}
function getLanguageByLanguageName(languages2, languageName) {
  if (languageName)
    return languages2.find(({
      name
    }) => name.toLowerCase() === languageName) ?? languages2.find(({
      aliases
    }) => aliases?.includes(languageName)) ?? languages2.find(({
      extensions
    }) => extensions?.includes(`.${languageName}`));
}
function getLanguageByInterpreterNodejs(languages2, file) {
  if (!file || getFileBasename(file).includes("."))
    return;
  let languagesWithInterpreters = languages2.filter(({
    interpreters
  }) => is_non_empty_array_default(interpreters));
  if (languagesWithInterpreters.length === 0)
    return;
  let interpreter = get_interpreter_default(file);
  if (interpreter)
    return languagesWithInterpreters.find(({
      interpreters
    }) => interpreters.includes(interpreter));
}
function getLanguageByIsSupported(languages2, file) {
  if (file) {
    if (isUrl(file))
      try {
        file = fileURLToPath5(file);
      } catch {
        return;
      }
    if (typeof file == "string")
      return languages2.find(({
        isSupported
      }) => isSupported?.({
        filepath: file
      }));
  }
}
function inferParser(options8, fileInfo) {
  let languages2 = method_to_reversed_default(
    /* OPTIONAL_OBJECT: false */
    0,
    options8.plugins
  ).flatMap((plugin) => (
    // @ts-expect-error -- Safe
    plugin.languages ?? []
  ));
  return (getLanguageByLanguageName(languages2, fileInfo.language) ?? getLanguageByFileName(languages2, fileInfo.physicalFile) ?? getLanguageByFileName(languages2, fileInfo.file) ?? getLanguageByIsSupported(languages2, fileInfo.physicalFile) ?? getLanguageByIsSupported(languages2, fileInfo.file) ?? getLanguageByInterpreter?.(languages2, fileInfo.physicalFile))?.parsers[0];
}
function normalizeOptions(options8, optionInfos, {
  logger = !1,
  isCLI = !1,
  passThrough = !1,
  FlagSchema,
  descriptor
} = {}) {
  if (isCLI) {
    if (!FlagSchema)
      throw new Error("'FlagSchema' option is required.");
    if (!descriptor)
      throw new Error("'descriptor' option is required.");
  } else
    descriptor = apiDescriptor;
  let unknown = passThrough ? Array.isArray(passThrough) ? (key2, value) => passThrough.includes(key2) ? {
    [key2]: value
  } : void 0 : (key2, value) => ({
    [key2]: value
  }) : (key2, value, options9) => {
    let {
      _,
      ...schemas2
    } = options9.schemas;
    return levenUnknownHandler(key2, value, {
      ...options9,
      schemas: schemas2
    });
  }, schemas = optionInfosToSchemas(optionInfos, {
    isCLI,
    FlagSchema
  }), normalizer = new Normalizer(schemas, {
    logger,
    unknown,
    descriptor
  }), shouldSuppressDuplicateDeprecationWarnings = logger !== !1;
  shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned && (normalizer._hasDeprecationWarned = hasDeprecationWarned);
  let normalized = normalizer.normalize(options8);
  return shouldSuppressDuplicateDeprecationWarnings && (hasDeprecationWarned = normalizer._hasDeprecationWarned), normalized;
}
function optionInfosToSchemas(optionInfos, {
  isCLI,
  FlagSchema
}) {
  let schemas = [];
  isCLI && schemas.push(AnySchema.create({
    name: "_"
  }));
  for (let optionInfo of optionInfos)
    schemas.push(optionInfoToSchema(optionInfo, {
      isCLI,
      optionInfos,
      FlagSchema
    })), optionInfo.alias && isCLI && schemas.push(AliasSchema.create({
      // @ts-expect-error
      name: optionInfo.alias,
      sourceName: optionInfo.name
    }));
  return schemas;
}
function optionInfoToSchema(optionInfo, {
  isCLI,
  optionInfos,
  FlagSchema
}) {
  let {
    name
  } = optionInfo, parameters = {
    name
  }, SchemaConstructor, handlers = {};
  switch (optionInfo.type) {
    case "int":
      SchemaConstructor = IntegerSchema, isCLI && (parameters.preprocess = Number);
      break;
    case "string":
      SchemaConstructor = StringSchema;
      break;
    case "choice":
      SchemaConstructor = ChoiceSchema, parameters.choices = optionInfo.choices.map((choiceInfo) => choiceInfo?.redirect ? {
        ...choiceInfo,
        redirect: {
          to: {
            key: optionInfo.name,
            value: choiceInfo.redirect
          }
        }
      } : choiceInfo);
      break;
    case "boolean":
      SchemaConstructor = BooleanSchema;
      break;
    case "flag":
      SchemaConstructor = FlagSchema, parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));
      break;
    case "path":
      SchemaConstructor = StringSchema;
      break;
    default:
      throw new Error(`Unexpected type ${optionInfo.type}`);
  }
  if (optionInfo.exception ? parameters.validate = (value, schema, utils2) => optionInfo.exception(value) || schema.validate(value, utils2) : parameters.validate = (value, schema, utils2) => value === void 0 || schema.validate(value, utils2), optionInfo.redirect && (handlers.redirect = (value) => value ? {
    to: typeof optionInfo.redirect == "string" ? optionInfo.redirect : {
      key: optionInfo.redirect.option,
      value: optionInfo.redirect.value
    }
  } : void 0), optionInfo.deprecated && (handlers.deprecated = !0), isCLI && !optionInfo.array) {
    let originalPreprocess = parameters.preprocess || ((x) => x);
    parameters.preprocess = (value, schema, utils2) => schema.preprocess(originalPreprocess(Array.isArray(value) ? method_at_default2(
      /* OPTIONAL_OBJECT: false */
      0,
      value,
      -1
    ) : value), utils2);
  }
  return optionInfo.array ? ArraySchema.create({
    ...isCLI ? {
      preprocess: (v) => Array.isArray(v) ? v : [v]
    } : {},
    ...handlers,
    // @ts-expect-error
    valueSchema: SchemaConstructor.create(parameters)
  }) : SchemaConstructor.create({
    ...parameters,
    ...handlers
  });
}
function isFrontMatter(node) {
  return !!node?.[FRONT_MATTER_MARK];
}
async function printEmbedFrontMatter(textToDoc2, print, path15, options8) {
  let {
    node
  } = path15, {
    language
  } = node;
  if (!SUPPORTED_EMBED_LANGUAGES.has(language))
    return;
  let value = node.value.trim(), doc2;
  if (value) {
    let parser = language === "yaml" ? language : infer_parser_default(options8, {
      language
    });
    if (!parser)
      return;
    doc2 = value ? await textToDoc2(value, {
      parser
    }) : "";
  } else
    doc2 = value;
  return markAsRoot2([node.startDelimiter, node.explicitLanguage ?? "", hardline22, doc2, doc2 ? hardline22 : "", node.endDelimiter]);
}
function clean(original, cloned) {
  return isEmbedFrontMatter({ node: original }) && (delete cloned.end, delete cloned.raw, delete cloned.value), cloned;
}
function printFrontMatter({ node }) {
  return node.raw;
}
function createGetVisitorKeysFunction(printerGetVisitorKeys, supportFrontMatter) {
  let getVisitorKeys = printerGetVisitorKeys ? (node) => printerGetVisitorKeys(node, nonTraversableKeys) : defaultGetVisitorKeys;
  return supportFrontMatter ? new Proxy(getVisitorKeys, {
    apply: (target, thisArgument, argumentsList) => is_front_matter_default(argumentsList[0]) ? FRONT_MATTER_VISITOR_KEYS : Reflect.apply(target, thisArgument, argumentsList)
  }) : getVisitorKeys;
}
function getParserPluginByParserName(plugins, parserName) {
  if (!parserName)
    throw new Error("parserName is required.");
  let plugin = method_find_last_default(
    /* OPTIONAL_OBJECT: false */
    0,
    plugins,
    (plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName)
  );
  if (plugin)
    return plugin;
  let message = `Couldn't resolve parser "${parserName}".`;
  throw new ConfigError(message);
}
function getPrinterPluginByAstFormat(plugins, astFormat) {
  if (!astFormat)
    throw new Error("astFormat is required.");
  let plugin = method_find_last_default(
    /* OPTIONAL_OBJECT: false */
    0,
    plugins,
    (plugin2) => plugin2.printers && Object.prototype.hasOwnProperty.call(plugin2.printers, astFormat)
  );
  if (plugin)
    return plugin;
  let message = `Couldn't find plugin for AST format "${astFormat}".`;
  throw new ConfigError(message);
}
function resolveParser({
  plugins,
  parser
}) {
  let plugin = getParserPluginByParserName(plugins, parser);
  return initParser(plugin, parser);
}
function initParser(plugin, parserName) {
  let parserOrParserInitFunction = plugin.parsers[parserName];
  return typeof parserOrParserInitFunction == "function" ? parserOrParserInitFunction() : parserOrParserInitFunction;
}
async function initPrinter(plugin, astFormat) {
  let printerOrPrinterInitFunction = plugin.printers[astFormat], printer2 = typeof printerOrPrinterInitFunction == "function" ? await printerOrPrinterInitFunction() : printerOrPrinterInitFunction;
  return normalizePrinter(printer2);
}
function normalizePrinter(printer2) {
  if (normalizedPrinters.has(printer2))
    return normalizedPrinters.get(printer2);
  let {
    features,
    getVisitorKeys,
    embed: originalEmbed,
    massageAstNode: originalCleanFunction,
    print: originalPrint,
    ...printerRestProperties
  } = printer2;
  features = normalizePrinterFeatures(features);
  let frontMatterSupport = features.experimental_frontMatterSupport;
  getVisitorKeys = create_get_visitor_keys_function_default(
    getVisitorKeys,
    /** frontMatterVisitorKeys */
    frontMatterSupport.massageAstNode || frontMatterSupport.embed || frontMatterSupport.print
  );
  let massageAstNode = originalCleanFunction;
  originalCleanFunction && frontMatterSupport.massageAstNode && (massageAstNode = new Proxy(originalCleanFunction, {
    apply(target, thisArgument, argumentsList) {
      return clean_default(...argumentsList), Reflect.apply(target, thisArgument, argumentsList);
    }
  }));
  let embed = originalEmbed;
  if (originalEmbed) {
    let embedGetVisitorKeys;
    embed = new Proxy(originalEmbed, {
      get(target, property, receiver) {
        return property === "getVisitorKeys" ? (embedGetVisitorKeys ?? (embedGetVisitorKeys = originalEmbed.getVisitorKeys ? create_get_visitor_keys_function_default(
          originalEmbed.getVisitorKeys,
          /** frontMatterVisitorKeys */
          frontMatterSupport.massageAstNode || frontMatterSupport.embed
        ) : getVisitorKeys), embedGetVisitorKeys) : Reflect.get(target, property, receiver);
      },
      apply: (target, thisArgument, argumentsList) => frontMatterSupport.embed && isEmbedFrontMatter(...argumentsList) ? printEmbedFrontMatter : Reflect.apply(target, thisArgument, argumentsList)
    });
  }
  let print = originalPrint;
  frontMatterSupport.print && (print = new Proxy(originalPrint, {
    apply(target, thisArgument, argumentsList) {
      let [path15] = argumentsList;
      return is_front_matter_default(path15.node) ? print_default(path15) : Reflect.apply(target, thisArgument, argumentsList);
    }
  }));
  let normalizedPrinter = {
    features,
    getVisitorKeys,
    embed,
    massageAstNode,
    print,
    ...printerRestProperties
  };
  return normalizedPrinters.set(printer2, normalizedPrinter), normalizedPrinter;
}
function normalizePrinterFrontMatterSupport(frontMatterSupport) {
  return {
    ...PRINTER_FRONT_MATTER_SUPPORT_OFF,
    ...frontMatterSupport
  };
}
function normalizePrinterFeatures(features) {
  return {
    experimental_avoidAstMutation: !1,
    ...features,
    experimental_frontMatterSupport: normalizePrinterFrontMatterSupport(features?.experimental_frontMatterSupport)
  };
}
async function normalizeFormatOptions(options8, opts = {}) {
  let rawOptions = { ...options8 };
  if (!rawOptions.parser)
    if (rawOptions.filepath) {
      if (rawOptions.parser = infer_parser_default(rawOptions, {
        physicalFile: rawOptions.filepath
      }), !rawOptions.parser)
        throw new UndefinedParserError(
          `No parser could be inferred for file "${rawOptions.filepath}".`
        );
    } else
      throw new UndefinedParserError(
        "No parser and no file path given, couldn't infer a parser."
      );
  let supportOptions = getSupportInfo({
    plugins: options8.plugins,
    showDeprecated: !0
  }).options, defaults = {
    ...formatOptionsHiddenDefaults,
    ...Object.fromEntries(
      supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])
    )
  }, parserPlugin = getParserPluginByParserName(
    rawOptions.plugins,
    rawOptions.parser
  ), parser = await initParser(parserPlugin, rawOptions.parser);
  rawOptions.astFormat = parser.astFormat, rawOptions.locEnd = parser.locEnd, rawOptions.locStart = parser.locStart;
  let printerPlugin = parserPlugin.printers?.[parser.astFormat] ? parserPlugin : getPrinterPluginByAstFormat(rawOptions.plugins, parser.astFormat), printer2 = await initPrinter(printerPlugin, parser.astFormat);
  rawOptions.printer = printer2, rawOptions.getVisitorKeys = printer2.getVisitorKeys;
  let pluginDefaults = printerPlugin.defaultOptions ? Object.fromEntries(
    Object.entries(printerPlugin.defaultOptions).filter(
      ([, value]) => value !== void 0
    )
  ) : {}, mixedDefaults = { ...defaults, ...pluginDefaults };
  for (let [k, value] of Object.entries(mixedDefaults))
    (rawOptions[k] === null || rawOptions[k] === void 0) && (rawOptions[k] = value);
  return rawOptions.parser === "json" && (rawOptions.trailingComma = "none"), normalize_options_default(rawOptions, supportOptions, {
    passThrough: Object.keys(formatOptionsHiddenDefaults),
    ...opts
  });
}
async function parse5(originalText, options8) {
  let parser = await resolveParser(options8), text = parser.preprocess ? await parser.preprocess(originalText, options8) : originalText;
  options8.originalText = text;
  let ast;
  try {
    ast = await parser.parse(
      text,
      options8,
      // TODO: remove the third argument in v4
      // The duplicated argument is passed as intended, see #10156
      options8
    );
  } catch (error) {
    handleParseError(error, originalText);
  }
  return { text, ast };
}
function handleParseError(error, text) {
  let { loc } = error;
  if (loc) {
    let codeFrame = codeFrameColumns(text, loc, { highlightCode: !0 });
    throw error.message += `
` + codeFrame, error.codeFrame = codeFrame, error;
  }
  throw error;
}
async function printEmbeddedLanguages(path15, genericPrint, options8, printAstToDoc2, embeds) {
  if (options8.embeddedLanguageFormatting !== "auto")
    return;
  let {
    printer: printer2
  } = options8, {
    embed
  } = printer2;
  if (!embed)
    return;
  if (embed.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let {
    hasPrettierIgnore
  } = printer2, {
    getVisitorKeys
  } = embed, embedCallResults = [];
  recurse();
  let originalPathStack = path15.stack;
  for (let {
    print,
    node,
    pathStack
  } of embedCallResults)
    try {
      path15.stack = pathStack;
      let doc2 = await print(textToDocForEmbed, genericPrint, path15, options8);
      doc2 && embeds.set(node, doc2);
    } catch (error) {
      if (process.env.PRETTIER_DEBUG)
        throw error;
    }
  path15.stack = originalPathStack;
  function textToDocForEmbed(text, partialNextOptions) {
    return textToDoc(text, partialNextOptions, options8, printAstToDoc2);
  }
  function recurse() {
    let {
      node
    } = path15;
    if (node === null || typeof node != "object" || hasPrettierIgnore?.(path15))
      return;
    for (let key2 of getVisitorKeys(node))
      Array.isArray(node[key2]) ? path15.each(recurse, key2) : path15.call(recurse, key2);
    let result = embed(path15, options8);
    if (result) {
      if (typeof result == "function") {
        embedCallResults.push({
          print: result,
          node,
          pathStack: [...path15.stack]
        });
        return;
      }
      embeds.set(node, result);
    }
  }
}
async function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc2) {
  let options8 = await normalize_format_options_default({
    ...parentOptions,
    ...partialNextOptions,
    parentParser: parentOptions.parser,
    originalText: text,
    // Improve this if we calculate the relative index
    cursorOffset: void 0,
    rangeStart: void 0,
    rangeEnd: void 0
  }, {
    passThrough: !0
  }), {
    ast
  } = await parse_default(text, options8), doc2 = await printAstToDoc2(ast, options8);
  return stripTrailingHardline2(doc2);
}
function printIgnored(path15, options8, printPath, args) {
  let {
    originalText,
    [Symbol.for("comments")]: comments,
    locStart,
    locEnd,
    [Symbol.for("printedComments")]: printedComments
  } = options8, { node } = path15, start = locStart(node), end = locEnd(node);
  for (let comment of comments)
    locStart(comment) >= start && locEnd(comment) <= end && printedComments.add(comment);
  let { printPrettierIgnored } = options8.printer;
  return printPrettierIgnored ? printPrettierIgnored(path15, options8, printPath, args) : originalText.slice(start, end);
}
async function printAstToDoc(ast, options8) {
  ({
    ast
  } = await prepareToPrint(ast, options8));
  let cache3 = /* @__PURE__ */ new Map(), path15 = new ast_path_default(ast), ensurePrintingNode = create_print_pre_check_function_default(options8), embeds = /* @__PURE__ */ new Map();
  await printEmbeddedLanguages(path15, mainPrint, options8, printAstToDoc, embeds);
  let doc2 = await callPluginPrintFunction(path15, options8, mainPrint, void 0, embeds);
  if (ensureAllCommentsPrinted(options8), options8.cursorOffset >= 0) {
    if (options8.nodeAfterCursor && !options8.nodeBeforeCursor)
      return [cursor2, doc2];
    if (options8.nodeBeforeCursor && !options8.nodeAfterCursor)
      return [doc2, cursor2];
  }
  return doc2;
  function mainPrint(selector, args) {
    return selector === void 0 || selector === path15 ? mainPrintInternal(args) : Array.isArray(selector) ? path15.call(() => mainPrintInternal(args), ...selector) : path15.call(() => mainPrintInternal(args), selector);
  }
  function mainPrintInternal(args) {
    ensurePrintingNode(path15);
    let value = path15.node;
    if (value == null)
      return "";
    let shouldCache = is_object_default(value) && args === void 0;
    if (shouldCache && cache3.has(value))
      return cache3.get(value);
    let doc3 = callPluginPrintFunction(path15, options8, mainPrint, args, embeds);
    return shouldCache && cache3.set(value, doc3), doc3;
  }
}
function callPluginPrintFunction(path15, options8, printPath, args, embeds) {
  let {
    node
  } = path15, {
    printer: printer2
  } = options8, doc2;
  switch (printer2.hasPrettierIgnore?.(path15) ? doc2 = print_ignored_default(path15, options8, printPath, args) : embeds.has(node) ? doc2 = embeds.get(node) : doc2 = printer2.print(path15, options8, printPath, args), node) {
    case options8.cursorNode:
      doc2 = inheritLabel(doc2, (doc3) => [cursor2, doc3, cursor2]);
      break;
    case options8.nodeBeforeCursor:
      doc2 = inheritLabel(doc2, (doc3) => [doc3, cursor2]);
      break;
    case options8.nodeAfterCursor:
      doc2 = inheritLabel(doc2, (doc3) => [cursor2, doc3]);
      break;
  }
  return printer2.printComment && !printer2.willPrintOwnComments?.(path15, options8) && (doc2 = printComments(path15, doc2, options8)), doc2;
}
async function prepareToPrint(ast, options8) {
  let comments = ast.comments ?? [];
  options8[Symbol.for("comments")] = comments, options8[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), attachComments(ast, options8);
  let {
    printer: {
      preprocess
    }
  } = options8;
  return ast = preprocess ? await preprocess(ast, options8) : ast, {
    ast,
    comments
  };
}
function getCursorLocation(ast, options8) {
  let { cursorOffset, locStart, locEnd, getVisitorKeys } = options8, nodeContainsCursor = (node) => locStart(node) <= cursorOffset && locEnd(node) >= cursorOffset, cursorNode = ast, nodesContainingCursor = [ast];
  for (let node of getDescendants(ast, {
    getVisitorKeys,
    filter: nodeContainsCursor
  }))
    nodesContainingCursor.push(node), cursorNode = node;
  if (isLeaf(cursorNode, { getVisitorKeys }))
    return { cursorNode };
  let nodeBeforeCursor, nodeAfterCursor, nodeBeforeCursorEndIndex = -1, nodeAfterCursorStartIndex = Number.POSITIVE_INFINITY;
  for (; nodesContainingCursor.length > 0 && (nodeBeforeCursor === void 0 || nodeAfterCursor === void 0); ) {
    cursorNode = nodesContainingCursor.pop();
    let foundBeforeNode = nodeBeforeCursor !== void 0, foundAfterNode = nodeAfterCursor !== void 0;
    for (let node of getChildren(cursorNode, { getVisitorKeys })) {
      if (!foundBeforeNode) {
        let nodeEnd = locEnd(node);
        nodeEnd <= cursorOffset && nodeEnd > nodeBeforeCursorEndIndex && (nodeBeforeCursor = node, nodeBeforeCursorEndIndex = nodeEnd);
      }
      if (!foundAfterNode) {
        let nodeStart = locStart(node);
        nodeStart >= cursorOffset && nodeStart < nodeAfterCursorStartIndex && (nodeAfterCursor = node, nodeAfterCursorStartIndex = nodeStart);
      }
    }
  }
  return {
    nodeBeforeCursor,
    nodeAfterCursor
  };
}
function massageAst(ast, options8) {
  let {
    printer: printer2
  } = options8, clean2 = printer2.massageAstNode;
  if (!clean2)
    return ast;
  let {
    getVisitorKeys
  } = printer2, {
    ignoredProperties
  } = clean2;
  return recurse(ast);
  function recurse(original, parent) {
    if (!is_object_default(original))
      return original;
    if (Array.isArray(original))
      return original.map((child) => recurse(child, parent)).filter(Boolean);
    let cloned = {}, childrenKeys = new Set(getVisitorKeys(original));
    for (let key2 in original)
      !Object.prototype.hasOwnProperty.call(original, key2) || ignoredProperties?.has(key2) || (childrenKeys.has(key2) ? cloned[key2] = recurse(original[key2], original) : cloned[key2] = original[key2]);
    let result = clean2(original, cloned, parent);
    if (result !== null)
      return result ?? cloned;
  }
}
function findCommonAncestor(startNodeAndAncestors, endNodeAndAncestors) {
  return endNodeAndAncestors = new Set(endNodeAndAncestors), startNodeAndAncestors.find((node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node));
}
function dropRootParents(parents) {
  let index = method_find_last_index_default(
    /* OPTIONAL_OBJECT: false */
    0,
    parents,
    (node) => node.type !== "Program" && node.type !== "File"
  );
  return index === -1 ? parents : parents.slice(0, index + 1);
}
function findSiblingAncestors(startNodeAndAncestors, endNodeAndAncestors, {
  locStart,
  locEnd
}) {
  let [resultStartNode, ...startNodeAncestors] = startNodeAndAncestors, [resultEndNode, ...endNodeAncestors] = endNodeAndAncestors;
  if (resultStartNode === resultEndNode)
    return [resultStartNode, resultEndNode];
  let startNodeStart = locStart(resultStartNode);
  for (let endAncestor of dropRootParents(endNodeAncestors))
    if (locStart(endAncestor) >= startNodeStart)
      resultEndNode = endAncestor;
    else
      break;
  let endNodeEnd = locEnd(resultEndNode);
  for (let startAncestor of dropRootParents(startNodeAncestors)) {
    if (locEnd(startAncestor) <= endNodeEnd)
      resultStartNode = startAncestor;
    else
      break;
    if (resultStartNode === resultEndNode)
      break;
  }
  return [resultStartNode, resultEndNode];
}
function findNodeAtOffset(node, offset, options8, predicate, ancestors = [], type) {
  let {
    locStart,
    locEnd
  } = options8, start = locStart(node), end = locEnd(node);
  if (offset > end || offset < start || type === "rangeEnd" && offset === start || type === "rangeStart" && offset === end)
    return;
  let nodeAndAncestors = [node, ...ancestors], childNodes = get_sorted_child_nodes_default(node, nodeAndAncestors, {
    cache: childNodesCache,
    locStart,
    locEnd,
    getVisitorKeys: options8.getVisitorKeys,
    // These two property should be removed, since we don't care if it can attach comment
    filter: options8.printer.canAttachComment,
    getChildren: options8.printer.getCommentChildNodes
  });
  for (let child of childNodes) {
    let childAndAncestors = findNodeAtOffset(child, offset, options8, predicate, nodeAndAncestors, type);
    if (childAndAncestors)
      return childAndAncestors;
  }
  if (predicate(node, ancestors[0]))
    return nodeAndAncestors;
}
function isJsSourceElement(type, parentType) {
  return parentType !== "DeclareExportDeclaration" && type !== "TypeParameterDeclaration" && (type === "Directive" || type === "TypeAlias" || type === "TSExportAssignment" || type.startsWith("Declare") || type.startsWith("TSDeclare") || type.endsWith("Statement") || type.endsWith("Declaration"));
}
function isSourceElement(opts, node, parentNode) {
  if (!node)
    return !1;
  switch (opts.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return isJsSourceElement(node.type, parentNode?.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return jsonSourceElements.has(node.type);
    case "graphql":
      return graphqlSourceElements.has(node.kind);
    case "vue":
      return node.tag !== "root";
  }
  return !1;
}
function calculateRange(text, opts, ast) {
  let {
    rangeStart: start,
    rangeEnd: end,
    locStart,
    locEnd
  } = opts;
  ok(end > start);
  let firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\S/u), isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;
  if (!isAllWhitespace)
    for (start += firstNonWhitespaceCharacterIndex; end > start && !/\S/u.test(text[end - 1]); --end)
      ;
  let startNodeAndAncestors = findNodeAtOffset(ast, start, opts, (node, parentNode) => isSourceElement(opts, node, parentNode), [], "rangeStart");
  if (!startNodeAndAncestors)
    return;
  let endNodeAndAncestors = (
    // No need find Node at `end`, it will be the same as `startNodeAndAncestors`
    isAllWhitespace ? startNodeAndAncestors : findNodeAtOffset(ast, end, opts, (node) => isSourceElement(opts, node), [], "rangeEnd")
  );
  if (!endNodeAndAncestors)
    return;
  let startNode, endNode;
  if (isJsonParser(opts)) {
    let commonAncestor = findCommonAncestor(startNodeAndAncestors, endNodeAndAncestors);
    startNode = commonAncestor, endNode = commonAncestor;
  } else
    [startNode, endNode] = findSiblingAncestors(startNodeAndAncestors, endNodeAndAncestors, opts);
  return [Math.min(locStart(startNode), locStart(endNode)), Math.max(locEnd(startNode), locEnd(endNode))];
}
async function coreFormat(originalText, opts, addAlignmentSize = 0) {
  if (!originalText || originalText.trim().length === 0)
    return {
      formatted: "",
      cursorOffset: -1,
      comments: []
    };
  let {
    ast,
    text
  } = await parse_default(originalText, opts);
  opts.cursorOffset >= 0 && (opts = {
    ...opts,
    ...get_cursor_node_default(ast, opts)
  });
  let doc2 = await printAstToDoc(ast, opts, addAlignmentSize);
  addAlignmentSize > 0 && (doc2 = addAlignmentToDoc2([hardline3, doc2], addAlignmentSize, opts.tabWidth));
  let result = printDocToStringWithoutNormalizeOptions(doc2, opts);
  if (addAlignmentSize > 0) {
    let trimmed = result.formatted.trim();
    result.cursorNodeStart !== void 0 && (result.cursorNodeStart -= result.formatted.indexOf(trimmed), result.cursorNodeStart < 0 && (result.cursorNodeStart = 0, result.cursorNodeText = result.cursorNodeText.trimStart()), result.cursorNodeStart + result.cursorNodeText.length > trimmed.length && (result.cursorNodeText = result.cursorNodeText.trimEnd())), result.formatted = trimmed + convertEndOfLineOptionToCharacter2(opts.endOfLine);
  }
  let comments = opts[Symbol.for("comments")];
  if (opts.cursorOffset >= 0) {
    let oldCursorRegionStart, oldCursorRegionText, newCursorRegionStart, newCursorRegionText;
    if ((opts.cursorNode || opts.nodeBeforeCursor || opts.nodeAfterCursor) && result.cursorNodeText)
      if (newCursorRegionStart = result.cursorNodeStart, newCursorRegionText = result.cursorNodeText, opts.cursorNode)
        oldCursorRegionStart = opts.locStart(opts.cursorNode), oldCursorRegionText = text.slice(oldCursorRegionStart, opts.locEnd(opts.cursorNode));
      else {
        if (!opts.nodeBeforeCursor && !opts.nodeAfterCursor)
          throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
        oldCursorRegionStart = opts.nodeBeforeCursor ? opts.locEnd(opts.nodeBeforeCursor) : 0;
        let oldCursorRegionEnd = opts.nodeAfterCursor ? opts.locStart(opts.nodeAfterCursor) : text.length;
        oldCursorRegionText = text.slice(oldCursorRegionStart, oldCursorRegionEnd);
      }
    else
      oldCursorRegionStart = 0, oldCursorRegionText = text, newCursorRegionStart = 0, newCursorRegionText = result.formatted;
    let cursorOffsetRelativeToOldCursorRegionStart = opts.cursorOffset - oldCursorRegionStart;
    if (oldCursorRegionText === newCursorRegionText)
      return {
        formatted: result.formatted,
        cursorOffset: newCursorRegionStart + cursorOffsetRelativeToOldCursorRegionStart,
        comments
      };
    let oldCursorNodeCharArray = oldCursorRegionText.split("");
    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorRegionStart, 0, CURSOR);
    let newCursorNodeCharArray = newCursorRegionText.split(""), cursorNodeDiff = diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray), cursorOffset = newCursorRegionStart;
    for (let entry of cursorNodeDiff)
      if (entry.removed) {
        if (entry.value.includes(CURSOR))
          break;
      } else
        cursorOffset += entry.count;
    return {
      formatted: result.formatted,
      cursorOffset,
      comments
    };
  }
  return {
    formatted: result.formatted,
    cursorOffset: -1,
    comments
  };
}
async function formatRange(originalText, opts) {
  let {
    ast,
    text
  } = await parse_default(originalText, opts), [rangeStart, rangeEnd] = calculateRange(text, opts, ast) ?? [0, 0], rangeString = text.slice(rangeStart, rangeEnd), rangeStart2 = Math.min(rangeStart, text.lastIndexOf(`
`, rangeStart) + 1), indentString = text.slice(rangeStart2, rangeStart).match(/^\s*/u)[0], alignmentSize = get_alignment_size_default(indentString, opts.tabWidth), rangeResult = await coreFormat(rangeString, {
    ...opts,
    rangeStart: 0,
    rangeEnd: Number.POSITIVE_INFINITY,
    // Track the cursor offset only if it's within our range
    cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,
    // Always use `lf` to format, we'll replace it later
    endOfLine: "lf"
  }, alignmentSize), rangeTrimmed = rangeResult.formatted.trimEnd(), {
    cursorOffset
  } = opts;
  cursorOffset > rangeEnd ? cursorOffset += rangeTrimmed.length - rangeString.length : rangeResult.cursorOffset >= 0 && (cursorOffset = rangeResult.cursorOffset + rangeStart);
  let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);
  if (opts.endOfLine !== "lf") {
    let eol = convertEndOfLineOptionToCharacter2(opts.endOfLine);
    cursorOffset >= 0 && eol === `\r
` && (cursorOffset += countEndOfLineCharacters(formatted.slice(0, cursorOffset), `
`)), formatted = method_replace_all_default2(
      /* OPTIONAL_OBJECT: false */
      0,
      formatted,
      `
`,
      eol
    );
  }
  return {
    formatted,
    cursorOffset,
    comments: rangeResult.comments
  };
}
function ensureIndexInText(text, index, defaultValue) {
  return typeof index != "number" || Number.isNaN(index) || index < 0 || index > text.length ? defaultValue : index;
}
function normalizeIndexes(text, options8) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd
  } = options8;
  return cursorOffset = ensureIndexInText(text, cursorOffset, -1), rangeStart = ensureIndexInText(text, rangeStart, 0), rangeEnd = ensureIndexInText(text, rangeEnd, text.length), {
    ...options8,
    cursorOffset,
    rangeStart,
    rangeEnd
  };
}
function normalizeInputAndOptions(text, options8) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd,
    endOfLine
  } = normalizeIndexes(text, options8), hasBOM = text.charAt(0) === BOM;
  if (hasBOM && (text = text.slice(1), cursorOffset--, rangeStart--, rangeEnd--), endOfLine === "auto" && (endOfLine = guessEndOfLine(text)), text.includes("\r")) {
    let countCrlfBefore = (index) => countEndOfLineCharacters(text.slice(0, Math.max(index, 0)), `\r
`);
    cursorOffset -= countCrlfBefore(cursorOffset), rangeStart -= countCrlfBefore(rangeStart), rangeEnd -= countCrlfBefore(rangeEnd), text = normalizeEndOfLine(text);
  }
  return {
    hasBOM,
    text,
    options: normalizeIndexes(text, {
      ...options8,
      cursorOffset,
      rangeStart,
      rangeEnd,
      endOfLine
    })
  };
}
async function hasPragma(text, options8) {
  let selectedParser = await resolveParser(options8);
  return !selectedParser.hasPragma || selectedParser.hasPragma(text);
}
async function hasIgnorePragma(text, options8) {
  return (await resolveParser(options8)).hasIgnorePragma?.(text);
}
async function formatWithCursor(originalText, originalOptions) {
  let {
    hasBOM,
    text,
    options: options8
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));
  if (options8.rangeStart >= options8.rangeEnd && text !== "" || options8.requirePragma && !await hasPragma(text, options8) || options8.checkIgnorePragma && await hasIgnorePragma(text, options8))
    return {
      formatted: originalText,
      cursorOffset: originalOptions.cursorOffset,
      comments: []
    };
  let result;
  return options8.rangeStart > 0 || options8.rangeEnd < text.length ? result = await formatRange(text, options8) : (!options8.requirePragma && options8.insertPragma && options8.printer.insertPragma && !await hasPragma(text, options8) && (text = options8.printer.insertPragma(text)), result = await coreFormat(text, options8)), hasBOM && (result.formatted = BOM + result.formatted, result.cursorOffset >= 0 && result.cursorOffset++), result;
}
async function parse6(originalText, originalOptions, devOptions) {
  let {
    text,
    options: options8
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions)), parsed = await parse_default(text, options8);
  return devOptions && (devOptions.preprocessForPrint && (parsed.ast = await prepareToPrint(parsed.ast, options8)), devOptions.massage && (parsed.ast = massage_ast_default(parsed.ast, options8))), parsed;
}
async function formatAst(ast, options8) {
  options8 = await normalize_format_options_default(options8);
  let doc2 = await printAstToDoc(ast, options8);
  return printDocToStringWithoutNormalizeOptions(doc2, options8);
}
async function formatDoc(doc2, options8) {
  let text = printDocToDebug(doc2), {
    formatted
  } = await formatWithCursor(text, {
    ...options8,
    parser: "__js_expression"
  });
  return formatted;
}
async function printToDoc(originalText, options8) {
  options8 = await normalize_format_options_default(options8);
  let {
    ast
  } = await parse_default(originalText, options8);
  return options8.cursorOffset >= 0 && (options8 = {
    ...options8,
    ...get_cursor_node_default(ast, options8)
  }), printAstToDoc(ast, options8);
}
async function printDocToString2(doc2, options8) {
  return printDocToStringWithoutNormalizeOptions(doc2, await normalize_format_options_default(options8));
}
function createParsersAndPrinters(modules) {
  let parsers2 = /* @__PURE__ */ Object.create(null), printers2 = /* @__PURE__ */ Object.create(null);
  for (let {
    importPlugin: importPlugin2,
    parsers: parserNames = [],
    printers: printerNames = []
  } of modules) {
    let loadPlugin2 = async () => {
      let plugin = await importPlugin2();
      return Object.assign(parsers2, plugin.parsers), Object.assign(printers2, plugin.printers), plugin;
    };
    for (let parserName of parserNames)
      parsers2[parserName] = async () => (await loadPlugin2()).parsers[parserName];
    for (let printerName of printerNames)
      printers2[printerName] = async () => (await loadPlugin2()).printers[printerName];
  }
  return { parsers: parsers2, printers: printers2 };
}
function loadBuiltinPlugins() {
  return builtin_plugins_proxy_default;
}
function importFromDirectory(specifier, directory) {
  return import_from_file_default(specifier, path12.join(directory, "noop.js"));
}
async function importPlugin(name, cwd) {
  if (isUrl(name))
    return import(name);
  if (path13.isAbsolute(name))
    return import(pathToFileURL5(name).href);
  try {
    return await import(pathToFileURL5(path13.resolve(name)).href);
  } catch {
    return import_from_directory_default(name, cwd);
  }
}
async function loadPluginWithoutCache(plugin, cwd) {
  let module = await importPlugin(plugin, cwd), implementation = module.default ?? module;
  return { name: isUrl(plugin) ? toPath(plugin) : plugin, ...implementation };
}
function loadPlugin(plugin) {
  if (typeof plugin != "string" && !(plugin instanceof URL))
    return plugin;
  let cwd = process.cwd(), cacheKey = JSON.stringify({ name: plugin, cwd });
  return cache2.has(cacheKey) || cache2.set(cacheKey, loadPluginWithoutCache(plugin, cwd)), cache2.get(cacheKey);
}
function clearCache2() {
  cache2.clear();
}
function loadPlugins(plugins = []) {
  return Promise.all(plugins.map((plugin) => loadPlugin(plugin)));
}
function getRelativePath(file, ignoreFile) {
  let ignoreFilePath = toPath(ignoreFile), filePath = isUrl(file) ? url2.fileURLToPath(file) : path14.resolve(file);
  return path14.relative(
    // If there's an ignore-path set, the filename must be relative to the
    // ignore path, not the current working directory.
    ignoreFilePath ? path14.dirname(ignoreFilePath) : process.cwd(),
    filePath
  );
}
async function createSingleIsIgnoredFunction(ignoreFile, withNodeModules) {
  let content = "";
  if (ignoreFile && (content += await read_file_default(ignoreFile) ?? ""), withNodeModules || (content += `
node_modules`), !content)
    return;
  let ignore = (0, import_ignore.default)({
    allowRelativePaths: !0
  }).add(content);
  return (file) => ignore.checkIgnore(slash(getRelativePath(file, ignoreFile))).ignored;
}
async function createIsIgnoredFunction(ignoreFiles, withNodeModules) {
  ignoreFiles.length === 0 && !withNodeModules && (ignoreFiles = [void 0]);
  let isIgnoredFunctions = (await Promise.all(ignoreFiles.map((ignoreFile) => createSingleIsIgnoredFunction(ignoreFile, withNodeModules)))).filter(Boolean);
  return (file) => isIgnoredFunctions.some((isIgnored2) => isIgnored2(file));
}
async function isIgnored(file, options8) {
  let {
    ignorePath: ignoreFiles,
    withNodeModules
  } = options8;
  return (await createIsIgnoredFunction(ignoreFiles, withNodeModules))(file);
}
function omit(object, keys) {
  return keys = new Set(keys), Object.fromEntries(
    Object.entries(object).filter(([key2]) => !keys.has(key2))
  );
}
async function getFileInfo(file, options8 = {}) {
  if (typeof file != "string" && !(file instanceof URL))
    throw new TypeError(
      `expect \`file\` to be a string or URL, got \`${typeof file}\``
    );
  let { ignorePath, withNodeModules } = options8;
  Array.isArray(ignorePath) || (ignorePath = [ignorePath]);
  let ignored = await isIgnored(file, { ignorePath, withNodeModules }), inferredParser;
  return ignored || (inferredParser = options8.parser ?? await getParser(file, options8)), {
    ignored,
    inferredParser: inferredParser ?? null
  };
}
async function getParser(file, options8) {
  let config;
  if (options8.resolveConfig !== !1 && (config = await resolveConfig(file, {
    // No need read `.editorconfig`
    editorconfig: !1
  })), config?.parser)
    return config.parser;
  let plugins = options8.plugins ?? config?.plugins ?? [];
  return plugins = (await Promise.all([load_builtin_plugins_default(), load_plugins_default(plugins)])).flat(), infer_parser_default({ plugins }, { physicalFile: file });
}
function skipInlineComment(text, startIndex) {
  if (startIndex === !1)
    return !1;
  if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "*") {
    for (let i = startIndex + 2; i < text.length; ++i)
      if (text.charAt(i) === "*" && text.charAt(i + 1) === "/")
        return i + 2;
  }
  return startIndex;
}
function skipTrailingComment(text, startIndex) {
  return startIndex === !1 ? !1 : text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "/" ? skipEverythingButNewLine(text, startIndex) : startIndex;
}
function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {
  let oldIdx = null, nextIdx = startIndex;
  for (; nextIdx !== oldIdx; )
    oldIdx = nextIdx, nextIdx = skipSpaces(text, nextIdx), nextIdx = skip_inline_comment_default(text, nextIdx), nextIdx = skip_trailing_comment_default(text, nextIdx), nextIdx = skip_newline_default(text, nextIdx);
  return nextIdx;
}
function isNextLineEmpty(text, startIndex) {
  let oldIdx = null, idx = startIndex;
  for (; idx !== oldIdx; )
    oldIdx = idx, idx = skipToLineEnd(text, idx), idx = skip_inline_comment_default(text, idx), idx = skipSpaces(text, idx);
  return idx = skip_trailing_comment_default(text, idx), idx = skip_newline_default(text, idx), idx !== !1 && has_newline_default(text, idx);
}
function getIndentSize(value, tabWidth) {
  let lastNewlineIndex = value.lastIndexOf(`
`);
  return lastNewlineIndex === -1 ? 0 : get_alignment_size_default(
    // All the leading whitespaces
    value.slice(lastNewlineIndex + 1).match(/^[\t ]*/u)[0],
    tabWidth
  );
}
function escapeStringRegexp(string) {
  if (typeof string != "string")
    throw new TypeError("Expected a string");
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function getMaxContinuousCount(text, searchString) {
  let results = text.matchAll(
    new RegExp(`(?:${escapeStringRegexp(searchString)})+`, "gu")
  );
  return results.reduce || (results = [...results]), results.reduce(
    (maxCount, [result]) => Math.max(maxCount, result.length),
    0
  ) / searchString.length;
}
function getNextNonSpaceNonCommentCharacter(text, startIndex) {
  let index = get_next_non_space_non_comment_character_index_default(text, startIndex);
  return index === !1 ? "" : text.charAt(index);
}
function getPreferredQuote(text, preferredQuoteOrPreferSingleQuote) {
  let { preferred, alternate } = preferredQuoteOrPreferSingleQuote === !0 || preferredQuoteOrPreferSingleQuote === SINGLE_QUOTE ? SINGLE_QUOTE_SETTINGS : DOUBLE_QUOTE_SETTINGS, { length } = text, preferredQuoteCount = 0, alternateQuoteCount = 0;
  for (let index = 0; index < length; index++) {
    let codePoint = text.charCodeAt(index);
    codePoint === preferred.codePoint ? preferredQuoteCount++ : codePoint === alternate.codePoint && alternateQuoteCount++;
  }
  return (preferredQuoteCount > alternateQuoteCount ? alternate : preferred).character;
}
function hasNewlineInRange(text, startIndex, endIndex) {
  for (let i = startIndex; i < endIndex; ++i)
    if (text.charAt(i) === `
`)
      return !0;
  return !1;
}
function hasSpaces(text, startIndex, options8 = {}) {
  return skipSpaces(
    text,
    options8.backwards ? startIndex - 1 : startIndex,
    options8
  ) !== startIndex;
}
function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
  return get_next_non_space_non_comment_character_index_default(text, locEnd(node));
}
function getNextNonSpaceNonCommentCharacterIndex2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? get_next_non_space_non_comment_character_index_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments)
  );
}
function legacyIsPreviousLineEmpty(text, node, locStart) {
  return is_previous_line_empty_default(text, locStart(node));
}
function isPreviousLineEmpty2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? is_previous_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsPreviousLineEmpty(...arguments)
  );
}
function legacyIsNextLineEmpty(text, node, locEnd) {
  return is_next_line_empty_default(text, locEnd(node));
}
function makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {
  let otherQuote = enclosingQuote === '"' ? "'" : '"', raw = method_replace_all_default2(
    /* OPTIONAL_OBJECT: false */
    0,
    rawText,
    /\\(.)|(["'])/gsu,
    (match, escaped, quote) => escaped === otherQuote ? escaped : quote === enclosingQuote ? "\\" + quote : quote || (unescapeUnnecessaryEscapes && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(escaped) ? escaped : "\\" + escaped)
  );
  return enclosingQuote + raw + enclosingQuote;
}
function isNextLineEmpty2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? is_next_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsNextLineEmpty(...arguments)
  );
}
function withPlugins(fn, optionsArgumentIndex = 1) {
  return async (...args) => {
    let options8 = args[optionsArgumentIndex] ?? {}, { plugins = [] } = options8;
    return args[optionsArgumentIndex] = {
      ...options8,
      plugins: (await Promise.all([
        load_builtin_plugins_default(),
        // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too
        load_plugins_default(plugins)
      ])).flat()
    }, fn(...args);
  };
}
async function format2(text, options8) {
  let { formatted } = await formatWithCursor2(text, {
    ...options8,
    cursorOffset: -1
  });
  return formatted;
}
async function check(text, options8) {
  return await format2(text, options8) === text;
}
async function clearCache3() {
  clearCache(), clearCache2();
}
var require2, __filename, __dirname, __create, __defProp2, __getOwnPropDesc, __getOwnPropNames, __getProtoOf, __hasOwnProp, __require, __commonJS, __export3, __copyProps, __toESM, require_array, require_errno, require_fs, require_path, require_is_extglob, require_is_glob, require_glob_parent, require_utils, require_stringify, require_is_number, require_to_regex_range, require_fill_range, require_compile, require_expand, require_constants, require_parse, require_braces, require_constants2, require_utils2, require_scan, require_parse2, require_picomatch, require_picomatch2, require_micromatch, require_pattern, require_merge2, require_stream, require_string, require_utils3, require_tasks, require_async, require_sync, require_fs2, require_settings, require_out, require_queue_microtask, require_run_parallel, require_constants3, require_fs3, require_utils4, require_common, require_async2, require_sync2, require_fs4, require_settings2, require_out2, require_reusify, require_queue, require_common2, require_reader, require_async3, require_async4, require_stream2, require_sync3, require_sync4, require_settings3, require_out3, require_reader2, require_stream3, require_async5, require_matcher, require_partial, require_deep, require_entry, require_error, require_entry2, require_provider, require_async6, require_stream4, require_sync5, require_sync6, require_settings4, require_out4, require_picocolors, require_debug, require_constants4, require_re, require_parse_options, require_identifiers, require_semver, require_compare, require_gte, require_pseudomap, require_map, require_yallist, require_lru_cache, require_sigmund, require_fnmatch, require_ini, require_package, require_src, require_js_tokens, require_readlines, require_ignore, index_exports, Diff, LineDiff, lineDiff, ArrayDiff, arrayDiff, import_fast_glob, array, characterCodeCache, import_picocolors5, apiDescriptor, import_picocolors, commonDeprecatedHandler, import_picocolors2, VALUE_NOT_EXIST, VALUE_UNCHANGED, INDENTATION, commonInvalidHandler, import_picocolors3, levenUnknownHandler, HANDLER_KEYS, Schema, AliasSchema, AnySchema, ArraySchema, BooleanSchema, ChoiceSchema, NumberSchema, IntegerSchema, StringSchema, defaultDescriptor, defaultUnknownHandler, defaultInvalidHandler, defaultDeprecatedHandler, Normalizer, errors_exports, ConfigError, UndefinedParserError, ArgExpansionBailout, create_mockable_default, mockable, mockable_default, import_micromatch, URL_STRING_PREFIX, isUrlInstance, isUrlString, isUrl, toPath, toAbsolutePath, partition_default, import_editorconfig, isFile, isDirectory, iterate_directory_up_default, Searcher, FileSearcher, DirectorySearcher, DIRECTORIES, searcher, isPositiveInteger, editorconfig_to_prettier_default, editorconfigCache, Space_Separator, ID_Start, ID_Continue, unicode, util, source, parseState, stack, pos, line2, column, token, key, root, parse2, lexState, buffer, doubleQuote, sign, c, lexStates, parseStates, dist_default, import_picocolors4, import_js_tokens, nonASCIIidentifierStartChars, nonASCIIidentifierChars, nonASCIIidentifierStart, nonASCIIidentifier, reservedWords, keywords, reservedWordsStrictSet, reservedWordsStrictBindSet, compose, defsOn, defsOff, sometimesKeywords, NEWLINE$1, BRACKET, tokenize2, NEWLINE, getOffsets, getCodePoint, JSONError, getErrorLocation, addCodePointToUnexpectedToken, TomlError, DATE_TIME_RE, TomlDate, INT_REGEX, FLOAT_REGEX, LEADING_ZERO, ESCAPE_REGEX, ESC_MAP, KEY_PART_RE, read_file_default, loadConfigFromPackageJson, parseYaml, loaders, loaders_default, CONFIG_FILE_NAMES, config_searcher_default, own, classRegExp, kTypes, codes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace, hasOwnProperty, ERR_INVALID_PACKAGE_CONFIG, cache, ERR_UNKNOWN_FILE_EXTENSION, hasOwnProperty2, extensionFormatMap, protocolHandlers, ERR_INVALID_ARG_VALUE, DEFAULT_CONDITIONS, DEFAULT_CONDITIONS_SET, RegExpPrototypeSymbolReplace, ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG2, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST, own2, invalidSegmentRegEx, deprecatedInvalidSegmentRegEx, invalidPackageNameRegEx, patternRegEx, encodedSeparatorRegEx, emittedPackageWarnings, doubleSlashRegEx, import_from_file_default, require_from_file_default, requireErrorCodesShouldBeIgnored, load_external_config_default, load_config_default, loadCache, searchCache, OPTIONAL_OBJECT2, createMethodShim2, stringReplaceAll2, replaceAll2, method_replace_all_default2, OPTION_CR2, OPTION_CRLF2, OPTION_LF, DEFAULT_OPTION, CHARACTER_CR2, CHARACTER_CRLF2, CHARACTER_LF2, DEFAULT_EOL2, regexps, END_OF_LINE_REGEXP, at2, method_at_default2, noop2, noop_default2, DOC_TYPE_CURSOR2, DOC_TYPE_INDENT2, DOC_TYPE_ALIGN2, DOC_TYPE_TRIM2, DOC_TYPE_GROUP2, DOC_TYPE_FILL2, DOC_TYPE_IF_BREAK2, DOC_TYPE_INDENT_IF_BREAK2, DOC_TYPE_LINE_SUFFIX2, DOC_TYPE_LINE_SUFFIX_BOUNDARY2, DOC_TYPE_LINE2, DOC_TYPE_LABEL2, DOC_TYPE_BREAK_PARENT2, emoji_regex_default2, narrow_emojis_evaluate_default2, notAsciiRegex2, narrowEmojisSet2, get_string_width_default2, get_alignment_size_default, AstPath, ast_path_default, is_object_default, skipWhitespace, skipSpaces, skipToLineEnd, skipEverythingButNewLine, isNewlineCharacter, skip_newline_default, has_newline_default, is_non_empty_array_default, get_sorted_child_nodes_default, childNodesCache, returnFalse, isAllEmptyAndNoLineBreak, is_previous_line_empty_default, breakParent2, hardline2, indent2, join3, line22, lineSuffix2, create_print_pre_check_function_default, core_options_evaluate_default, arrayToReversed, toReversed, method_to_reversed_default, import_n_readlines, get_interpreter_default, getFileBasename, getLanguageByInterpreter, infer_parser_default, hasDeprecationWarned, normalize_options_default, arrayFindLast, findLast, method_find_last_default, FRONT_MATTER_MARK, FRONT_MATTER_VISITOR_KEYS, is_front_matter_default, hardline22, markAsRoot2, SUPPORTED_EMBED_LANGUAGES, isEmbedFrontMatter, clean_default, print_default, nonTraversableKeys, defaultGetVisitorKeys, create_get_visitor_keys_function_default, normalizedPrinters, PRINTER_NORMALIZED_MARK, PRINTER_FRONT_MATTER_SUPPORT_FEATURES, PRINTER_FRONT_MATTER_SUPPORT_OFF, formatOptionsHiddenDefaults, normalize_format_options_default, parse_default, stripTrailingHardline2, print_ignored_default, cursor2, get_cursor_node_default, massage_ast_default, arrayFindLastIndex, findLastIndex, method_find_last_index_default, isJsonParser, jsonSourceElements, graphqlSourceElements, addAlignmentToDoc2, hardline3, printDocToStringWithoutNormalizeOptions, BOM, CURSOR, option_categories_exports, CATEGORY_CONFIG, CATEGORY_EDITOR, CATEGORY_FORMAT, CATEGORY_OTHER, CATEGORY_OUTPUT, CATEGORY_GLOBAL, CATEGORY_SPECIAL, languages_evaluate_default, common_options_evaluate_default, options, options_default, languages_evaluate_default2, options2, options_default2, languages_evaluate_default3, languages_evaluate_default4, CATEGORY_HTML, options3, options_default3, languages_evaluate_default5, CATEGORY_JAVASCRIPT, options4, options_default4, languages_evaluate_default6, languages_evaluate_default7, options5, options_default5, languages_evaluate_default8, options6, options_default6, estreePlugin, options7, languages, parsers, printers, builtin_plugins_proxy_default, load_builtin_plugins_default, import_from_directory_default, cache2, load_plugins_default, import_ignore, slash, object_omit_default, get_file_info_default, version_evaluate_default, public_exports2, skip_inline_comment_default, skip_trailing_comment_default, get_next_non_space_non_comment_character_index_default, is_next_line_empty_default, get_indent_size_default, get_max_continuous_count_default, get_next_non_space_non_comment_character_default, SINGLE_QUOTE, DOUBLE_QUOTE, SINGLE_QUOTE_DATA, DOUBLE_QUOTE_DATA, SINGLE_QUOTE_SETTINGS, DOUBLE_QUOTE_SETTINGS, get_preferred_quote_default, has_newline_in_range_default, has_spaces_default, formatWithCursor2, getSupportInfo2, inferParser2, sharedWithCli, debugApis, init_prettier = __esm({
  "../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/index.mjs"() {
    init_cjs_shims();
    init_doc();
    init_doc();
    init_doc();
    init_doc();
    init_doc();
    init_doc();
    require2 = __prettierCreateRequire(import.meta.url), __filename = __prettierFileUrlToPath(import.meta.url), __dirname = __prettierDirname(__filename), __create = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __require = /* @__PURE__ */ ((x) => typeof require2 < "u" ? require2 : typeof Proxy < "u" ? new Proxy(x, {
      get: (a, b) => (typeof require2 < "u" ? require2 : a)[b]
    }) : x)(function(x) {
      if (typeof require2 < "u") return require2.apply(this, arguments);
      throw Error('Dynamic require of "' + x + '" is not supported');
    }), __commonJS = (cb, mod) => function() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    }, __export3 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: !0 });
    }, __copyProps = (to, from, except, desc) => {
      if (from && typeof from == "object" || typeof from == "function")
        for (let key2 of __getOwnPropNames(from))
          !__hasOwnProp.call(to, key2) && key2 !== except && __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
      return to;
    }, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target,
      mod
    )), require_array = __commonJS({
      "node_modules/fast-glob/out/utils/array.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.splitWhen = exports.flatten = void 0;
        function flatten(items) {
          return items.reduce((collection, item) => [].concat(collection, item), []);
        }
        exports.flatten = flatten;
        function splitWhen(items, predicate) {
          let result = [[]], groupIndex = 0;
          for (let item of items)
            predicate(item) ? (groupIndex++, result[groupIndex] = []) : result[groupIndex].push(item);
          return result;
        }
        exports.splitWhen = splitWhen;
      }
    }), require_errno = __commonJS({
      "node_modules/fast-glob/out/utils/errno.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEnoentCodeError = void 0;
        function isEnoentCodeError(error) {
          return error.code === "ENOENT";
        }
        exports.isEnoentCodeError = isEnoentCodeError;
      }
    }), require_fs = __commonJS({
      "node_modules/fast-glob/out/utils/fs.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.createDirentFromStats = void 0;
        var DirentFromStats = class {
          constructor(name, stats) {
            this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
          }
        };
        function createDirentFromStats(name, stats) {
          return new DirentFromStats(name, stats);
        }
        exports.createDirentFromStats = createDirentFromStats;
      }
    }), require_path = __commonJS({
      "node_modules/fast-glob/out/utils/path.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
        var os = __require("os"), path15 = __require("path"), IS_WINDOWS_PLATFORM = os.platform() === "win32", LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2, POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, DOS_DEVICE_PATH_RE = /^\\\\([.?])/, WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
        function unixify(filepath) {
          return filepath.replace(/\\/g, "/");
        }
        exports.unixify = unixify;
        function makeAbsolute(cwd, filepath) {
          return path15.resolve(cwd, filepath);
        }
        exports.makeAbsolute = makeAbsolute;
        function removeLeadingDotSegment(entry) {
          if (entry.charAt(0) === ".") {
            let secondCharactery = entry.charAt(1);
            if (secondCharactery === "/" || secondCharactery === "\\")
              return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
          }
          return entry;
        }
        exports.removeLeadingDotSegment = removeLeadingDotSegment, exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
        function escapeWindowsPath(pattern) {
          return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
        }
        exports.escapeWindowsPath = escapeWindowsPath;
        function escapePosixPath(pattern) {
          return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
        }
        exports.escapePosixPath = escapePosixPath, exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
        function convertWindowsPathToPattern(filepath) {
          return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
        }
        exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
        function convertPosixPathToPattern(filepath) {
          return escapePosixPath(filepath);
        }
        exports.convertPosixPathToPattern = convertPosixPathToPattern;
      }
    }), require_is_extglob = __commonJS({
      "node_modules/is-extglob/index.js"(exports, module) {
        module.exports = function(str) {
          if (typeof str != "string" || str === "")
            return !1;
          for (var match; match = /(\\).|([@?!+*]\(.*\))/g.exec(str); ) {
            if (match[2]) return !0;
            str = str.slice(match.index + match[0].length);
          }
          return !1;
        };
      }
    }), require_is_glob = __commonJS({
      "node_modules/is-glob/index.js"(exports, module) {
        var isExtglob = require_is_extglob(), chars = { "{": "}", "(": ")", "[": "]" }, strictCheck = function(str) {
          if (str[0] === "!")
            return !0;
          for (var index = 0, pipeIndex = -2, closeSquareIndex = -2, closeCurlyIndex = -2, closeParenIndex = -2, backSlashIndex = -2; index < str.length; ) {
            if (str[index] === "*" || str[index + 1] === "?" && /[\].+)]/.test(str[index]) || closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]" && (closeSquareIndex < index && (closeSquareIndex = str.indexOf("]", index)), closeSquareIndex > index && (backSlashIndex === -1 || backSlashIndex > closeSquareIndex || (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeSquareIndex))) || closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}" && (closeCurlyIndex = str.indexOf("}", index), closeCurlyIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeCurlyIndex)) || closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")" && (closeParenIndex = str.indexOf(")", index), closeParenIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeParenIndex)) || pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|" && (pipeIndex < index && (pipeIndex = str.indexOf("|", index)), pipeIndex !== -1 && str[pipeIndex + 1] !== ")" && (closeParenIndex = str.indexOf(")", pipeIndex), closeParenIndex > pipeIndex && (backSlashIndex = str.indexOf("\\", pipeIndex), backSlashIndex === -1 || backSlashIndex > closeParenIndex))))
              return !0;
            if (str[index] === "\\") {
              var open = str[index + 1];
              index += 2;
              var close = chars[open];
              if (close) {
                var n = str.indexOf(close, index);
                n !== -1 && (index = n + 1);
              }
              if (str[index] === "!")
                return !0;
            } else
              index++;
          }
          return !1;
        }, relaxedCheck = function(str) {
          if (str[0] === "!")
            return !0;
          for (var index = 0; index < str.length; ) {
            if (/[*?{}()[\]]/.test(str[index]))
              return !0;
            if (str[index] === "\\") {
              var open = str[index + 1];
              index += 2;
              var close = chars[open];
              if (close) {
                var n = str.indexOf(close, index);
                n !== -1 && (index = n + 1);
              }
              if (str[index] === "!")
                return !0;
            } else
              index++;
          }
          return !1;
        };
        module.exports = function(str, options8) {
          if (typeof str != "string" || str === "")
            return !1;
          if (isExtglob(str))
            return !0;
          var check2 = strictCheck;
          return options8 && options8.strict === !1 && (check2 = relaxedCheck), check2(str);
        };
      }
    }), require_glob_parent = __commonJS({
      "node_modules/fast-glob/node_modules/glob-parent/index.js"(exports, module) {
        "use strict";
        var isGlob = require_is_glob(), pathPosixDirname = __require("path").posix.dirname, isWin32 = __require("os").platform() === "win32", slash2 = "/", backslash = /\\/g, enclosure = /[\{\[].*[\}\]]$/, globby = /(^|[^\\])([\{\[]|\([^\)]+$)/, escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
        module.exports = function(str, opts) {
          var options8 = Object.assign({ flipBackslashes: !0 }, opts);
          options8.flipBackslashes && isWin32 && str.indexOf(slash2) < 0 && (str = str.replace(backslash, slash2)), enclosure.test(str) && (str += slash2), str += "a";
          do
            str = pathPosixDirname(str);
          while (isGlob(str) || globby.test(str));
          return str.replace(escaped, "$1");
        };
      }
    }), require_utils = __commonJS({
      "node_modules/braces/lib/utils.js"(exports) {
        "use strict";
        exports.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1, exports.find = (node, type) => node.nodes.find((node2) => node2.type === type), exports.exceedsLimit = (min, max, step = 1, limit) => limit === !1 || !exports.isInteger(min) || !exports.isInteger(max) ? !1 : (Number(max) - Number(min)) / Number(step) >= limit, exports.escapeNode = (block, n = 0, type) => {
          let node = block.nodes[n];
          node && (type && node.type === type || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
        }, exports.encloseBrace = (node) => node.type !== "brace" ? !1 : node.commas >> 0 + node.ranges >> 0 === 0 ? (node.invalid = !0, !0) : !1, exports.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : block.commas >> 0 + block.ranges >> 0 === 0 || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1, exports.isOpenOrClose = (node) => node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0, exports.reduce = (nodes) => nodes.reduce((acc, node) => (node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc), []), exports.flatten = (...args) => {
          let result = [], flat = (arr) => {
            for (let i = 0; i < arr.length; i++) {
              let ele = arr[i];
              if (Array.isArray(ele)) {
                flat(ele);
                continue;
              }
              ele !== void 0 && result.push(ele);
            }
            return result;
          };
          return flat(args), result;
        };
      }
    }), require_stringify = __commonJS({
      "node_modules/braces/lib/stringify.js"(exports, module) {
        "use strict";
        var utils2 = require_utils();
        module.exports = (ast, options8 = {}) => {
          let stringify2 = (node, parent = {}) => {
            let invalidBlock = options8.escapeInvalid && utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options8.escapeInvalid === !0, output = "";
            if (node.value)
              return (invalidBlock || invalidNode) && utils2.isOpenOrClose(node) ? "\\" + node.value : node.value;
            if (node.value)
              return node.value;
            if (node.nodes)
              for (let child of node.nodes)
                output += stringify2(child);
            return output;
          };
          return stringify2(ast);
        };
      }
    }), require_is_number = __commonJS({
      "node_modules/is-number/index.js"(exports, module) {
        "use strict";
        module.exports = function(num) {
          return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
        };
      }
    }), require_to_regex_range = __commonJS({
      "node_modules/to-regex-range/index.js"(exports, module) {
        "use strict";
        var isNumber = require_is_number(), toRegexRange = (min, max, options8) => {
          if (isNumber(min) === !1)
            throw new TypeError("toRegexRange: expected the first argument to be a number");
          if (max === void 0 || min === max)
            return String(min);
          if (isNumber(max) === !1)
            throw new TypeError("toRegexRange: expected the second argument to be a number.");
          let opts = { relaxZeros: !0, ...options8 };
          typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
          let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap = String(opts.wrap), cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
          if (toRegexRange.cache.hasOwnProperty(cacheKey))
            return toRegexRange.cache[cacheKey].result;
          let a = Math.min(min, max), b = Math.max(min, max);
          if (Math.abs(a - b) === 1) {
            let result = min + "|" + max;
            return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
          }
          let isPadded = hasPadding(min) || hasPadding(max), state = { min, max, a, b }, positives = [], negatives = [];
          if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
            let newMin = b < 0 ? Math.abs(b) : 1;
            negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
          }
          return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives, opts), opts.capture === !0 ? state.result = `(${state.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = `(?:${state.result})`), toRegexRange.cache[cacheKey] = state, state.result;
        };
        function collatePatterns(neg, pos2, options8) {
          let onlyNegative = filterPatterns(neg, pos2, "-", !1, options8) || [], onlyPositive = filterPatterns(pos2, neg, "", !1, options8) || [], intersected = filterPatterns(neg, pos2, "-?", !0, options8) || [];
          return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
        }
        function splitToRanges(min, max) {
          let nines = 1, zeros = 1, stop = countNines(min, nines), stops = /* @__PURE__ */ new Set([max]);
          for (; min <= stop && stop <= max; )
            stops.add(stop), nines += 1, stop = countNines(min, nines);
          for (stop = countZeros(max + 1, zeros) - 1; min < stop && stop <= max; )
            stops.add(stop), zeros += 1, stop = countZeros(max + 1, zeros) - 1;
          return stops = [...stops], stops.sort(compare), stops;
        }
        function rangeToPattern(start, stop, options8) {
          if (start === stop)
            return { pattern: start, count: [], digits: 0 };
          let zipped = zip(start, stop), digits = zipped.length, pattern = "", count = 0;
          for (let i = 0; i < digits; i++) {
            let [startDigit, stopDigit] = zipped[i];
            startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit, options8) : count++;
          }
          return count && (pattern += options8.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count], digits };
        }
        function splitToPatterns(min, max, tok, options8) {
          let ranges = splitToRanges(min, max), tokens = [], start = min, prev;
          for (let i = 0; i < ranges.length; i++) {
            let max2 = ranges[i], obj = rangeToPattern(String(start), String(max2), options8), zeros = "";
            if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
              prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max2 + 1;
              continue;
            }
            tok.isPadded && (zeros = padZeros(max2, tok, options8)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max2 + 1, prev = obj;
          }
          return tokens;
        }
        function filterPatterns(arr, comparison, prefix, intersection, options8) {
          let result = [];
          for (let ele of arr) {
            let { string } = ele;
            !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
          }
          return result;
        }
        function zip(a, b) {
          let arr = [];
          for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
          return arr;
        }
        function compare(a, b) {
          return a > b ? 1 : b > a ? -1 : 0;
        }
        function contains(arr, key2, val) {
          return arr.some((ele) => ele[key2] === val);
        }
        function countNines(min, len) {
          return Number(String(min).slice(0, -len) + "9".repeat(len));
        }
        function countZeros(integer, zeros) {
          return integer - integer % Math.pow(10, zeros);
        }
        function toQuantifier(digits) {
          let [start = 0, stop = ""] = digits;
          return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
        }
        function toCharacterClass(a, b, options8) {
          return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
        }
        function hasPadding(str) {
          return /^-?(0+)\d/.test(str);
        }
        function padZeros(value, tok, options8) {
          if (!tok.isPadded)
            return value;
          let diff = Math.abs(tok.maxLen - String(value).length), relax = options8.relaxZeros !== !1;
          switch (diff) {
            case 0:
              return "";
            case 1:
              return relax ? "0?" : "0";
            case 2:
              return relax ? "0{0,2}" : "00";
            default:
              return relax ? `0{0,${diff}}` : `0{${diff}}`;
          }
        }
        toRegexRange.cache = {}, toRegexRange.clearCache = () => toRegexRange.cache = {}, module.exports = toRegexRange;
      }
    }), require_fill_range = __commonJS({
      "node_modules/fill-range/index.js"(exports, module) {
        "use strict";
        var util2 = __require("util"), toRegexRange = require_to_regex_range(), isObject2 = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber = (num) => Number.isInteger(+num), zeros = (input) => {
          let value = `${input}`, index = -1;
          if (value[0] === "-" && (value = value.slice(1)), value === "0") return !1;
          for (; value[++index] === "0"; ) ;
          return index > 0;
        }, stringify2 = (start, end, options8) => typeof start == "string" || typeof end == "string" ? !0 : options8.stringify === !0, pad = (input, maxLength, toNumber) => {
          if (maxLength > 0) {
            let dash = input[0] === "-" ? "-" : "";
            dash && (input = input.slice(1)), input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
          }
          return toNumber === !1 ? String(input) : input;
        }, toMaxLen = (input, maxLength) => {
          let negative = input[0] === "-" ? "-" : "";
          for (negative && (input = input.slice(1), maxLength--); input.length < maxLength; ) input = "0" + input;
          return negative ? "-" + input : input;
        }, toSequence = (parts, options8, maxLen) => {
          parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
          let prefix = options8.capture ? "" : "?:", positives = "", negatives = "", result;
          return parts.positives.length && (positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options8.wrap ? `(${prefix}${result})` : result;
        }, toRange = (a, b, isNumbers, options8) => {
          if (isNumbers)
            return toRegexRange(a, b, { wrap: !1, ...options8 });
          let start = String.fromCharCode(a);
          if (a === b) return start;
          let stop = String.fromCharCode(b);
          return `[${start}-${stop}]`;
        }, toRegex = (start, end, options8) => {
          if (Array.isArray(start)) {
            let wrap = options8.wrap === !0, prefix = options8.capture ? "" : "?:";
            return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
          }
          return toRegexRange(start, end, options8);
        }, rangeError = (...args) => new RangeError("Invalid range arguments: " + util2.inspect(...args)), invalidRange = (start, end, options8) => {
          if (options8.strictRanges === !0) throw rangeError([start, end]);
          return [];
        }, invalidStep = (step, options8) => {
          if (options8.strictRanges === !0)
            throw new TypeError(`Expected step "${step}" to be a number`);
          return [];
        }, fillNumbers = (start, end, step = 1, options8 = {}) => {
          let a = Number(start), b = Number(end);
          if (!Number.isInteger(a) || !Number.isInteger(b)) {
            if (options8.strictRanges === !0) throw rangeError([start, end]);
            return [];
          }
          a === 0 && (a = 0), b === 0 && (b = 0);
          let descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
          step = Math.max(Math.abs(step), 1);
          let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify2(start, end, options8) === !1, format3 = options8.transform || transform(toNumber);
          if (options8.toRegex && step === 1)
            return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options8);
          let parts = { negatives: [], positives: [] }, push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range = [], index = 0;
          for (; descending ? a >= b : a <= b; )
            options8.toRegex === !0 && step > 1 ? push2(a) : range.push(pad(format3(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
          return options8.toRegex === !0 ? step > 1 ? toSequence(parts, options8, maxLen) : toRegex(range, null, { wrap: !1, ...options8 }) : range;
        }, fillLetters = (start, end, step = 1, options8 = {}) => {
          if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1)
            return invalidRange(start, end, options8);
          let format3 = options8.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end}`.charCodeAt(0), descending = a > b, min = Math.min(a, b), max = Math.max(a, b);
          if (options8.toRegex && step === 1)
            return toRange(min, max, !1, options8);
          let range = [], index = 0;
          for (; descending ? a >= b : a <= b; )
            range.push(format3(a, index)), a = descending ? a - step : a + step, index++;
          return options8.toRegex === !0 ? toRegex(range, null, { wrap: !1, options: options8 }) : range;
        }, fill2 = (start, end, step, options8 = {}) => {
          if (end == null && isValidValue(start))
            return [start];
          if (!isValidValue(start) || !isValidValue(end))
            return invalidRange(start, end, options8);
          if (typeof step == "function")
            return fill2(start, end, 1, { transform: step });
          if (isObject2(step))
            return fill2(start, end, 0, step);
          let opts = { ...options8 };
          return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber(step) ? isNumber(start) && isNumber(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject2(step) ? invalidStep(step, opts) : fill2(start, end, 1, step);
        };
        module.exports = fill2;
      }
    }), require_compile = __commonJS({
      "node_modules/braces/lib/compile.js"(exports, module) {
        "use strict";
        var fill2 = require_fill_range(), utils2 = require_utils(), compile = (ast, options8 = {}) => {
          let walk = (node, parent = {}) => {
            let invalidBlock = utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options8.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options8.escapeInvalid === !0 ? "\\" : "", output = "";
            if (node.isOpen === !0)
              return prefix + node.value;
            if (node.isClose === !0)
              return console.log("node.isClose", prefix, node.value), prefix + node.value;
            if (node.type === "open")
              return invalid ? prefix + node.value : "(";
            if (node.type === "close")
              return invalid ? prefix + node.value : ")";
            if (node.type === "comma")
              return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
            if (node.value)
              return node.value;
            if (node.nodes && node.ranges > 0) {
              let args = utils2.reduce(node.nodes), range = fill2(...args, { ...options8, wrap: !1, toRegex: !0, strictZeros: !0 });
              if (range.length !== 0)
                return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
            if (node.nodes)
              for (let child of node.nodes)
                output += walk(child, node);
            return output;
          };
          return walk(ast);
        };
        module.exports = compile;
      }
    }), require_expand = __commonJS({
      "node_modules/braces/lib/expand.js"(exports, module) {
        "use strict";
        var fill2 = require_fill_range(), stringify2 = require_stringify(), utils2 = require_utils(), append = (queue = "", stash = "", enclose = !1) => {
          let result = [];
          if (queue = [].concat(queue), stash = [].concat(stash), !stash.length) return queue;
          if (!queue.length)
            return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
          for (let item of queue)
            if (Array.isArray(item))
              for (let value of item)
                result.push(append(value, stash, enclose));
            else
              for (let ele of stash)
                enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          return utils2.flatten(result);
        }, expand = (ast, options8 = {}) => {
          let rangeLimit = options8.rangeLimit === void 0 ? 1e3 : options8.rangeLimit, walk = (node, parent = {}) => {
            node.queue = [];
            let p = parent, q = parent.queue;
            for (; p.type !== "brace" && p.type !== "root" && p.parent; )
              p = p.parent, q = p.queue;
            if (node.invalid || node.dollar) {
              q.push(append(q.pop(), stringify2(node, options8)));
              return;
            }
            if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
              q.push(append(q.pop(), ["{}"]));
              return;
            }
            if (node.nodes && node.ranges > 0) {
              let args = utils2.reduce(node.nodes);
              if (utils2.exceedsLimit(...args, options8.step, rangeLimit))
                throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
              let range = fill2(...args, options8);
              range.length === 0 && (range = stringify2(node, options8)), q.push(append(q.pop(), range)), node.nodes = [];
              return;
            }
            let enclose = utils2.encloseBrace(node), queue = node.queue, block = node;
            for (; block.type !== "brace" && block.type !== "root" && block.parent; )
              block = block.parent, queue = block.queue;
            for (let i = 0; i < node.nodes.length; i++) {
              let child = node.nodes[i];
              if (child.type === "comma" && node.type === "brace") {
                i === 1 && queue.push(""), queue.push("");
                continue;
              }
              if (child.type === "close") {
                q.push(append(q.pop(), queue, enclose));
                continue;
              }
              if (child.value && child.type !== "open") {
                queue.push(append(queue.pop(), child.value));
                continue;
              }
              child.nodes && walk(child, node);
            }
            return queue;
          };
          return utils2.flatten(walk(ast));
        };
        module.exports = expand;
      }
    }), require_constants = __commonJS({
      "node_modules/braces/lib/constants.js"(exports, module) {
        "use strict";
        module.exports = {
          MAX_LENGTH: 1e4,
          // Digits
          CHAR_0: "0",
          /* 0 */
          CHAR_9: "9",
          /* 9 */
          // Alphabet chars.
          CHAR_UPPERCASE_A: "A",
          /* A */
          CHAR_LOWERCASE_A: "a",
          /* a */
          CHAR_UPPERCASE_Z: "Z",
          /* Z */
          CHAR_LOWERCASE_Z: "z",
          /* z */
          CHAR_LEFT_PARENTHESES: "(",
          /* ( */
          CHAR_RIGHT_PARENTHESES: ")",
          /* ) */
          CHAR_ASTERISK: "*",
          /* * */
          // Non-alphabetic chars.
          CHAR_AMPERSAND: "&",
          /* & */
          CHAR_AT: "@",
          /* @ */
          CHAR_BACKSLASH: "\\",
          /* \ */
          CHAR_BACKTICK: "`",
          /* ` */
          CHAR_CARRIAGE_RETURN: "\r",
          /* \r */
          CHAR_CIRCUMFLEX_ACCENT: "^",
          /* ^ */
          CHAR_COLON: ":",
          /* : */
          CHAR_COMMA: ",",
          /* , */
          CHAR_DOLLAR: "$",
          /* . */
          CHAR_DOT: ".",
          /* . */
          CHAR_DOUBLE_QUOTE: '"',
          /* " */
          CHAR_EQUAL: "=",
          /* = */
          CHAR_EXCLAMATION_MARK: "!",
          /* ! */
          CHAR_FORM_FEED: "\f",
          /* \f */
          CHAR_FORWARD_SLASH: "/",
          /* / */
          CHAR_HASH: "#",
          /* # */
          CHAR_HYPHEN_MINUS: "-",
          /* - */
          CHAR_LEFT_ANGLE_BRACKET: "<",
          /* < */
          CHAR_LEFT_CURLY_BRACE: "{",
          /* { */
          CHAR_LEFT_SQUARE_BRACKET: "[",
          /* [ */
          CHAR_LINE_FEED: `
`,
          /* \n */
          CHAR_NO_BREAK_SPACE: "\xA0",
          /* \u00A0 */
          CHAR_PERCENT: "%",
          /* % */
          CHAR_PLUS: "+",
          /* + */
          CHAR_QUESTION_MARK: "?",
          /* ? */
          CHAR_RIGHT_ANGLE_BRACKET: ">",
          /* > */
          CHAR_RIGHT_CURLY_BRACE: "}",
          /* } */
          CHAR_RIGHT_SQUARE_BRACKET: "]",
          /* ] */
          CHAR_SEMICOLON: ";",
          /* ; */
          CHAR_SINGLE_QUOTE: "'",
          /* ' */
          CHAR_SPACE: " ",
          /*   */
          CHAR_TAB: "	",
          /* \t */
          CHAR_UNDERSCORE: "_",
          /* _ */
          CHAR_VERTICAL_LINE: "|",
          /* | */
          CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
          /* \uFEFF */
        };
      }
    }), require_parse = __commonJS({
      "node_modules/braces/lib/parse.js"(exports, module) {
        "use strict";
        var stringify2 = require_stringify(), {
          MAX_LENGTH,
          CHAR_BACKSLASH,
          /* \ */
          CHAR_BACKTICK,
          /* ` */
          CHAR_COMMA,
          /* , */
          CHAR_DOT,
          /* . */
          CHAR_LEFT_PARENTHESES,
          /* ( */
          CHAR_RIGHT_PARENTHESES,
          /* ) */
          CHAR_LEFT_CURLY_BRACE,
          /* { */
          CHAR_RIGHT_CURLY_BRACE,
          /* } */
          CHAR_LEFT_SQUARE_BRACKET,
          /* [ */
          CHAR_RIGHT_SQUARE_BRACKET,
          /* ] */
          CHAR_DOUBLE_QUOTE,
          /* " */
          CHAR_SINGLE_QUOTE,
          /* ' */
          CHAR_NO_BREAK_SPACE,
          CHAR_ZERO_WIDTH_NOBREAK_SPACE
        } = require_constants(), parse7 = (input, options8 = {}) => {
          if (typeof input != "string")
            throw new TypeError("Expected a string");
          let opts = options8 || {}, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
          if (input.length > max)
            throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
          let ast = { type: "root", input, nodes: [] }, stack2 = [ast], block = ast, prev = ast, brackets = 0, length = input.length, index = 0, depth = 0, value, advance = () => input[index++], push2 = (node) => {
            if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
              prev.value += node.value;
              return;
            }
            return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
          };
          for (push2({ type: "bos" }); index < length; )
            if (block = stack2[stack2.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
              if (value === CHAR_BACKSLASH) {
                push2({ type: "text", value: (options8.keepEscaping ? value : "") + advance() });
                continue;
              }
              if (value === CHAR_RIGHT_SQUARE_BRACKET) {
                push2({ type: "text", value: "\\" + value });
                continue;
              }
              if (value === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                let next;
                for (; index < length && (next = advance()); ) {
                  if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
                    brackets++;
                    continue;
                  }
                  if (next === CHAR_BACKSLASH) {
                    value += advance();
                    continue;
                  }
                  if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
                    break;
                }
                push2({ type: "text", value });
                continue;
              }
              if (value === CHAR_LEFT_PARENTHESES) {
                block = push2({ type: "paren", nodes: [] }), stack2.push(block), push2({ type: "text", value });
                continue;
              }
              if (value === CHAR_RIGHT_PARENTHESES) {
                if (block.type !== "paren") {
                  push2({ type: "text", value });
                  continue;
                }
                block = stack2.pop(), push2({ type: "text", value }), block = stack2[stack2.length - 1];
                continue;
              }
              if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
                let open = value, next;
                for (options8.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
                  if (next === CHAR_BACKSLASH) {
                    value += next + advance();
                    continue;
                  }
                  if (next === open) {
                    options8.keepQuotes === !0 && (value += next);
                    break;
                  }
                  value += next;
                }
                push2({ type: "text", value });
                continue;
              }
              if (value === CHAR_LEFT_CURLY_BRACE) {
                depth++;
                let brace = {
                  type: "brace",
                  open: !0,
                  close: !1,
                  dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
                  depth,
                  commas: 0,
                  ranges: 0,
                  nodes: []
                };
                block = push2(brace), stack2.push(block), push2({ type: "open", value });
                continue;
              }
              if (value === CHAR_RIGHT_CURLY_BRACE) {
                if (block.type !== "brace") {
                  push2({ type: "text", value });
                  continue;
                }
                let type = "close";
                block = stack2.pop(), block.close = !0, push2({ type, value }), depth--, block = stack2[stack2.length - 1];
                continue;
              }
              if (value === CHAR_COMMA && depth > 0) {
                if (block.ranges > 0) {
                  block.ranges = 0;
                  let open = block.nodes.shift();
                  block.nodes = [open, { type: "text", value: stringify2(block) }];
                }
                push2({ type: "comma", value }), block.commas++;
                continue;
              }
              if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
                let siblings = block.nodes;
                if (depth === 0 || siblings.length === 0) {
                  push2({ type: "text", value });
                  continue;
                }
                if (prev.type === "dot") {
                  if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
                    block.invalid = !0, block.ranges = 0, prev.type = "text";
                    continue;
                  }
                  block.ranges++, block.args = [];
                  continue;
                }
                if (prev.type === "range") {
                  siblings.pop();
                  let before = siblings[siblings.length - 1];
                  before.value += prev.value + value, prev = before, block.ranges--;
                  continue;
                }
                push2({ type: "dot", value });
                continue;
              }
              push2({ type: "text", value });
            }
          do
            if (block = stack2.pop(), block.type !== "root") {
              block.nodes.forEach((node) => {
                node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
              });
              let parent = stack2[stack2.length - 1], index2 = parent.nodes.indexOf(block);
              parent.nodes.splice(index2, 1, ...block.nodes);
            }
          while (stack2.length > 0);
          return push2({ type: "eos" }), ast;
        };
        module.exports = parse7;
      }
    }), require_braces = __commonJS({
      "node_modules/braces/index.js"(exports, module) {
        "use strict";
        var stringify2 = require_stringify(), compile = require_compile(), expand = require_expand(), parse7 = require_parse(), braces = (input, options8 = {}) => {
          let output = [];
          if (Array.isArray(input))
            for (let pattern of input) {
              let result = braces.create(pattern, options8);
              Array.isArray(result) ? output.push(...result) : output.push(result);
            }
          else
            output = [].concat(braces.create(input, options8));
          return options8 && options8.expand === !0 && options8.nodupes === !0 && (output = [...new Set(output)]), output;
        };
        braces.parse = (input, options8 = {}) => parse7(input, options8), braces.stringify = (input, options8 = {}) => stringify2(typeof input == "string" ? braces.parse(input, options8) : input, options8), braces.compile = (input, options8 = {}) => (typeof input == "string" && (input = braces.parse(input, options8)), compile(input, options8)), braces.expand = (input, options8 = {}) => {
          typeof input == "string" && (input = braces.parse(input, options8));
          let result = expand(input, options8);
          return options8.noempty === !0 && (result = result.filter(Boolean)), options8.nodupes === !0 && (result = [...new Set(result)]), result;
        }, braces.create = (input, options8 = {}) => input === "" || input.length < 3 ? [input] : options8.expand !== !0 ? braces.compile(input, options8) : braces.expand(input, options8), module.exports = braces;
      }
    }), require_constants2 = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/lib/constants.js"(exports, module) {
        "use strict";
        var path15 = __require("path"), WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
          DOT_LITERAL,
          PLUS_LITERAL,
          QMARK_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          QMARK,
          END_ANCHOR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        }, WINDOWS_CHARS = {
          ...POSIX_CHARS,
          SLASH_LITERAL: `[${WIN_SLASH}]`,
          QMARK: WIN_NO_SLASH,
          STAR: `${WIN_NO_SLASH}*?`,
          DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
          NO_DOT: `(?!${DOT_LITERAL})`,
          NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
          NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
          NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
          QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
          START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
          END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
        }, POSIX_REGEX_SOURCE = {
          alnum: "a-zA-Z0-9",
          alpha: "a-zA-Z",
          ascii: "\\x00-\\x7F",
          blank: " \\t",
          cntrl: "\\x00-\\x1F\\x7F",
          digit: "0-9",
          graph: "\\x21-\\x7E",
          lower: "a-z",
          print: "\\x20-\\x7E ",
          punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
          space: " \\t\\r\\n\\v\\f",
          upper: "A-Z",
          word: "A-Za-z0-9_",
          xdigit: "A-Fa-f0-9"
        };
        module.exports = {
          MAX_LENGTH: 1024 * 64,
          POSIX_REGEX_SOURCE,
          // regular expressions
          REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
          REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
          REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
          REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
          REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
          REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
          // Replace globs with equivalent patterns to reduce parsing time.
          REPLACEMENTS: {
            "***": "*",
            "**/**": "**",
            "**/**/**": "**"
          },
          // Digits
          CHAR_0: 48,
          /* 0 */
          CHAR_9: 57,
          /* 9 */
          // Alphabet chars.
          CHAR_UPPERCASE_A: 65,
          /* A */
          CHAR_LOWERCASE_A: 97,
          /* a */
          CHAR_UPPERCASE_Z: 90,
          /* Z */
          CHAR_LOWERCASE_Z: 122,
          /* z */
          CHAR_LEFT_PARENTHESES: 40,
          /* ( */
          CHAR_RIGHT_PARENTHESES: 41,
          /* ) */
          CHAR_ASTERISK: 42,
          /* * */
          // Non-alphabetic chars.
          CHAR_AMPERSAND: 38,
          /* & */
          CHAR_AT: 64,
          /* @ */
          CHAR_BACKWARD_SLASH: 92,
          /* \ */
          CHAR_CARRIAGE_RETURN: 13,
          /* \r */
          CHAR_CIRCUMFLEX_ACCENT: 94,
          /* ^ */
          CHAR_COLON: 58,
          /* : */
          CHAR_COMMA: 44,
          /* , */
          CHAR_DOT: 46,
          /* . */
          CHAR_DOUBLE_QUOTE: 34,
          /* " */
          CHAR_EQUAL: 61,
          /* = */
          CHAR_EXCLAMATION_MARK: 33,
          /* ! */
          CHAR_FORM_FEED: 12,
          /* \f */
          CHAR_FORWARD_SLASH: 47,
          /* / */
          CHAR_GRAVE_ACCENT: 96,
          /* ` */
          CHAR_HASH: 35,
          /* # */
          CHAR_HYPHEN_MINUS: 45,
          /* - */
          CHAR_LEFT_ANGLE_BRACKET: 60,
          /* < */
          CHAR_LEFT_CURLY_BRACE: 123,
          /* { */
          CHAR_LEFT_SQUARE_BRACKET: 91,
          /* [ */
          CHAR_LINE_FEED: 10,
          /* \n */
          CHAR_NO_BREAK_SPACE: 160,
          /* \u00A0 */
          CHAR_PERCENT: 37,
          /* % */
          CHAR_PLUS: 43,
          /* + */
          CHAR_QUESTION_MARK: 63,
          /* ? */
          CHAR_RIGHT_ANGLE_BRACKET: 62,
          /* > */
          CHAR_RIGHT_CURLY_BRACE: 125,
          /* } */
          CHAR_RIGHT_SQUARE_BRACKET: 93,
          /* ] */
          CHAR_SEMICOLON: 59,
          /* ; */
          CHAR_SINGLE_QUOTE: 39,
          /* ' */
          CHAR_SPACE: 32,
          /*   */
          CHAR_TAB: 9,
          /* \t */
          CHAR_UNDERSCORE: 95,
          /* _ */
          CHAR_VERTICAL_LINE: 124,
          /* | */
          CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
          /* \uFEFF */
          SEP: path15.sep,
          /**
           * Create EXTGLOB_CHARS
           */
          extglobChars(chars) {
            return {
              "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
              "?": { type: "qmark", open: "(?:", close: ")?" },
              "+": { type: "plus", open: "(?:", close: ")+" },
              "*": { type: "star", open: "(?:", close: ")*" },
              "@": { type: "at", open: "(?:", close: ")" }
            };
          },
          /**
           * Create GLOB_CHARS
           */
          globChars(win32) {
            return win32 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
          }
        };
      }
    }), require_utils2 = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/lib/utils.js"(exports) {
        "use strict";
        var path15 = __require("path"), win32 = process.platform === "win32", {
          REGEX_BACKSLASH,
          REGEX_REMOVE_BACKSLASH,
          REGEX_SPECIAL_CHARS,
          REGEX_SPECIAL_CHARS_GLOBAL
        } = require_constants2();
        exports.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str), exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str), exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1"), exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/"), exports.removeBackslashes = (str) => str.replace(REGEX_REMOVE_BACKSLASH, (match) => match === "\\" ? "" : match), exports.supportsLookbehinds = () => {
          let segs = process.version.slice(1).split(".").map(Number);
          return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
        }, exports.isWindows = (options8) => options8 && typeof options8.windows == "boolean" ? options8.windows : win32 === !0 || path15.sep === "\\", exports.escapeLast = (input, char, lastIdx) => {
          let idx = input.lastIndexOf(char, lastIdx);
          return idx === -1 ? input : input[idx - 1] === "\\" ? exports.escapeLast(input, char, idx - 1) : `${input.slice(0, idx)}\\${input.slice(idx)}`;
        }, exports.removePrefix = (input, state = {}) => {
          let output = input;
          return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
        }, exports.wrapOutput = (input, state = {}, options8 = {}) => {
          let prepend = options8.contains ? "" : "^", append = options8.contains ? "" : "$", output = `${prepend}(?:${input})${append}`;
          return state.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
        };
      }
    }), require_scan = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/lib/scan.js"(exports, module) {
        "use strict";
        var utils2 = require_utils2(), {
          CHAR_ASTERISK,
          /* * */
          CHAR_AT,
          /* @ */
          CHAR_BACKWARD_SLASH,
          /* \ */
          CHAR_COMMA,
          /* , */
          CHAR_DOT,
          /* . */
          CHAR_EXCLAMATION_MARK,
          /* ! */
          CHAR_FORWARD_SLASH,
          /* / */
          CHAR_LEFT_CURLY_BRACE,
          /* { */
          CHAR_LEFT_PARENTHESES,
          /* ( */
          CHAR_LEFT_SQUARE_BRACKET,
          /* [ */
          CHAR_PLUS,
          /* + */
          CHAR_QUESTION_MARK,
          /* ? */
          CHAR_RIGHT_CURLY_BRACE,
          /* } */
          CHAR_RIGHT_PARENTHESES,
          /* ) */
          CHAR_RIGHT_SQUARE_BRACKET
          /* ] */
        } = require_constants2(), isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token2) => {
          token2.isPrefix !== !0 && (token2.depth = token2.isGlobstar ? 1 / 0 : 1);
        }, scan = (input, options8) => {
          let opts = options8 || {}, length = input.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [], str = input, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token2 = { value: "", depth: 0, isGlob: !1 }, eos = () => index >= length, peek2 = () => str.charCodeAt(index + 1), advance = () => (prev = code, str.charCodeAt(++index));
          for (; index < length; ) {
            code = advance();
            let next;
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
              continue;
            }
            if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
              for (braces++; eos() !== !0 && (code = advance()); ) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = !0, advance();
                  continue;
                }
                if (code === CHAR_LEFT_CURLY_BRACE) {
                  braces++;
                  continue;
                }
                if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                  if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                    continue;
                  break;
                }
                if (braceEscaped !== !0 && code === CHAR_COMMA) {
                  if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                    continue;
                  break;
                }
                if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
                  braceEscaped = !1, isBrace = token2.isBrace = !0, finished = !0;
                  break;
                }
              }
              if (scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_FORWARD_SLASH) {
              if (slashes.push(index), tokens.push(token2), token2 = { value: "", depth: 0, isGlob: !1 }, finished === !0) continue;
              if (prev === CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
              }
              lastIndex = index + 1;
              continue;
            }
            if (opts.noext !== !0 && (code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek2() === CHAR_LEFT_PARENTHESES) {
              if (isGlob = token2.isGlob = !0, isExtglob = token2.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
                for (; eos() !== !0 && (code = advance()); ) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token2.backslashes = !0, code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token2.isGlob = !0, finished = !0;
                    break;
                  }
                }
                continue;
              }
              break;
            }
            if (code === CHAR_ASTERISK) {
              if (prev === CHAR_ASTERISK && (isGlobstar = token2.isGlobstar = !0), isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_QUESTION_MARK) {
              if (isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_LEFT_SQUARE_BRACKET) {
              for (; eos() !== !0 && (next = advance()); ) {
                if (next === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = !0, advance();
                  continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                  isBracket = token2.isBracket = !0, isGlob = token2.isGlob = !0, finished = !0;
                  break;
                }
              }
              if (scanToEnd === !0)
                continue;
              break;
            }
            if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
              negated = token2.negated = !0, start++;
              continue;
            }
            if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
              if (isGlob = token2.isGlob = !0, scanToEnd === !0) {
                for (; eos() !== !0 && (code = advance()); ) {
                  if (code === CHAR_LEFT_PARENTHESES) {
                    backslashes = token2.backslashes = !0, code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    finished = !0;
                    break;
                  }
                }
                continue;
              }
              break;
            }
            if (isGlob === !0) {
              if (finished = !0, scanToEnd === !0)
                continue;
              break;
            }
          }
          opts.noext === !0 && (isExtglob = !1, isGlob = !1);
          let base = str, prefix = "", glob = "";
          start > 0 && (prefix = str.slice(0, start), str = str.slice(start), lastIndex -= start), base && isGlob === !0 && lastIndex > 0 ? (base = str.slice(0, lastIndex), glob = str.slice(lastIndex)) : isGlob === !0 ? (base = "", glob = str) : base = str, base && base !== "" && base !== "/" && base !== str && isPathSeparator(base.charCodeAt(base.length - 1)) && (base = base.slice(0, -1)), opts.unescape === !0 && (glob && (glob = utils2.removeBackslashes(glob)), base && backslashes === !0 && (base = utils2.removeBackslashes(base)));
          let state = {
            prefix,
            input,
            start,
            base,
            glob,
            isBrace,
            isBracket,
            isGlob,
            isExtglob,
            isGlobstar,
            negated,
            negatedExtglob
          };
          if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token2), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
            let prevIndex;
            for (let idx = 0; idx < slashes.length; idx++) {
              let n = prevIndex ? prevIndex + 1 : start, i = slashes[idx], value = input.slice(n, i);
              opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i;
            }
            if (prevIndex && prevIndex + 1 < input.length) {
              let value = input.slice(prevIndex + 1);
              parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
            }
            state.slashes = slashes, state.parts = parts;
          }
          return state;
        };
        module.exports = scan;
      }
    }), require_parse2 = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/lib/parse.js"(exports, module) {
        "use strict";
        var constants = require_constants2(), utils2 = require_utils2(), {
          MAX_LENGTH,
          POSIX_REGEX_SOURCE,
          REGEX_NON_SPECIAL_CHARS,
          REGEX_SPECIAL_CHARS_BACKREF,
          REPLACEMENTS
        } = constants, expandRange = (args, options8) => {
          if (typeof options8.expandRange == "function")
            return options8.expandRange(...args, options8);
          args.sort();
          let value = `[${args.join("-")}]`;
          try {
            new RegExp(value);
          } catch {
            return args.map((v) => utils2.escapeRegex(v)).join("..");
          }
          return value;
        }, syntaxError2 = (type, char) => `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`, parse7 = (input, options8) => {
          if (typeof input != "string")
            throw new TypeError("Expected a string");
          input = REPLACEMENTS[input] || input;
          let opts = { ...options8 }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
          if (len > max)
            throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
          let bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win32 = utils2.isWindows(options8), PLATFORM_CHARS = constants.globChars(win32), EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS), {
            DOT_LITERAL,
            PLUS_LITERAL,
            SLASH_LITERAL,
            ONE_CHAR,
            DOTS_SLASH,
            NO_DOT,
            NO_DOT_SLASH,
            NO_DOTS_SLASH,
            QMARK,
            QMARK_NO_DOT,
            STAR,
            START_ANCHOR
          } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT, star = opts.bash === !0 ? globstar(opts) : STAR;
          opts.capture && (star = `(${star})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
          let state = {
            input,
            index: -1,
            start: 0,
            dot: opts.dot === !0,
            consumed: "",
            output: "",
            prefix: "",
            backtrack: !1,
            negated: !1,
            brackets: 0,
            braces: 0,
            parens: 0,
            quotes: 0,
            globstar: !1,
            tokens
          };
          input = utils2.removePrefix(input, state), len = input.length;
          let extglobs = [], braces = [], stack2 = [], prev = bos, value, eos = () => state.index === len - 1, peek2 = state.peek = (n = 1) => input[state.index + n], advance = state.advance = () => input[++state.index] || "", remaining = () => input.slice(state.index + 1), consume = (value2 = "", num = 0) => {
            state.consumed += value2, state.index += num;
          }, append = (token2) => {
            state.output += token2.output != null ? token2.output : token2.value, consume(token2.value);
          }, negate = () => {
            let count = 1;
            for (; peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?"); )
              advance(), state.start++, count++;
            return count % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
          }, increment = (type) => {
            state[type]++, stack2.push(type);
          }, decrement = (type) => {
            state[type]--, stack2.pop();
          }, push2 = (tok) => {
            if (prev.type === "globstar") {
              let isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
              tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star, state.output += prev.output);
            }
            if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
              prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
              return;
            }
            tok.prev = prev, tokens.push(tok), prev = tok;
          }, extglobOpen = (type, value2) => {
            let token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
            token2.prev = prev, token2.parens = state.parens, token2.output = state.output;
            let output = (opts.capture ? "(" : "") + token2.open;
            increment("parens"), push2({ type, value: value2, output: state.output ? "" : ONE_CHAR }), push2({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token2);
          }, extglobClose = (token2) => {
            let output = token2.close + (opts.capture ? ")" : ""), rest;
            if (token2.type === "negate") {
              let extglobStar = star;
              if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star || eos() || /^\)+$/.test(remaining())) && (output = token2.close = `)$))${extglobStar}`), token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                let expression = parse7(rest, { ...options8, fastpaths: !1 }).output;
                output = token2.close = `)${expression})${extglobStar})`;
              }
              token2.prev.type === "bos" && (state.negatedExtglob = !0);
            }
            push2({ type: "paren", extglob: !0, value, output }), decrement("parens");
          };
          if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input)) {
            let backslashes = !1, output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => first === "\\" ? (backslashes = !0, m) : first === "?" ? esc ? esc + first + (rest ? QMARK.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "") : QMARK.repeat(chars.length) : first === "." ? DOT_LITERAL.repeat(chars.length) : first === "*" ? esc ? esc + first + (rest ? star : "") : star : esc ? m : `\\${m}`);
            return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input && opts.contains === !0 ? (state.output = input, state) : (state.output = utils2.wrapOutput(output, state, options8), state);
          }
          for (; !eos(); ) {
            if (value = advance(), value === "\0")
              continue;
            if (value === "\\") {
              let next = peek2();
              if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
                continue;
              if (!next) {
                value += "\\", push2({ type: "text", value });
                continue;
              }
              let match = /^\\+/.exec(remaining()), slashes = 0;
              if (match && match[0].length > 2 && (slashes = match[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
                push2({ type: "text", value });
                continue;
              }
            }
            if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
              if (opts.posix !== !1 && value === ":") {
                let inner = prev.value.slice(1);
                if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
                  let idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix = POSIX_REGEX_SOURCE[rest2];
                  if (posix) {
                    prev.value = pre + posix, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
                    continue;
                  }
                }
              }
              (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({ value });
              continue;
            }
            if (state.quotes === 1 && value !== '"') {
              value = utils2.escapeRegex(value), prev.value += value, append({ value });
              continue;
            }
            if (value === '"') {
              state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push2({ type: "text", value });
              continue;
            }
            if (value === "(") {
              increment("parens"), push2({ type: "paren", value });
              continue;
            }
            if (value === ")") {
              if (state.parens === 0 && opts.strictBrackets === !0)
                throw new SyntaxError(syntaxError2("opening", "("));
              let extglob = extglobs[extglobs.length - 1];
              if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
              }
              push2({ type: "paren", value, output: state.parens ? ")" : "\\)" }), decrement("parens");
              continue;
            }
            if (value === "[") {
              if (opts.nobracket === !0 || !remaining().includes("]")) {
                if (opts.nobracket !== !0 && opts.strictBrackets === !0)
                  throw new SyntaxError(syntaxError2("closing", "]"));
                value = `\\${value}`;
              } else
                increment("brackets");
              push2({ type: "bracket", value });
              continue;
            }
            if (value === "]") {
              if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
                push2({ type: "text", value, output: `\\${value}` });
                continue;
              }
              if (state.brackets === 0) {
                if (opts.strictBrackets === !0)
                  throw new SyntaxError(syntaxError2("opening", "["));
                push2({ type: "text", value, output: `\\${value}` });
                continue;
              }
              decrement("brackets");
              let prevValue = prev.value.slice(1);
              if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append({ value }), opts.literalBrackets === !1 || utils2.hasRegexChars(prevValue))
                continue;
              let escaped = utils2.escapeRegex(prev.value);
              if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
                state.output += escaped, prev.value = escaped;
                continue;
              }
              prev.value = `(${capture}${escaped}|${prev.value})`, state.output += prev.value;
              continue;
            }
            if (value === "{" && opts.nobrace !== !0) {
              increment("braces");
              let open = {
                type: "brace",
                value,
                output: "(",
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
              };
              braces.push(open), push2(open);
              continue;
            }
            if (value === "}") {
              let brace = braces[braces.length - 1];
              if (opts.nobrace === !0 || !brace) {
                push2({ type: "text", value, output: value });
                continue;
              }
              let output = ")";
              if (brace.dots === !0) {
                let arr = tokens.slice(), range = [];
                for (let i = arr.length - 1; i >= 0 && (tokens.pop(), arr[i].type !== "brace"); i--)
                  arr[i].type !== "dots" && range.unshift(arr[i].value);
                output = expandRange(range, opts), state.backtrack = !0;
              }
              if (brace.comma !== !0 && brace.dots !== !0) {
                let out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = "\\{", value = output = "\\}", state.output = out;
                for (let t of toks)
                  state.output += t.output || t.value;
              }
              push2({ type: "brace", value, output }), decrement("braces"), braces.pop();
              continue;
            }
            if (value === "|") {
              extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push2({ type: "text", value });
              continue;
            }
            if (value === ",") {
              let output = value, brace = braces[braces.length - 1];
              brace && stack2[stack2.length - 1] === "braces" && (brace.comma = !0, output = "|"), push2({ type: "comma", value, output });
              continue;
            }
            if (value === "/") {
              if (prev.type === "dot" && state.index === state.start + 1) {
                state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
                continue;
              }
              push2({ type: "slash", value, output: SLASH_LITERAL });
              continue;
            }
            if (value === ".") {
              if (state.braces > 0 && prev.type === "dot") {
                prev.value === "." && (prev.output = DOT_LITERAL);
                let brace = braces[braces.length - 1];
                prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
                continue;
              }
              if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
                push2({ type: "text", value, output: DOT_LITERAL });
                continue;
              }
              push2({ type: "dot", value, output: DOT_LITERAL });
              continue;
            }
            if (value === "?") {
              if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
                extglobOpen("qmark", value);
                continue;
              }
              if (prev && prev.type === "paren") {
                let next = peek2(), output = value;
                if (next === "<" && !utils2.supportsLookbehinds())
                  throw new Error("Node.js v10 or higher is required for regex lookbehinds");
                (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push2({ type: "text", value, output });
                continue;
              }
              if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
                push2({ type: "qmark", value, output: QMARK_NO_DOT });
                continue;
              }
              push2({ type: "qmark", value, output: QMARK });
              continue;
            }
            if (value === "!") {
              if (opts.noextglob !== !0 && peek2() === "(" && (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3)))) {
                extglobOpen("negate", value);
                continue;
              }
              if (opts.nonegate !== !0 && state.index === 0) {
                negate();
                continue;
              }
            }
            if (value === "+") {
              if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
                extglobOpen("plus", value);
                continue;
              }
              if (prev && prev.value === "(" || opts.regex === !1) {
                push2({ type: "plus", value, output: PLUS_LITERAL });
                continue;
              }
              if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
                push2({ type: "plus", value });
                continue;
              }
              push2({ type: "plus", value: PLUS_LITERAL });
              continue;
            }
            if (value === "@") {
              if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
                push2({ type: "at", extglob: !0, value, output: "" });
                continue;
              }
              push2({ type: "text", value });
              continue;
            }
            if (value !== "*") {
              (value === "$" || value === "^") && (value = `\\${value}`);
              let match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
              match && (value += match[0], state.index += match[0].length), push2({ type: "text", value });
              continue;
            }
            if (prev && (prev.type === "globstar" || prev.star === !0)) {
              prev.type = "star", prev.star = !0, prev.value += value, prev.output = star, state.backtrack = !0, state.globstar = !0, consume(value);
              continue;
            }
            let rest = remaining();
            if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
              extglobOpen("star", value);
              continue;
            }
            if (prev.type === "star") {
              if (opts.noglobstar === !0) {
                consume(value);
                continue;
              }
              let prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
              if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
                push2({ type: "star", value, output: "" });
                continue;
              }
              let isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
              if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
                push2({ type: "star", value, output: "" });
                continue;
              }
              for (; rest.slice(0, 3) === "/**"; ) {
                let after = input[state.index + 4];
                if (after && after !== "/")
                  break;
                rest = rest.slice(3), consume("/**", 3);
              }
              if (prior.type === "bos" && eos()) {
                prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
                continue;
              }
              if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
                continue;
              }
              if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
                let end = rest[1] !== void 0 ? "|$" : "";
                state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`, prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
                continue;
              }
              if (prior.type === "bos" && rest[0] === "/") {
                prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`, state.output = prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
                continue;
              }
              state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
              continue;
            }
            let token2 = { type: "star", value, output: star };
            if (opts.bash === !0) {
              token2.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token2.output = nodot + token2.output), push2(token2);
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
              token2.output = value, push2(token2);
              continue;
            }
            (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek2() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push2(token2);
          }
          for (; state.brackets > 0; ) {
            if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "]"));
            state.output = utils2.escapeLast(state.output, "["), decrement("brackets");
          }
          for (; state.parens > 0; ) {
            if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", ")"));
            state.output = utils2.escapeLast(state.output, "("), decrement("parens");
          }
          for (; state.braces > 0; ) {
            if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "}"));
            state.output = utils2.escapeLast(state.output, "{"), decrement("braces");
          }
          if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` }), state.backtrack === !0) {
            state.output = "";
            for (let token2 of state.tokens)
              state.output += token2.output != null ? token2.output : token2.value, token2.suffix && (state.output += token2.suffix);
          }
          return state;
        };
        parse7.fastpaths = (input, options8) => {
          let opts = { ...options8 }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
          if (len > max)
            throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
          input = REPLACEMENTS[input] || input;
          let win32 = utils2.isWindows(options8), {
            DOT_LITERAL,
            SLASH_LITERAL,
            ONE_CHAR,
            DOTS_SLASH,
            NO_DOT,
            NO_DOTS,
            NO_DOTS_SLASH,
            STAR,
            START_ANCHOR
          } = constants.globChars(win32), nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = { negated: !1, prefix: "" }, star = opts.bash === !0 ? ".*?" : STAR;
          opts.capture && (star = `(${star})`);
          let globstar = (opts2) => opts2.noglobstar === !0 ? star : `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, create = (str) => {
            switch (str) {
              case "*":
                return `${nodot}${ONE_CHAR}${star}`;
              case ".*":
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
              case "*.*":
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
              case "*/*":
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
              case "**":
                return nodot + globstar(opts);
              case "**/*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
              case "**/*.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
              case "**/.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
              default: {
                let match = /^(.*?)\.(\w+)$/.exec(str);
                if (!match) return;
                let source3 = create(match[1]);
                return source3 ? source3 + DOT_LITERAL + match[2] : void 0;
              }
            }
          }, output = utils2.removePrefix(input, state), source2 = create(output);
          return source2 && opts.strictSlashes !== !0 && (source2 += `${SLASH_LITERAL}?`), source2;
        }, module.exports = parse7;
      }
    }), require_picomatch = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/lib/picomatch.js"(exports, module) {
        "use strict";
        var path15 = __require("path"), scan = require_scan(), parse7 = require_parse2(), utils2 = require_utils2(), constants = require_constants2(), isObject2 = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch = (glob, options8, returnState = !1) => {
          if (Array.isArray(glob)) {
            let fns = glob.map((input) => picomatch(input, options8, returnState));
            return (str) => {
              for (let isMatch of fns) {
                let state2 = isMatch(str);
                if (state2) return state2;
              }
              return !1;
            };
          }
          let isState = isObject2(glob) && glob.tokens && glob.input;
          if (glob === "" || typeof glob != "string" && !isState)
            throw new TypeError("Expected pattern to be a non-empty string");
          let opts = options8 || {}, posix = utils2.isWindows(options8), regex = isState ? picomatch.compileRe(glob, options8) : picomatch.makeRe(glob, options8, !1, !0), state = regex.state;
          delete regex.state;
          let isIgnored2 = () => !1;
          if (opts.ignore) {
            let ignoreOpts = { ...options8, ignore: null, onMatch: null, onResult: null };
            isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);
          }
          let matcher = (input, returnObject = !1) => {
            let { isMatch, match, output } = picomatch.test(input, regex, options8, { glob, posix }), result = { glob, state, regex, posix, input, output, match, isMatch };
            return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored2(input) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
          };
          return returnState && (matcher.state = state), matcher;
        };
        picomatch.test = (input, regex, options8, { glob, posix } = {}) => {
          if (typeof input != "string")
            throw new TypeError("Expected input to be a string");
          if (input === "")
            return { isMatch: !1, output: "" };
          let opts = options8 || {}, format3 = opts.format || (posix ? utils2.toPosixSlashes : null), match = input === glob, output = match && format3 ? format3(input) : input;
          return match === !1 && (output = format3 ? format3(input) : input, match = output === glob), (match === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match = picomatch.matchBase(input, regex, options8, posix) : match = regex.exec(output)), { isMatch: !!match, match, output };
        }, picomatch.matchBase = (input, glob, options8, posix = utils2.isWindows(options8)) => (glob instanceof RegExp ? glob : picomatch.makeRe(glob, options8)).test(path15.basename(input)), picomatch.isMatch = (str, patterns, options8) => picomatch(patterns, options8)(str), picomatch.parse = (pattern, options8) => Array.isArray(pattern) ? pattern.map((p) => picomatch.parse(p, options8)) : parse7(pattern, { ...options8, fastpaths: !1 }), picomatch.scan = (input, options8) => scan(input, options8), picomatch.compileRe = (state, options8, returnOutput = !1, returnState = !1) => {
          if (returnOutput === !0)
            return state.output;
          let opts = options8 || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$", source2 = `${prepend}(?:${state.output})${append}`;
          state && state.negated === !0 && (source2 = `^(?!${source2}).*$`);
          let regex = picomatch.toRegex(source2, options8);
          return returnState === !0 && (regex.state = state), regex;
        }, picomatch.makeRe = (input, options8 = {}, returnOutput = !1, returnState = !1) => {
          if (!input || typeof input != "string")
            throw new TypeError("Expected a non-empty string");
          let parsed = { negated: !1, fastpaths: !0 };
          return options8.fastpaths !== !1 && (input[0] === "." || input[0] === "*") && (parsed.output = parse7.fastpaths(input, options8)), parsed.output || (parsed = parse7(input, options8)), picomatch.compileRe(parsed, options8, returnOutput, returnState);
        }, picomatch.toRegex = (source2, options8) => {
          try {
            let opts = options8 || {};
            return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
          } catch (err) {
            if (options8 && options8.debug === !0) throw err;
            return /$^/;
          }
        }, picomatch.constants = constants, module.exports = picomatch;
      }
    }), require_picomatch2 = __commonJS({
      "node_modules/micromatch/node_modules/picomatch/index.js"(exports, module) {
        "use strict";
        module.exports = require_picomatch();
      }
    }), require_micromatch = __commonJS({
      "node_modules/micromatch/index.js"(exports, module) {
        "use strict";
        var util2 = __require("util"), braces = require_braces(), picomatch = require_picomatch2(), utils2 = require_utils2(), isEmptyString = (v) => v === "" || v === "./", hasBraces = (v) => {
          let index = v.indexOf("{");
          return index > -1 && v.indexOf("}", index) > -1;
        }, micromatch2 = (list, patterns, options8) => {
          patterns = [].concat(patterns), list = [].concat(list);
          let omit2 = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state) => {
            items.add(state.output), options8 && options8.onResult && options8.onResult(state);
          };
          for (let i = 0; i < patterns.length; i++) {
            let isMatch = picomatch(String(patterns[i]), { ...options8, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
            negated && negatives++;
            for (let item of list) {
              let matched = isMatch(item, !0);
              (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit2.add(matched.output) : (omit2.delete(matched.output), keep.add(matched.output)));
            }
          }
          let matches = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit2.has(item));
          if (options8 && matches.length === 0) {
            if (options8.failglob === !0)
              throw new Error(`No matches found for "${patterns.join(", ")}"`);
            if (options8.nonull === !0 || options8.nullglob === !0)
              return options8.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
          }
          return matches;
        };
        micromatch2.match = micromatch2, micromatch2.matcher = (pattern, options8) => picomatch(pattern, options8), micromatch2.isMatch = (str, patterns, options8) => picomatch(patterns, options8)(str), micromatch2.any = micromatch2.isMatch, micromatch2.not = (list, patterns, options8 = {}) => {
          patterns = [].concat(patterns).map(String);
          let result = /* @__PURE__ */ new Set(), items = [], onResult = (state) => {
            options8.onResult && options8.onResult(state), items.push(state.output);
          }, matches = new Set(micromatch2(list, patterns, { ...options8, onResult }));
          for (let item of items)
            matches.has(item) || result.add(item);
          return [...result];
        }, micromatch2.contains = (str, pattern, options8) => {
          if (typeof str != "string")
            throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
          if (Array.isArray(pattern))
            return pattern.some((p) => micromatch2.contains(str, p, options8));
          if (typeof pattern == "string") {
            if (isEmptyString(str) || isEmptyString(pattern))
              return !1;
            if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern))
              return !0;
          }
          return micromatch2.isMatch(str, pattern, { ...options8, contains: !0 });
        }, micromatch2.matchKeys = (obj, patterns, options8) => {
          if (!utils2.isObject(obj))
            throw new TypeError("Expected the first argument to be an object");
          let keys = micromatch2(Object.keys(obj), patterns, options8), res = {};
          for (let key2 of keys) res[key2] = obj[key2];
          return res;
        }, micromatch2.some = (list, patterns, options8) => {
          let items = [].concat(list);
          for (let pattern of [].concat(patterns)) {
            let isMatch = picomatch(String(pattern), options8);
            if (items.some((item) => isMatch(item)))
              return !0;
          }
          return !1;
        }, micromatch2.every = (list, patterns, options8) => {
          let items = [].concat(list);
          for (let pattern of [].concat(patterns)) {
            let isMatch = picomatch(String(pattern), options8);
            if (!items.every((item) => isMatch(item)))
              return !1;
          }
          return !0;
        }, micromatch2.all = (str, patterns, options8) => {
          if (typeof str != "string")
            throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
          return [].concat(patterns).every((p) => picomatch(p, options8)(str));
        }, micromatch2.capture = (glob, input, options8) => {
          let posix = utils2.isWindows(options8), match = picomatch.makeRe(String(glob), { ...options8, capture: !0 }).exec(posix ? utils2.toPosixSlashes(input) : input);
          if (match)
            return match.slice(1).map((v) => v === void 0 ? "" : v);
        }, micromatch2.makeRe = (...args) => picomatch.makeRe(...args), micromatch2.scan = (...args) => picomatch.scan(...args), micromatch2.parse = (patterns, options8) => {
          let res = [];
          for (let pattern of [].concat(patterns || []))
            for (let str of braces(String(pattern), options8))
              res.push(picomatch.parse(str, options8));
          return res;
        }, micromatch2.braces = (pattern, options8) => {
          if (typeof pattern != "string") throw new TypeError("Expected a string");
          return options8 && options8.nobrace === !0 || !hasBraces(pattern) ? [pattern] : braces(pattern, options8);
        }, micromatch2.braceExpand = (pattern, options8) => {
          if (typeof pattern != "string") throw new TypeError("Expected a string");
          return micromatch2.braces(pattern, { ...options8, expand: !0 });
        }, micromatch2.hasBraces = hasBraces, module.exports = micromatch2;
      }
    }), require_pattern = __commonJS({
      "node_modules/fast-glob/out/utils/pattern.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isAbsolute = exports.partitionAbsoluteAndRelative = exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
        var path15 = __require("path"), globParent = require_glob_parent(), micromatch2 = require_micromatch(), GLOBSTAR = "**", ESCAPE_SYMBOL = "\\", COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/, REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/, REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/, BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./, DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
        function isStaticPattern(pattern, options8 = {}) {
          return !isDynamicPattern(pattern, options8);
        }
        exports.isStaticPattern = isStaticPattern;
        function isDynamicPattern(pattern, options8 = {}) {
          return pattern === "" ? !1 : !!(options8.caseSensitiveMatch === !1 || pattern.includes(ESCAPE_SYMBOL) || COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern) || options8.extglob !== !1 && GLOB_EXTENSION_SYMBOLS_RE.test(pattern) || options8.braceExpansion !== !1 && hasBraceExpansion(pattern));
        }
        exports.isDynamicPattern = isDynamicPattern;
        function hasBraceExpansion(pattern) {
          let openingBraceIndex = pattern.indexOf("{");
          if (openingBraceIndex === -1)
            return !1;
          let closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
          if (closingBraceIndex === -1)
            return !1;
          let braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
          return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
        }
        function convertToPositivePattern(pattern) {
          return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
        }
        exports.convertToPositivePattern = convertToPositivePattern;
        function convertToNegativePattern(pattern) {
          return "!" + pattern;
        }
        exports.convertToNegativePattern = convertToNegativePattern;
        function isNegativePattern(pattern) {
          return pattern.startsWith("!") && pattern[1] !== "(";
        }
        exports.isNegativePattern = isNegativePattern;
        function isPositivePattern(pattern) {
          return !isNegativePattern(pattern);
        }
        exports.isPositivePattern = isPositivePattern;
        function getNegativePatterns(patterns) {
          return patterns.filter(isNegativePattern);
        }
        exports.getNegativePatterns = getNegativePatterns;
        function getPositivePatterns(patterns) {
          return patterns.filter(isPositivePattern);
        }
        exports.getPositivePatterns = getPositivePatterns;
        function getPatternsInsideCurrentDirectory(patterns) {
          return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
        }
        exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
        function getPatternsOutsideCurrentDirectory(patterns) {
          return patterns.filter(isPatternRelatedToParentDirectory);
        }
        exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
        function isPatternRelatedToParentDirectory(pattern) {
          return pattern.startsWith("..") || pattern.startsWith("./..");
        }
        exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
        function getBaseDirectory(pattern) {
          return globParent(pattern, { flipBackslashes: !1 });
        }
        exports.getBaseDirectory = getBaseDirectory;
        function hasGlobStar(pattern) {
          return pattern.includes(GLOBSTAR);
        }
        exports.hasGlobStar = hasGlobStar;
        function endsWithSlashGlobStar(pattern) {
          return pattern.endsWith("/" + GLOBSTAR);
        }
        exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
        function isAffectDepthOfReadingPattern(pattern) {
          let basename = path15.basename(pattern);
          return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
        }
        exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
        function expandPatternsWithBraceExpansion(patterns) {
          return patterns.reduce((collection, pattern) => collection.concat(expandBraceExpansion(pattern)), []);
        }
        exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
        function expandBraceExpansion(pattern) {
          let patterns = micromatch2.braces(pattern, { expand: !0, nodupes: !0, keepEscaping: !0 });
          return patterns.sort((a, b) => a.length - b.length), patterns.filter((pattern2) => pattern2 !== "");
        }
        exports.expandBraceExpansion = expandBraceExpansion;
        function getPatternParts(pattern, options8) {
          let { parts } = micromatch2.scan(pattern, Object.assign(Object.assign({}, options8), { parts: !0 }));
          return parts.length === 0 && (parts = [pattern]), parts[0].startsWith("/") && (parts[0] = parts[0].slice(1), parts.unshift("")), parts;
        }
        exports.getPatternParts = getPatternParts;
        function makeRe(pattern, options8) {
          return micromatch2.makeRe(pattern, options8);
        }
        exports.makeRe = makeRe;
        function convertPatternsToRe(patterns, options8) {
          return patterns.map((pattern) => makeRe(pattern, options8));
        }
        exports.convertPatternsToRe = convertPatternsToRe;
        function matchAny(entry, patternsRe) {
          return patternsRe.some((patternRe) => patternRe.test(entry));
        }
        exports.matchAny = matchAny;
        function removeDuplicateSlashes(pattern) {
          return pattern.replace(DOUBLE_SLASH_RE, "/");
        }
        exports.removeDuplicateSlashes = removeDuplicateSlashes;
        function partitionAbsoluteAndRelative(patterns) {
          let absolute = [], relative2 = [];
          for (let pattern of patterns)
            isAbsolute(pattern) ? absolute.push(pattern) : relative2.push(pattern);
          return [absolute, relative2];
        }
        exports.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;
        function isAbsolute(pattern) {
          return path15.isAbsolute(pattern);
        }
        exports.isAbsolute = isAbsolute;
      }
    }), require_merge2 = __commonJS({
      "node_modules/merge2/index.js"(exports, module) {
        "use strict";
        var Stream = __require("stream"), PassThrough = Stream.PassThrough, slice = Array.prototype.slice;
        module.exports = merge2;
        function merge2() {
          let streamsQueue = [], args = slice.call(arguments), merging = !1, options8 = args[args.length - 1];
          options8 && !Array.isArray(options8) && options8.pipe == null ? args.pop() : options8 = {};
          let doEnd = options8.end !== !1, doPipeError = options8.pipeError === !0;
          options8.objectMode == null && (options8.objectMode = !0), options8.highWaterMark == null && (options8.highWaterMark = 64 * 1024);
          let mergedStream = PassThrough(options8);
          function addStream() {
            for (let i = 0, len = arguments.length; i < len; i++)
              streamsQueue.push(pauseStreams(arguments[i], options8));
            return mergeStream(), this;
          }
          function mergeStream() {
            if (merging)
              return;
            merging = !0;
            let streams = streamsQueue.shift();
            if (!streams) {
              process.nextTick(endStream);
              return;
            }
            Array.isArray(streams) || (streams = [streams]);
            let pipesCount = streams.length + 1;
            function next() {
              --pipesCount > 0 || (merging = !1, mergeStream());
            }
            function pipe(stream) {
              function onend() {
                stream.removeListener("merge2UnpipeEnd", onend), stream.removeListener("end", onend), doPipeError && stream.removeListener("error", onerror), next();
              }
              function onerror(err) {
                mergedStream.emit("error", err);
              }
              if (stream._readableState.endEmitted)
                return next();
              stream.on("merge2UnpipeEnd", onend), stream.on("end", onend), doPipeError && stream.on("error", onerror), stream.pipe(mergedStream, { end: !1 }), stream.resume();
            }
            for (let i = 0; i < streams.length; i++)
              pipe(streams[i]);
            next();
          }
          function endStream() {
            merging = !1, mergedStream.emit("queueDrain"), doEnd && mergedStream.end();
          }
          return mergedStream.setMaxListeners(0), mergedStream.add = addStream, mergedStream.on("unpipe", function(stream) {
            stream.emit("merge2UnpipeEnd");
          }), args.length && addStream.apply(null, args), mergedStream;
        }
        function pauseStreams(streams, options8) {
          if (Array.isArray(streams))
            for (let i = 0, len = streams.length; i < len; i++)
              streams[i] = pauseStreams(streams[i], options8);
          else {
            if (!streams._readableState && streams.pipe && (streams = streams.pipe(PassThrough(options8))), !streams._readableState || !streams.pause || !streams.pipe)
              throw new Error("Only readable stream can be merged.");
            streams.pause();
          }
          return streams;
        }
      }
    }), require_stream = __commonJS({
      "node_modules/fast-glob/out/utils/stream.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.merge = void 0;
        var merge2 = require_merge2();
        function merge(streams) {
          let mergedStream = merge2(streams);
          return streams.forEach((stream) => {
            stream.once("error", (error) => mergedStream.emit("error", error));
          }), mergedStream.once("close", () => propagateCloseEventToSources(streams)), mergedStream.once("end", () => propagateCloseEventToSources(streams)), mergedStream;
        }
        exports.merge = merge;
        function propagateCloseEventToSources(streams) {
          streams.forEach((stream) => stream.emit("close"));
        }
      }
    }), require_string = __commonJS({
      "node_modules/fast-glob/out/utils/string.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEmpty = exports.isString = void 0;
        function isString(input) {
          return typeof input == "string";
        }
        exports.isString = isString;
        function isEmpty(input) {
          return input === "";
        }
        exports.isEmpty = isEmpty;
      }
    }), require_utils3 = __commonJS({
      "node_modules/fast-glob/out/utils/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
        var array2 = require_array();
        exports.array = array2;
        var errno = require_errno();
        exports.errno = errno;
        var fs4 = require_fs();
        exports.fs = fs4;
        var path15 = require_path();
        exports.path = path15;
        var pattern = require_pattern();
        exports.pattern = pattern;
        var stream = require_stream();
        exports.stream = stream;
        var string = require_string();
        exports.string = string;
      }
    }), require_tasks = __commonJS({
      "node_modules/fast-glob/out/managers/tasks.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
        var utils2 = require_utils3();
        function generate(input, settings) {
          let patterns = processPatterns(input, settings), ignore = processPatterns(settings.ignore, settings), positivePatterns = getPositivePatterns(patterns), negativePatterns = getNegativePatternsAsPositive(patterns, ignore), staticPatterns = positivePatterns.filter((pattern) => utils2.pattern.isStaticPattern(pattern, settings)), dynamicPatterns = positivePatterns.filter((pattern) => utils2.pattern.isDynamicPattern(pattern, settings)), staticTasks = convertPatternsToTasks(
            staticPatterns,
            negativePatterns,
            /* dynamic */
            !1
          ), dynamicTasks = convertPatternsToTasks(
            dynamicPatterns,
            negativePatterns,
            /* dynamic */
            !0
          );
          return staticTasks.concat(dynamicTasks);
        }
        exports.generate = generate;
        function processPatterns(input, settings) {
          let patterns = input;
          return settings.braceExpansion && (patterns = utils2.pattern.expandPatternsWithBraceExpansion(patterns)), settings.baseNameMatch && (patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`)), patterns.map((pattern) => utils2.pattern.removeDuplicateSlashes(pattern));
        }
        function convertPatternsToTasks(positive, negative, dynamic) {
          let tasks = [], patternsOutsideCurrentDirectory = utils2.pattern.getPatternsOutsideCurrentDirectory(positive), patternsInsideCurrentDirectory = utils2.pattern.getPatternsInsideCurrentDirectory(positive), outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory), insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
          return tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic)), "." in insideCurrentDirectoryGroup ? tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic)) : tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic)), tasks;
        }
        exports.convertPatternsToTasks = convertPatternsToTasks;
        function getPositivePatterns(patterns) {
          return utils2.pattern.getPositivePatterns(patterns);
        }
        exports.getPositivePatterns = getPositivePatterns;
        function getNegativePatternsAsPositive(patterns, ignore) {
          return utils2.pattern.getNegativePatterns(patterns).concat(ignore).map(utils2.pattern.convertToPositivePattern);
        }
        exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
        function groupPatternsByBaseDirectory(patterns) {
          let group2 = {};
          return patterns.reduce((collection, pattern) => {
            let base = utils2.pattern.getBaseDirectory(pattern);
            return base in collection ? collection[base].push(pattern) : collection[base] = [pattern], collection;
          }, group2);
        }
        exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
        function convertPatternGroupsToTasks(positive, negative, dynamic) {
          return Object.keys(positive).map((base) => convertPatternGroupToTask(base, positive[base], negative, dynamic));
        }
        exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
        function convertPatternGroupToTask(base, positive, negative, dynamic) {
          return {
            dynamic,
            positive,
            negative,
            base,
            patterns: [].concat(positive, negative.map(utils2.pattern.convertToNegativePattern))
          };
        }
        exports.convertPatternGroupToTask = convertPatternGroupToTask;
      }
    }), require_async = __commonJS({
      "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.read = void 0;
        function read3(path15, settings, callback) {
          settings.fs.lstat(path15, (lstatError, lstat2) => {
            if (lstatError !== null) {
              callFailureCallback(callback, lstatError);
              return;
            }
            if (!lstat2.isSymbolicLink() || !settings.followSymbolicLink) {
              callSuccessCallback(callback, lstat2);
              return;
            }
            settings.fs.stat(path15, (statError, stat2) => {
              if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                  callFailureCallback(callback, statError);
                  return;
                }
                callSuccessCallback(callback, lstat2);
                return;
              }
              settings.markSymbolicLink && (stat2.isSymbolicLink = () => !0), callSuccessCallback(callback, stat2);
            });
          });
        }
        exports.read = read3;
        function callFailureCallback(callback, error) {
          callback(error);
        }
        function callSuccessCallback(callback, result) {
          callback(null, result);
        }
      }
    }), require_sync = __commonJS({
      "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.read = void 0;
        function read3(path15, settings) {
          let lstat2 = settings.fs.lstatSync(path15);
          if (!lstat2.isSymbolicLink() || !settings.followSymbolicLink)
            return lstat2;
          try {
            let stat2 = settings.fs.statSync(path15);
            return settings.markSymbolicLink && (stat2.isSymbolicLink = () => !0), stat2;
          } catch (error) {
            if (!settings.throwErrorOnBrokenSymbolicLink)
              return lstat2;
            throw error;
          }
        }
        exports.read = read3;
      }
    }), require_fs2 = __commonJS({
      "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
        var fs4 = __require("fs");
        exports.FILE_SYSTEM_ADAPTER = {
          lstat: fs4.lstat,
          stat: fs4.stat,
          lstatSync: fs4.lstatSync,
          statSync: fs4.statSync
        };
        function createFileSystemAdapter(fsMethods) {
          return fsMethods === void 0 ? exports.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
        }
        exports.createFileSystemAdapter = createFileSystemAdapter;
      }
    }), require_settings = __commonJS({
      "node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fs4 = require_fs2(), Settings = class {
          constructor(_options = {}) {
            this._options = _options, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = fs4.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
          }
          _getValue(option, value) {
            return option ?? value;
          }
        };
        exports.default = Settings;
      }
    }), require_out = __commonJS({
      "node_modules/@nodelib/fs.stat/out/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.statSync = exports.stat = exports.Settings = void 0;
        var async = require_async(), sync = require_sync(), settings_1 = require_settings();
        exports.Settings = settings_1.default;
        function stat2(path15, optionsOrSettingsOrCallback, callback) {
          if (typeof optionsOrSettingsOrCallback == "function") {
            async.read(path15, getSettings(), optionsOrSettingsOrCallback);
            return;
          }
          async.read(path15, getSettings(optionsOrSettingsOrCallback), callback);
        }
        exports.stat = stat2;
        function statSync2(path15, optionsOrSettings) {
          let settings = getSettings(optionsOrSettings);
          return sync.read(path15, settings);
        }
        exports.statSync = statSync2;
        function getSettings(settingsOrOptions = {}) {
          return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
        }
      }
    }), require_queue_microtask = __commonJS({
      "node_modules/queue-microtask/index.js"(exports, module) {
        var promise;
        module.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
          throw err;
        }, 0));
      }
    }), require_run_parallel = __commonJS({
      "node_modules/run-parallel/index.js"(exports, module) {
        module.exports = runParallel;
        var queueMicrotask2 = require_queue_microtask();
        function runParallel(tasks, cb) {
          let results, pending, keys, isSync = !0;
          Array.isArray(tasks) ? (results = [], pending = tasks.length) : (keys = Object.keys(tasks), results = {}, pending = keys.length);
          function done(err) {
            function end() {
              cb && cb(err, results), cb = null;
            }
            isSync ? queueMicrotask2(end) : end();
          }
          function each(i, err, result) {
            results[i] = result, (--pending === 0 || err) && done(err);
          }
          pending ? keys ? keys.forEach(function(key2) {
            tasks[key2](function(err, result) {
              each(key2, err, result);
            });
          }) : tasks.forEach(function(task, i) {
            task(function(err, result) {
              each(i, err, result);
            });
          }) : done(null), isSync = !1;
        }
      }
    }), require_constants3 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
        var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
        if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0)
          throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
        var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10), MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10), SUPPORTED_MAJOR_VERSION = 10, SUPPORTED_MINOR_VERSION = 10, IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION, IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
        exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
      }
    }), require_fs3 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.createDirentFromStats = void 0;
        var DirentFromStats = class {
          constructor(name, stats) {
            this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
          }
        };
        function createDirentFromStats(name, stats) {
          return new DirentFromStats(name, stats);
        }
        exports.createDirentFromStats = createDirentFromStats;
      }
    }), require_utils4 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.fs = void 0;
        var fs4 = require_fs3();
        exports.fs = fs4;
      }
    }), require_common = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.joinPathSegments = void 0;
        function joinPathSegments(a, b, separator) {
          return a.endsWith(separator) ? a + b : a + separator + b;
        }
        exports.joinPathSegments = joinPathSegments;
      }
    }), require_async2 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
        var fsStat = require_out(), rpl = require_run_parallel(), constants_1 = require_constants3(), utils2 = require_utils4(), common = require_common();
        function read3(directory, settings, callback) {
          if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
            readdirWithFileTypes(directory, settings, callback);
            return;
          }
          readdir(directory, settings, callback);
        }
        exports.read = read3;
        function readdirWithFileTypes(directory, settings, callback) {
          settings.fs.readdir(directory, { withFileTypes: !0 }, (readdirError, dirents) => {
            if (readdirError !== null) {
              callFailureCallback(callback, readdirError);
              return;
            }
            let entries = dirents.map((dirent) => ({
              dirent,
              name: dirent.name,
              path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
            }));
            if (!settings.followSymbolicLinks) {
              callSuccessCallback(callback, entries);
              return;
            }
            let tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
            rpl(tasks, (rplError, rplEntries) => {
              if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
              }
              callSuccessCallback(callback, rplEntries);
            });
          });
        }
        exports.readdirWithFileTypes = readdirWithFileTypes;
        function makeRplTaskEntry(entry, settings) {
          return (done) => {
            if (!entry.dirent.isSymbolicLink()) {
              done(null, entry);
              return;
            }
            settings.fs.stat(entry.path, (statError, stats) => {
              if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                  done(statError);
                  return;
                }
                done(null, entry);
                return;
              }
              entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats), done(null, entry);
            });
          };
        }
        function readdir(directory, settings, callback) {
          settings.fs.readdir(directory, (readdirError, names) => {
            if (readdirError !== null) {
              callFailureCallback(callback, readdirError);
              return;
            }
            let tasks = names.map((name) => {
              let path15 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
              return (done) => {
                fsStat.stat(path15, settings.fsStatSettings, (error, stats) => {
                  if (error !== null) {
                    done(error);
                    return;
                  }
                  let entry = {
                    name,
                    path: path15,
                    dirent: utils2.fs.createDirentFromStats(name, stats)
                  };
                  settings.stats && (entry.stats = stats), done(null, entry);
                });
              };
            });
            rpl(tasks, (rplError, entries) => {
              if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
              }
              callSuccessCallback(callback, entries);
            });
          });
        }
        exports.readdir = readdir;
        function callFailureCallback(callback, error) {
          callback(error);
        }
        function callSuccessCallback(callback, result) {
          callback(null, result);
        }
      }
    }), require_sync2 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
        var fsStat = require_out(), constants_1 = require_constants3(), utils2 = require_utils4(), common = require_common();
        function read3(directory, settings) {
          return !settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? readdirWithFileTypes(directory, settings) : readdir(directory, settings);
        }
        exports.read = read3;
        function readdirWithFileTypes(directory, settings) {
          return settings.fs.readdirSync(directory, { withFileTypes: !0 }).map((dirent) => {
            let entry = {
              dirent,
              name: dirent.name,
              path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
            };
            if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks)
              try {
                let stats = settings.fs.statSync(entry.path);
                entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats);
              } catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink)
                  throw error;
              }
            return entry;
          });
        }
        exports.readdirWithFileTypes = readdirWithFileTypes;
        function readdir(directory, settings) {
          return settings.fs.readdirSync(directory).map((name) => {
            let entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator), stats = fsStat.statSync(entryPath, settings.fsStatSettings), entry = {
              name,
              path: entryPath,
              dirent: utils2.fs.createDirentFromStats(name, stats)
            };
            return settings.stats && (entry.stats = stats), entry;
          });
        }
        exports.readdir = readdir;
      }
    }), require_fs4 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
        var fs4 = __require("fs");
        exports.FILE_SYSTEM_ADAPTER = {
          lstat: fs4.lstat,
          stat: fs4.stat,
          lstatSync: fs4.lstatSync,
          statSync: fs4.statSync,
          readdir: fs4.readdir,
          readdirSync: fs4.readdirSync
        };
        function createFileSystemAdapter(fsMethods) {
          return fsMethods === void 0 ? exports.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
        }
        exports.createFileSystemAdapter = createFileSystemAdapter;
      }
    }), require_settings2 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var path15 = __require("path"), fsStat = require_out(), fs4 = require_fs4(), Settings = class {
          constructor(_options = {}) {
            this._options = _options, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = fs4.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path15.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new fsStat.Settings({
              followSymbolicLink: this.followSymbolicLinks,
              fs: this.fs,
              throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
            });
          }
          _getValue(option, value) {
            return option ?? value;
          }
        };
        exports.default = Settings;
      }
    }), require_out2 = __commonJS({
      "node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Settings = exports.scandirSync = exports.scandir = void 0;
        var async = require_async2(), sync = require_sync2(), settings_1 = require_settings2();
        exports.Settings = settings_1.default;
        function scandir(path15, optionsOrSettingsOrCallback, callback) {
          if (typeof optionsOrSettingsOrCallback == "function") {
            async.read(path15, getSettings(), optionsOrSettingsOrCallback);
            return;
          }
          async.read(path15, getSettings(optionsOrSettingsOrCallback), callback);
        }
        exports.scandir = scandir;
        function scandirSync(path15, optionsOrSettings) {
          let settings = getSettings(optionsOrSettings);
          return sync.read(path15, settings);
        }
        exports.scandirSync = scandirSync;
        function getSettings(settingsOrOptions = {}) {
          return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
        }
      }
    }), require_reusify = __commonJS({
      "node_modules/reusify/reusify.js"(exports, module) {
        "use strict";
        function reusify(Constructor) {
          var head = new Constructor(), tail = head;
          function get() {
            var current = head;
            return current.next ? head = current.next : (head = new Constructor(), tail = head), current.next = null, current;
          }
          function release(obj) {
            tail.next = obj, tail = obj;
          }
          return {
            get,
            release
          };
        }
        module.exports = reusify;
      }
    }), require_queue = __commonJS({
      "node_modules/fastq/queue.js"(exports, module) {
        "use strict";
        var reusify = require_reusify();
        function fastqueue(context, worker, _concurrency) {
          if (typeof context == "function" && (_concurrency = worker, worker = context, context = null), !(_concurrency >= 1))
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          var cache3 = reusify(Task), queueHead = null, queueTail = null, _running = 0, errorHandler = null, self = {
            push: push2,
            drain: noop22,
            saturated: noop22,
            pause,
            paused: !1,
            get concurrency() {
              return _concurrency;
            },
            set concurrency(value) {
              if (!(value >= 1))
                throw new Error("fastqueue concurrency must be equal to or greater than 1");
              if (_concurrency = value, !self.paused)
                for (; queueHead && _running < _concurrency; )
                  _running++, release();
            },
            running,
            resume,
            idle,
            length,
            getQueue,
            unshift,
            empty: noop22,
            kill,
            killAndDrain,
            error
          };
          return self;
          function running() {
            return _running;
          }
          function pause() {
            self.paused = !0;
          }
          function length() {
            for (var current = queueHead, counter = 0; current; )
              current = current.next, counter++;
            return counter;
          }
          function getQueue() {
            for (var current = queueHead, tasks = []; current; )
              tasks.push(current.value), current = current.next;
            return tasks;
          }
          function resume() {
            if (self.paused) {
              if (self.paused = !1, queueHead === null) {
                _running++, release();
                return;
              }
              for (; queueHead && _running < _concurrency; )
                _running++, release();
            }
          }
          function idle() {
            return _running === 0 && self.length() === 0;
          }
          function push2(value, done) {
            var current = cache3.get();
            current.context = context, current.release = release, current.value = value, current.callback = done || noop22, current.errorHandler = errorHandler, _running >= _concurrency || self.paused ? queueTail ? (queueTail.next = current, queueTail = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
          }
          function unshift(value, done) {
            var current = cache3.get();
            current.context = context, current.release = release, current.value = value, current.callback = done || noop22, current.errorHandler = errorHandler, _running >= _concurrency || self.paused ? queueHead ? (current.next = queueHead, queueHead = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
          }
          function release(holder) {
            holder && cache3.release(holder);
            var next = queueHead;
            next && _running <= _concurrency ? self.paused ? _running-- : (queueTail === queueHead && (queueTail = null), queueHead = next.next, next.next = null, worker.call(context, next.value, next.worked), queueTail === null && self.empty()) : --_running === 0 && self.drain();
          }
          function kill() {
            queueHead = null, queueTail = null, self.drain = noop22;
          }
          function killAndDrain() {
            queueHead = null, queueTail = null, self.drain(), self.drain = noop22;
          }
          function error(handler) {
            errorHandler = handler;
          }
        }
        function noop22() {
        }
        function Task() {
          this.value = null, this.callback = noop22, this.next = null, this.release = noop22, this.context = null, this.errorHandler = null;
          var self = this;
          this.worked = function(err, result) {
            var callback = self.callback, errorHandler = self.errorHandler, val = self.value;
            self.value = null, self.callback = noop22, self.errorHandler && errorHandler(err, val), callback.call(self.context, err, result), self.release(self);
          };
        }
        function queueAsPromised(context, worker, _concurrency) {
          typeof context == "function" && (_concurrency = worker, worker = context, context = null);
          function asyncWrapper(arg, cb) {
            worker.call(this, arg).then(function(res) {
              cb(null, res);
            }, cb);
          }
          var queue = fastqueue(context, asyncWrapper, _concurrency), pushCb = queue.push, unshiftCb = queue.unshift;
          return queue.push = push2, queue.unshift = unshift, queue.drained = drained, queue;
          function push2(value) {
            var p = new Promise(function(resolve3, reject) {
              pushCb(value, function(err, result) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve3(result);
              });
            });
            return p.catch(noop22), p;
          }
          function unshift(value) {
            var p = new Promise(function(resolve3, reject) {
              unshiftCb(value, function(err, result) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve3(result);
              });
            });
            return p.catch(noop22), p;
          }
          function drained() {
            var p = new Promise(function(resolve3) {
              process.nextTick(function() {
                if (queue.idle())
                  resolve3();
                else {
                  var previousDrain = queue.drain;
                  queue.drain = function() {
                    typeof previousDrain == "function" && previousDrain(), resolve3(), queue.drain = previousDrain;
                  };
                }
              });
            });
            return p;
          }
        }
        module.exports = fastqueue, module.exports.promise = queueAsPromised;
      }
    }), require_common2 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
        function isFatalError(settings, error) {
          return settings.errorFilter === null ? !0 : !settings.errorFilter(error);
        }
        exports.isFatalError = isFatalError;
        function isAppliedFilter(filter2, value) {
          return filter2 === null || filter2(value);
        }
        exports.isAppliedFilter = isAppliedFilter;
        function replacePathSegmentSeparator(filepath, separator) {
          return filepath.split(/[/\\]/).join(separator);
        }
        exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
        function joinPathSegments(a, b, separator) {
          return a === "" ? b : a.endsWith(separator) ? a + b : a + separator + b;
        }
        exports.joinPathSegments = joinPathSegments;
      }
    }), require_reader = __commonJS({
      "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var common = require_common2(), Reader = class {
          constructor(_root, _settings) {
            this._root = _root, this._settings = _settings, this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
          }
        };
        exports.default = Reader;
      }
    }), require_async3 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var events_1 = __require("events"), fsScandir = require_out2(), fastq = require_queue(), common = require_common2(), reader_1 = require_reader(), AsyncReader = class extends reader_1.default {
          constructor(_root, _settings) {
            super(_root, _settings), this._settings = _settings, this._scandir = fsScandir.scandir, this._emitter = new events_1.EventEmitter(), this._queue = fastq(this._worker.bind(this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
              this._isFatalError || this._emitter.emit("end");
            };
          }
          read() {
            return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
              this._pushToQueue(this._root, this._settings.basePath);
            }), this._emitter;
          }
          get isDestroyed() {
            return this._isDestroyed;
          }
          destroy() {
            if (this._isDestroyed)
              throw new Error("The reader is already destroyed");
            this._isDestroyed = !0, this._queue.killAndDrain();
          }
          onEntry(callback) {
            this._emitter.on("entry", callback);
          }
          onError(callback) {
            this._emitter.once("error", callback);
          }
          onEnd(callback) {
            this._emitter.once("end", callback);
          }
          _pushToQueue(directory, base) {
            let queueItem = { directory, base };
            this._queue.push(queueItem, (error) => {
              error !== null && this._handleError(error);
            });
          }
          _worker(item, done) {
            this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
              if (error !== null) {
                done(error, void 0);
                return;
              }
              for (let entry of entries)
                this._handleEntry(entry, item.base);
              done(null, void 0);
            });
          }
          _handleError(error) {
            this._isDestroyed || !common.isFatalError(this._settings, error) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", error));
          }
          _handleEntry(entry, base) {
            if (this._isDestroyed || this._isFatalError)
              return;
            let fullpath = entry.path;
            base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._emitEntry(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
          }
          _emitEntry(entry) {
            this._emitter.emit("entry", entry);
          }
        };
        exports.default = AsyncReader;
      }
    }), require_async4 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var async_1 = require_async3(), AsyncProvider = class {
          constructor(_root, _settings) {
            this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._storage = [];
          }
          read(callback) {
            this._reader.onError((error) => {
              callFailureCallback(callback, error);
            }), this._reader.onEntry((entry) => {
              this._storage.push(entry);
            }), this._reader.onEnd(() => {
              callSuccessCallback(callback, this._storage);
            }), this._reader.read();
          }
        };
        exports.default = AsyncProvider;
        function callFailureCallback(callback, error) {
          callback(error);
        }
        function callSuccessCallback(callback, entries) {
          callback(null, entries);
        }
      }
    }), require_stream2 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var stream_1 = __require("stream"), async_1 = require_async3(), StreamProvider = class {
          constructor(_root, _settings) {
            this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._stream = new stream_1.Readable({
              objectMode: !0,
              read: () => {
              },
              destroy: () => {
                this._reader.isDestroyed || this._reader.destroy();
              }
            });
          }
          read() {
            return this._reader.onError((error) => {
              this._stream.emit("error", error);
            }), this._reader.onEntry((entry) => {
              this._stream.push(entry);
            }), this._reader.onEnd(() => {
              this._stream.push(null);
            }), this._reader.read(), this._stream;
          }
        };
        exports.default = StreamProvider;
      }
    }), require_sync3 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fsScandir = require_out2(), common = require_common2(), reader_1 = require_reader(), SyncReader = class extends reader_1.default {
          constructor() {
            super(...arguments), this._scandir = fsScandir.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
          }
          read() {
            return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
          }
          _pushToQueue(directory, base) {
            this._queue.add({ directory, base });
          }
          _handleQueue() {
            for (let item of this._queue.values())
              this._handleDirectory(item.directory, item.base);
          }
          _handleDirectory(directory, base) {
            try {
              let entries = this._scandir(directory, this._settings.fsScandirSettings);
              for (let entry of entries)
                this._handleEntry(entry, base);
            } catch (error) {
              this._handleError(error);
            }
          }
          _handleError(error) {
            if (common.isFatalError(this._settings, error))
              throw error;
          }
          _handleEntry(entry, base) {
            let fullpath = entry.path;
            base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._pushToStorage(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
          }
          _pushToStorage(entry) {
            this._storage.push(entry);
          }
        };
        exports.default = SyncReader;
      }
    }), require_sync4 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var sync_1 = require_sync3(), SyncProvider = class {
          constructor(_root, _settings) {
            this._root = _root, this._settings = _settings, this._reader = new sync_1.default(this._root, this._settings);
          }
          read() {
            return this._reader.read();
          }
        };
        exports.default = SyncProvider;
      }
    }), require_settings3 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var path15 = __require("path"), fsScandir = require_out2(), Settings = class {
          constructor(_options = {}) {
            this._options = _options, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path15.sep), this.fsScandirSettings = new fsScandir.Settings({
              followSymbolicLinks: this._options.followSymbolicLinks,
              fs: this._options.fs,
              pathSegmentSeparator: this._options.pathSegmentSeparator,
              stats: this._options.stats,
              throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
            });
          }
          _getValue(option, value) {
            return option ?? value;
          }
        };
        exports.default = Settings;
      }
    }), require_out3 = __commonJS({
      "node_modules/@nodelib/fs.walk/out/index.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
        var async_1 = require_async4(), stream_1 = require_stream2(), sync_1 = require_sync4(), settings_1 = require_settings3();
        exports.Settings = settings_1.default;
        function walk(directory, optionsOrSettingsOrCallback, callback) {
          if (typeof optionsOrSettingsOrCallback == "function") {
            new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
            return;
          }
          new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
        }
        exports.walk = walk;
        function walkSync(directory, optionsOrSettings) {
          let settings = getSettings(optionsOrSettings);
          return new sync_1.default(directory, settings).read();
        }
        exports.walkSync = walkSync;
        function walkStream(directory, optionsOrSettings) {
          let settings = getSettings(optionsOrSettings);
          return new stream_1.default(directory, settings).read();
        }
        exports.walkStream = walkStream;
        function getSettings(settingsOrOptions = {}) {
          return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
        }
      }
    }), require_reader2 = __commonJS({
      "node_modules/fast-glob/out/readers/reader.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var path15 = __require("path"), fsStat = require_out(), utils2 = require_utils3(), Reader = class {
          constructor(_settings) {
            this._settings = _settings, this._fsStatSettings = new fsStat.Settings({
              followSymbolicLink: this._settings.followSymbolicLinks,
              fs: this._settings.fs,
              throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
            });
          }
          _getFullEntryPath(filepath) {
            return path15.resolve(this._settings.cwd, filepath);
          }
          _makeEntry(stats, pattern) {
            let entry = {
              name: pattern,
              path: pattern,
              dirent: utils2.fs.createDirentFromStats(pattern, stats)
            };
            return this._settings.stats && (entry.stats = stats), entry;
          }
          _isFatalError(error) {
            return !utils2.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
          }
        };
        exports.default = Reader;
      }
    }), require_stream3 = __commonJS({
      "node_modules/fast-glob/out/readers/stream.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var stream_1 = __require("stream"), fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderStream = class extends reader_1.default {
          constructor() {
            super(...arguments), this._walkStream = fsWalk.walkStream, this._stat = fsStat.stat;
          }
          dynamic(root2, options8) {
            return this._walkStream(root2, options8);
          }
          static(patterns, options8) {
            let filepaths = patterns.map(this._getFullEntryPath, this), stream = new stream_1.PassThrough({ objectMode: !0 });
            stream._write = (index, _enc, done) => this._getEntry(filepaths[index], patterns[index], options8).then((entry) => {
              entry !== null && options8.entryFilter(entry) && stream.push(entry), index === filepaths.length - 1 && stream.end(), done();
            }).catch(done);
            for (let i = 0; i < filepaths.length; i++)
              stream.write(i);
            return stream;
          }
          _getEntry(filepath, pattern, options8) {
            return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
              if (options8.errorFilter(error))
                return null;
              throw error;
            });
          }
          _getStat(filepath) {
            return new Promise((resolve3, reject) => {
              this._stat(filepath, this._fsStatSettings, (error, stats) => error === null ? resolve3(stats) : reject(error));
            });
          }
        };
        exports.default = ReaderStream;
      }
    }), require_async5 = __commonJS({
      "node_modules/fast-glob/out/readers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fsWalk = require_out3(), reader_1 = require_reader2(), stream_1 = require_stream3(), ReaderAsync = class extends reader_1.default {
          constructor() {
            super(...arguments), this._walkAsync = fsWalk.walk, this._readerStream = new stream_1.default(this._settings);
          }
          dynamic(root2, options8) {
            return new Promise((resolve3, reject) => {
              this._walkAsync(root2, options8, (error, entries) => {
                error === null ? resolve3(entries) : reject(error);
              });
            });
          }
          async static(patterns, options8) {
            let entries = [], stream = this._readerStream.static(patterns, options8);
            return new Promise((resolve3, reject) => {
              stream.once("error", reject), stream.on("data", (entry) => entries.push(entry)), stream.once("end", () => resolve3(entries));
            });
          }
        };
        exports.default = ReaderAsync;
      }
    }), require_matcher = __commonJS({
      "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var utils2 = require_utils3(), Matcher = class {
          constructor(_patterns, _settings, _micromatchOptions) {
            this._patterns = _patterns, this._settings = _settings, this._micromatchOptions = _micromatchOptions, this._storage = [], this._fillStorage();
          }
          _fillStorage() {
            for (let pattern of this._patterns) {
              let segments = this._getPatternSegments(pattern), sections = this._splitSegmentsIntoSections(segments);
              this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
              });
            }
          }
          _getPatternSegments(pattern) {
            return utils2.pattern.getPatternParts(pattern, this._micromatchOptions).map((part) => utils2.pattern.isDynamicPattern(part, this._settings) ? {
              dynamic: !0,
              pattern: part,
              patternRe: utils2.pattern.makeRe(part, this._micromatchOptions)
            } : {
              dynamic: !1,
              pattern: part
            });
          }
          _splitSegmentsIntoSections(segments) {
            return utils2.array.splitWhen(segments, (segment) => segment.dynamic && utils2.pattern.hasGlobStar(segment.pattern));
          }
        };
        exports.default = Matcher;
      }
    }), require_partial = __commonJS({
      "node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var matcher_1 = require_matcher(), PartialMatcher = class extends matcher_1.default {
          match(filepath) {
            let parts = filepath.split("/"), levels = parts.length, patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
            for (let pattern of patterns) {
              let section = pattern.sections[0];
              if (!pattern.complete && levels > section.length || parts.every((part, index) => {
                let segment = pattern.segments[index];
                return !!(segment.dynamic && segment.patternRe.test(part) || !segment.dynamic && segment.pattern === part);
              }))
                return !0;
            }
            return !1;
          }
        };
        exports.default = PartialMatcher;
      }
    }), require_deep = __commonJS({
      "node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var utils2 = require_utils3(), partial_1 = require_partial(), DeepFilter = class {
          constructor(_settings, _micromatchOptions) {
            this._settings = _settings, this._micromatchOptions = _micromatchOptions;
          }
          getFilter(basePath, positive, negative) {
            let matcher = this._getMatcher(positive), negativeRe = this._getNegativePatternsRe(negative);
            return (entry) => this._filter(basePath, entry, matcher, negativeRe);
          }
          _getMatcher(patterns) {
            return new partial_1.default(patterns, this._settings, this._micromatchOptions);
          }
          _getNegativePatternsRe(patterns) {
            let affectDepthOfReadingPatterns = patterns.filter(utils2.pattern.isAffectDepthOfReadingPattern);
            return utils2.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
          }
          _filter(basePath, entry, matcher, negativeRe) {
            if (this._isSkippedByDeep(basePath, entry.path) || this._isSkippedSymbolicLink(entry))
              return !1;
            let filepath = utils2.path.removeLeadingDotSegment(entry.path);
            return this._isSkippedByPositivePatterns(filepath, matcher) ? !1 : this._isSkippedByNegativePatterns(filepath, negativeRe);
          }
          _isSkippedByDeep(basePath, entryPath) {
            return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
          }
          _getEntryLevel(basePath, entryPath) {
            let entryPathDepth = entryPath.split("/").length;
            if (basePath === "")
              return entryPathDepth;
            let basePathDepth = basePath.split("/").length;
            return entryPathDepth - basePathDepth;
          }
          _isSkippedSymbolicLink(entry) {
            return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
          }
          _isSkippedByPositivePatterns(entryPath, matcher) {
            return !this._settings.baseNameMatch && !matcher.match(entryPath);
          }
          _isSkippedByNegativePatterns(entryPath, patternsRe) {
            return !utils2.pattern.matchAny(entryPath, patternsRe);
          }
        };
        exports.default = DeepFilter;
      }
    }), require_entry = __commonJS({
      "node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var utils2 = require_utils3(), EntryFilter = class {
          constructor(_settings, _micromatchOptions) {
            this._settings = _settings, this._micromatchOptions = _micromatchOptions, this.index = /* @__PURE__ */ new Map();
          }
          getFilter(positive, negative) {
            let [absoluteNegative, relativeNegative] = utils2.pattern.partitionAbsoluteAndRelative(negative), patterns = {
              positive: {
                all: utils2.pattern.convertPatternsToRe(positive, this._micromatchOptions)
              },
              negative: {
                absolute: utils2.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 })),
                relative: utils2.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }))
              }
            };
            return (entry) => this._filter(entry, patterns);
          }
          _filter(entry, patterns) {
            let filepath = utils2.path.removeLeadingDotSegment(entry.path);
            if (this._settings.unique && this._isDuplicateEntry(filepath) || this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry))
              return !1;
            let isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());
            return this._settings.unique && isMatched && this._createIndexRecord(filepath), isMatched;
          }
          _isDuplicateEntry(filepath) {
            return this.index.has(filepath);
          }
          _createIndexRecord(filepath) {
            this.index.set(filepath, void 0);
          }
          _onlyFileFilter(entry) {
            return this._settings.onlyFiles && !entry.dirent.isFile();
          }
          _onlyDirectoryFilter(entry) {
            return this._settings.onlyDirectories && !entry.dirent.isDirectory();
          }
          _isMatchToPatternsSet(filepath, patterns, isDirectory2) {
            return !(!this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory2) || this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory2) || this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory2));
          }
          _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory2) {
            if (patternsRe.length === 0)
              return !1;
            let fullpath = utils2.path.makeAbsolute(this._settings.cwd, filepath);
            return this._isMatchToPatterns(fullpath, patternsRe, isDirectory2);
          }
          _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
            if (patternsRe.length === 0)
              return !1;
            let isMatched = utils2.pattern.matchAny(filepath, patternsRe);
            return !isMatched && isDirectory2 ? utils2.pattern.matchAny(filepath + "/", patternsRe) : isMatched;
          }
        };
        exports.default = EntryFilter;
      }
    }), require_error = __commonJS({
      "node_modules/fast-glob/out/providers/filters/error.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var utils2 = require_utils3(), ErrorFilter = class {
          constructor(_settings) {
            this._settings = _settings;
          }
          getFilter() {
            return (error) => this._isNonFatalError(error);
          }
          _isNonFatalError(error) {
            return utils2.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
          }
        };
        exports.default = ErrorFilter;
      }
    }), require_entry2 = __commonJS({
      "node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var utils2 = require_utils3(), EntryTransformer = class {
          constructor(_settings) {
            this._settings = _settings;
          }
          getTransformer() {
            return (entry) => this._transform(entry);
          }
          _transform(entry) {
            let filepath = entry.path;
            return this._settings.absolute && (filepath = utils2.path.makeAbsolute(this._settings.cwd, filepath), filepath = utils2.path.unixify(filepath)), this._settings.markDirectories && entry.dirent.isDirectory() && (filepath += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, entry), { path: filepath }) : filepath;
          }
        };
        exports.default = EntryTransformer;
      }
    }), require_provider = __commonJS({
      "node_modules/fast-glob/out/providers/provider.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var path15 = __require("path"), deep_1 = require_deep(), entry_1 = require_entry(), error_1 = require_error(), entry_2 = require_entry2(), Provider = class {
          constructor(_settings) {
            this._settings = _settings, this.errorFilter = new error_1.default(this._settings), this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new entry_2.default(this._settings);
          }
          _getRootDirectory(task) {
            return path15.resolve(this._settings.cwd, task.base);
          }
          _getReaderOptions(task) {
            let basePath = task.base === "." ? "" : task.base;
            return {
              basePath,
              pathSegmentSeparator: "/",
              concurrency: this._settings.concurrency,
              deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
              entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
              errorFilter: this.errorFilter.getFilter(),
              followSymbolicLinks: this._settings.followSymbolicLinks,
              fs: this._settings.fs,
              stats: this._settings.stats,
              throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
              transform: this.entryTransformer.getTransformer()
            };
          }
          _getMicromatchOptions() {
            return {
              dot: this._settings.dot,
              matchBase: this._settings.baseNameMatch,
              nobrace: !this._settings.braceExpansion,
              nocase: !this._settings.caseSensitiveMatch,
              noext: !this._settings.extglob,
              noglobstar: !this._settings.globstar,
              posix: !0,
              strictSlashes: !1
            };
          }
        };
        exports.default = Provider;
      }
    }), require_async6 = __commonJS({
      "node_modules/fast-glob/out/providers/async.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var async_1 = require_async5(), provider_1 = require_provider(), ProviderAsync = class extends provider_1.default {
          constructor() {
            super(...arguments), this._reader = new async_1.default(this._settings);
          }
          async read(task) {
            let root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task);
            return (await this.api(root2, task, options8)).map((entry) => options8.transform(entry));
          }
          api(root2, task, options8) {
            return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
          }
        };
        exports.default = ProviderAsync;
      }
    }), require_stream4 = __commonJS({
      "node_modules/fast-glob/out/providers/stream.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var stream_1 = __require("stream"), stream_2 = require_stream3(), provider_1 = require_provider(), ProviderStream = class extends provider_1.default {
          constructor() {
            super(...arguments), this._reader = new stream_2.default(this._settings);
          }
          read(task) {
            let root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task), source2 = this.api(root2, task, options8), destination = new stream_1.Readable({ objectMode: !0, read: () => {
            } });
            return source2.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options8.transform(entry))).once("end", () => destination.emit("end")), destination.once("close", () => source2.destroy()), destination;
          }
          api(root2, task, options8) {
            return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
          }
        };
        exports.default = ProviderStream;
      }
    }), require_sync5 = __commonJS({
      "node_modules/fast-glob/out/readers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderSync = class extends reader_1.default {
          constructor() {
            super(...arguments), this._walkSync = fsWalk.walkSync, this._statSync = fsStat.statSync;
          }
          dynamic(root2, options8) {
            return this._walkSync(root2, options8);
          }
          static(patterns, options8) {
            let entries = [];
            for (let pattern of patterns) {
              let filepath = this._getFullEntryPath(pattern), entry = this._getEntry(filepath, pattern, options8);
              entry === null || !options8.entryFilter(entry) || entries.push(entry);
            }
            return entries;
          }
          _getEntry(filepath, pattern, options8) {
            try {
              let stats = this._getStat(filepath);
              return this._makeEntry(stats, pattern);
            } catch (error) {
              if (options8.errorFilter(error))
                return null;
              throw error;
            }
          }
          _getStat(filepath) {
            return this._statSync(filepath, this._fsStatSettings);
          }
        };
        exports.default = ReaderSync;
      }
    }), require_sync6 = __commonJS({
      "node_modules/fast-glob/out/providers/sync.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var sync_1 = require_sync5(), provider_1 = require_provider(), ProviderSync = class extends provider_1.default {
          constructor() {
            super(...arguments), this._reader = new sync_1.default(this._settings);
          }
          read(task) {
            let root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task);
            return this.api(root2, task, options8).map(options8.transform);
          }
          api(root2, task, options8) {
            return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
          }
        };
        exports.default = ProviderSync;
      }
    }), require_settings4 = __commonJS({
      "node_modules/fast-glob/out/settings.js"(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }), exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
        var fs4 = __require("fs"), os = __require("os"), CPU_COUNT = Math.max(os.cpus().length, 1);
        exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
          lstat: fs4.lstat,
          lstatSync: fs4.lstatSync,
          stat: fs4.stat,
          statSync: fs4.statSync,
          readdir: fs4.readdir,
          readdirSync: fs4.readdirSync
        };
        var Settings = class {
          constructor(_options = {}) {
            this._options = _options, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
          }
          _getValue(option, value) {
            return option === void 0 ? value : option;
          }
          _getFileSystemMethods(methods = {}) {
            return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
          }
        };
        exports.default = Settings;
      }
    }), require_out4 = __commonJS({
      "node_modules/fast-glob/out/index.js"(exports, module) {
        "use strict";
        var taskManager = require_tasks(), async_1 = require_async6(), stream_1 = require_stream4(), sync_1 = require_sync6(), settings_1 = require_settings4(), utils2 = require_utils3();
        async function FastGlob(source2, options8) {
          assertPatternsInput(source2);
          let works = getWorks(source2, async_1.default, options8), result = await Promise.all(works);
          return utils2.array.flatten(result);
        }
        (function(FastGlob2) {
          FastGlob2.glob = FastGlob2, FastGlob2.globSync = sync, FastGlob2.globStream = stream, FastGlob2.async = FastGlob2;
          function sync(source2, options8) {
            assertPatternsInput(source2);
            let works = getWorks(source2, sync_1.default, options8);
            return utils2.array.flatten(works);
          }
          FastGlob2.sync = sync;
          function stream(source2, options8) {
            assertPatternsInput(source2);
            let works = getWorks(source2, stream_1.default, options8);
            return utils2.stream.merge(works);
          }
          FastGlob2.stream = stream;
          function generateTasks(source2, options8) {
            assertPatternsInput(source2);
            let patterns = [].concat(source2), settings = new settings_1.default(options8);
            return taskManager.generate(patterns, settings);
          }
          FastGlob2.generateTasks = generateTasks;
          function isDynamicPattern(source2, options8) {
            assertPatternsInput(source2);
            let settings = new settings_1.default(options8);
            return utils2.pattern.isDynamicPattern(source2, settings);
          }
          FastGlob2.isDynamicPattern = isDynamicPattern;
          function escapePath(source2) {
            return assertPatternsInput(source2), utils2.path.escape(source2);
          }
          FastGlob2.escapePath = escapePath;
          function convertPathToPattern(source2) {
            return assertPatternsInput(source2), utils2.path.convertPathToPattern(source2);
          }
          FastGlob2.convertPathToPattern = convertPathToPattern;
          let posix;
          (function(posix2) {
            function escapePath2(source2) {
              return assertPatternsInput(source2), utils2.path.escapePosixPath(source2);
            }
            posix2.escapePath = escapePath2;
            function convertPathToPattern2(source2) {
              return assertPatternsInput(source2), utils2.path.convertPosixPathToPattern(source2);
            }
            posix2.convertPathToPattern = convertPathToPattern2;
          })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
          let win32;
          (function(win322) {
            function escapePath2(source2) {
              return assertPatternsInput(source2), utils2.path.escapeWindowsPath(source2);
            }
            win322.escapePath = escapePath2;
            function convertPathToPattern2(source2) {
              return assertPatternsInput(source2), utils2.path.convertWindowsPathToPattern(source2);
            }
            win322.convertPathToPattern = convertPathToPattern2;
          })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
        })(FastGlob || (FastGlob = {}));
        function getWorks(source2, _Provider, options8) {
          let patterns = [].concat(source2), settings = new settings_1.default(options8), tasks = taskManager.generate(patterns, settings), provider = new _Provider(settings);
          return tasks.map(provider.read, provider);
        }
        function assertPatternsInput(input) {
          if (![].concat(input).every((item) => utils2.string.isString(item) && !utils2.string.isEmpty(item)))
            throw new TypeError("Patterns must be a string (non empty) or an array of strings");
        }
        module.exports = FastGlob;
      }
    }), require_picocolors = __commonJS({
      "node_modules/picocolors/picocolors.js"(exports, module) {
        var p = process || {}, argv = p.argv || [], env = p.env || {}, isColorSupported2 = !(env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI), formatter = (open, close, replace = open) => (input) => {
          let string = "" + input, index = string.indexOf(close, open.length);
          return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
        }, replaceClose = (string, close, replace, index) => {
          let result = "", cursor22 = 0;
          do
            result += string.substring(cursor22, index) + replace, cursor22 = index + close.length, index = string.indexOf(close, cursor22);
          while (~index);
          return result + string.substring(cursor22);
        }, createColors2 = (enabled = isColorSupported2) => {
          let f = enabled ? formatter : () => String;
          return {
            isColorSupported: enabled,
            reset: f("\x1B[0m", "\x1B[0m"),
            bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
            dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
            italic: f("\x1B[3m", "\x1B[23m"),
            underline: f("\x1B[4m", "\x1B[24m"),
            inverse: f("\x1B[7m", "\x1B[27m"),
            hidden: f("\x1B[8m", "\x1B[28m"),
            strikethrough: f("\x1B[9m", "\x1B[29m"),
            black: f("\x1B[30m", "\x1B[39m"),
            red: f("\x1B[31m", "\x1B[39m"),
            green: f("\x1B[32m", "\x1B[39m"),
            yellow: f("\x1B[33m", "\x1B[39m"),
            blue: f("\x1B[34m", "\x1B[39m"),
            magenta: f("\x1B[35m", "\x1B[39m"),
            cyan: f("\x1B[36m", "\x1B[39m"),
            white: f("\x1B[37m", "\x1B[39m"),
            gray: f("\x1B[90m", "\x1B[39m"),
            bgBlack: f("\x1B[40m", "\x1B[49m"),
            bgRed: f("\x1B[41m", "\x1B[49m"),
            bgGreen: f("\x1B[42m", "\x1B[49m"),
            bgYellow: f("\x1B[43m", "\x1B[49m"),
            bgBlue: f("\x1B[44m", "\x1B[49m"),
            bgMagenta: f("\x1B[45m", "\x1B[49m"),
            bgCyan: f("\x1B[46m", "\x1B[49m"),
            bgWhite: f("\x1B[47m", "\x1B[49m"),
            blackBright: f("\x1B[90m", "\x1B[39m"),
            redBright: f("\x1B[91m", "\x1B[39m"),
            greenBright: f("\x1B[92m", "\x1B[39m"),
            yellowBright: f("\x1B[93m", "\x1B[39m"),
            blueBright: f("\x1B[94m", "\x1B[39m"),
            magentaBright: f("\x1B[95m", "\x1B[39m"),
            cyanBright: f("\x1B[96m", "\x1B[39m"),
            whiteBright: f("\x1B[97m", "\x1B[39m"),
            bgBlackBright: f("\x1B[100m", "\x1B[49m"),
            bgRedBright: f("\x1B[101m", "\x1B[49m"),
            bgGreenBright: f("\x1B[102m", "\x1B[49m"),
            bgYellowBright: f("\x1B[103m", "\x1B[49m"),
            bgBlueBright: f("\x1B[104m", "\x1B[49m"),
            bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
            bgCyanBright: f("\x1B[106m", "\x1B[49m"),
            bgWhiteBright: f("\x1B[107m", "\x1B[49m")
          };
        };
        module.exports = createColors2(), module.exports.createColors = createColors2;
      }
    }), require_debug = __commonJS({
      "node_modules/semver/internal/debug.js"(exports, module) {
        "use strict";
        var debug = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        };
        module.exports = debug;
      }
    }), require_constants4 = __commonJS({
      "node_modules/semver/internal/constants.js"(exports, module) {
        "use strict";
        var SEMVER_SPEC_VERSION = "2.0.0", MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
        9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6, RELEASE_TYPES = [
          "major",
          "premajor",
          "minor",
          "preminor",
          "patch",
          "prepatch",
          "prerelease"
        ];
        module.exports = {
          MAX_LENGTH,
          MAX_SAFE_COMPONENT_LENGTH,
          MAX_SAFE_BUILD_LENGTH,
          MAX_SAFE_INTEGER,
          RELEASE_TYPES,
          SEMVER_SPEC_VERSION,
          FLAG_INCLUDE_PRERELEASE: 1,
          FLAG_LOOSE: 2
        };
      }
    }), require_re = __commonJS({
      "node_modules/semver/internal/re.js"(exports, module) {
        "use strict";
        var {
          MAX_SAFE_COMPONENT_LENGTH,
          MAX_SAFE_BUILD_LENGTH,
          MAX_LENGTH
        } = require_constants4(), debug = require_debug();
        exports = module.exports = {};
        var re = exports.re = [], safeRe = exports.safeRe = [], src = exports.src = [], safeSrc = exports.safeSrc = [], t = exports.t = {}, R = 0, LETTERDASHNUMBER = "[a-zA-Z0-9-]", safeRegexReplacements = [
          ["\\s", 1],
          ["\\d", MAX_LENGTH],
          [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
        ], makeSafeRegex = (value) => {
          for (let [token2, max] of safeRegexReplacements)
            value = value.split(`${token2}*`).join(`${token2}{0,${max}}`).split(`${token2}+`).join(`${token2}{1,${max}}`);
          return value;
        }, createToken = (name, value, isGlobal) => {
          let safe = makeSafeRegex(value), index = R++;
          debug(name, index, value), t[name] = index, src[index] = value, safeSrc[index] = safe, re[index] = new RegExp(value, isGlobal ? "g" : void 0), safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
        };
        createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "\\d+"), createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), createToken("COERCEPLAIN", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`), createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`), createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`), createToken("COERCERTL", src[t.COERCE], !0), createToken("COERCERTLFULL", src[t.COERCEFULL], !0), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), exports.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), exports.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), exports.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }
    }), require_parse_options = __commonJS({
      "node_modules/semver/internal/parse-options.js"(exports, module) {
        "use strict";
        var looseOption = Object.freeze({ loose: !0 }), emptyOpts = Object.freeze({}), parseOptions = (options8) => options8 ? typeof options8 != "object" ? looseOption : options8 : emptyOpts;
        module.exports = parseOptions;
      }
    }), require_identifiers = __commonJS({
      "node_modules/semver/internal/identifiers.js"(exports, module) {
        "use strict";
        var numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
          if (typeof a == "number" && typeof b == "number")
            return a === b ? 0 : a < b ? -1 : 1;
          let anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }, rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
        module.exports = {
          compareIdentifiers,
          rcompareIdentifiers
        };
      }
    }), require_semver = __commonJS({
      "node_modules/semver/classes/semver.js"(exports, module) {
        "use strict";
        var debug = require_debug(), { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4(), { safeRe: re, t } = require_re(), parseOptions = require_parse_options(), { compareIdentifiers } = require_identifiers(), SemVer = class _SemVer {
          constructor(version, options8) {
            if (options8 = parseOptions(options8), version instanceof _SemVer) {
              if (version.loose === !!options8.loose && version.includePrerelease === !!options8.includePrerelease)
                return version;
              version = version.version;
            } else if (typeof version != "string")
              throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
            if (version.length > MAX_LENGTH)
              throw new TypeError(
                `version is longer than ${MAX_LENGTH} characters`
              );
            debug("SemVer", version, options8), this.options = options8, this.loose = !!options8.loose, this.includePrerelease = !!options8.includePrerelease;
            let m = version.trim().match(options8.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!m)
              throw new TypeError(`Invalid Version: ${version}`);
            if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m[4] ? this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                let num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof _SemVer)) {
              if (typeof other == "string" && other === this.version)
                return 0;
              other = new _SemVer(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof _SemVer || (other = new _SemVer(other, this.options)), this.major < other.major ? -1 : this.major > other.major ? 1 : this.minor < other.minor ? -1 : this.minor > other.minor ? 1 : this.patch < other.patch ? -1 : this.patch > other.patch ? 1 : 0;
          }
          comparePre(other) {
            if (other instanceof _SemVer || (other = new _SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              let a = this.prerelease[i], b = other.prerelease[i];
              if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a === b)
                continue;
              return compareIdentifiers(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof _SemVer || (other = new _SemVer(other, this.options));
            let i = 0;
            do {
              let a = this.build[i], b = other.build[i];
              if (debug("build compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a === b)
                continue;
              return compareIdentifiers(a, b);
            } while (++i);
          }
          // preminor will bump the version up to the next minor release, and immediately
          // down to pre-release. premajor and prepatch work the same way.
          inc(release, identifier, identifierBase) {
            if (release.startsWith("pre")) {
              if (!identifier && identifierBase === !1)
                throw new Error("invalid increment argument: identifier is empty");
              if (identifier) {
                let match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier)
                  throw new Error(`invalid identifier: ${identifier}`);
              }
            }
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
                break;
              // If the input is a non-prerelease version, this acts the same as
              // prepatch.
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
                break;
              case "release":
                if (this.prerelease.length === 0)
                  throw new Error(`version ${this.raw} is not a prerelease`);
                this.prerelease.length = 0;
                break;
              case "major":
                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              // This probably shouldn't be used publicly.
              // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
              case "pre": {
                let base = Number(identifierBase) ? 1 : 0;
                if (this.prerelease.length === 0)
                  this.prerelease = [base];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                  if (i === -1) {
                    if (identifier === this.prerelease.join(".") && identifierBase === !1)
                      throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(base);
                  }
                }
                if (identifier) {
                  let prerelease = [identifier, base];
                  identifierBase === !1 && (prerelease = [identifier]), compareIdentifiers(this.prerelease[0], identifier) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        };
        module.exports = SemVer;
      }
    }), require_compare = __commonJS({
      "node_modules/semver/functions/compare.js"(exports, module) {
        "use strict";
        var SemVer = require_semver(), compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
        module.exports = compare;
      }
    }), require_gte = __commonJS({
      "node_modules/semver/functions/gte.js"(exports, module) {
        "use strict";
        var compare = require_compare(), gte = (a, b, loose) => compare(a, b, loose) >= 0;
        module.exports = gte;
      }
    }), require_pseudomap = __commonJS({
      "node_modules/pseudomap/pseudomap.js"(exports, module) {
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        module.exports = PseudoMap;
        function PseudoMap(set2) {
          if (!(this instanceof PseudoMap))
            throw new TypeError("Constructor PseudoMap requires 'new'");
          if (this.clear(), set2)
            if (set2 instanceof PseudoMap || typeof Map == "function" && set2 instanceof Map)
              set2.forEach(function(value, key2) {
                this.set(key2, value);
              }, this);
            else if (Array.isArray(set2))
              set2.forEach(function(kv) {
                this.set(kv[0], kv[1]);
              }, this);
            else
              throw new TypeError("invalid argument");
        }
        PseudoMap.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this, Object.keys(this._data).forEach(function(k) {
            k !== "size" && fn.call(thisp, this._data[k].value, this._data[k].key);
          }, this);
        }, PseudoMap.prototype.has = function(k) {
          return !!find(this._data, k);
        }, PseudoMap.prototype.get = function(k) {
          var res = find(this._data, k);
          return res && res.value;
        }, PseudoMap.prototype.set = function(k, v) {
          set(this._data, k, v);
        }, PseudoMap.prototype.delete = function(k) {
          var res = find(this._data, k);
          res && (delete this._data[res._index], this._data.size--);
        }, PseudoMap.prototype.clear = function() {
          var data = /* @__PURE__ */ Object.create(null);
          data.size = 0, Object.defineProperty(this, "_data", {
            value: data,
            enumerable: !1,
            configurable: !0,
            writable: !1
          });
        }, Object.defineProperty(PseudoMap.prototype, "size", {
          get: function() {
            return this._data.size;
          },
          set: function(n) {
          },
          enumerable: !0,
          configurable: !0
        }), PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
          throw new Error("iterators are not implemented in this version");
        };
        function same(a, b) {
          return a === b || a !== a && b !== b;
        }
        function Entry(k, v, i) {
          this.key = k, this.value = v, this._index = i;
        }
        function find(data, k) {
          for (var i = 0, s = "_" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i++)
            if (same(data[key2].key, k))
              return data[key2];
        }
        function set(data, k, v) {
          for (var i = 0, s = "_" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i++)
            if (same(data[key2].key, k)) {
              data[key2].value = v;
              return;
            }
          data.size++, data[key2] = new Entry(k, v, key2);
        }
      }
    }), require_map = __commonJS({
      "node_modules/pseudomap/map.js"(exports, module) {
        process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test" && (process.env.TEST_PSEUDOMAP = "true"), typeof Map == "function" && !process.env.TEST_PSEUDOMAP ? module.exports = Map : module.exports = require_pseudomap();
      }
    }), require_yallist = __commonJS({
      "node_modules/yallist/yallist.js"(exports, module) {
        module.exports = Yallist, Yallist.Node = Node, Yallist.create = Yallist;
        function Yallist(list) {
          var self = this;
          if (self instanceof Yallist || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function")
            list.forEach(function(item) {
              self.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self.push(arguments[i]);
          return self;
        }
        Yallist.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null;
        }, Yallist.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push2(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++)
            walker = walker.next;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
            walker = walker.prev;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.head; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.tail; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else if (this.head)
            walker = this.head.next, acc = this.head.value;
          else
            throw new TypeError("Reduce of empty list with no initial value");
          for (var i = 0; walker !== null; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else if (this.tail)
            walker = this.tail.prev, acc = this.tail.value;
          else
            throw new TypeError("Reduce of empty list with no initial value");
          for (var i = this.length - 1; walker !== null; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist.prototype.slice = function(from, to) {
          to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; walker !== null && i < from; i++)
            walker = walker.next;
          for (; walker !== null && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.sliceReverse = function(from, to) {
          to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
            walker = walker.prev;
          for (; walker !== null && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        function push2(self, item) {
          self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
        }
        function unshift(self, item) {
          self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
        }
        function Node(value, prev, next, list) {
          if (!(this instanceof Node))
            return new Node(value, prev, next, list);
          this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
      }
    }), require_lru_cache = __commonJS({
      "node_modules/editorconfig/node_modules/lru-cache/index.js"(exports, module) {
        "use strict";
        module.exports = LRUCache;
        var Map2 = require_map(), util2 = __require("util"), Yallist = require_yallist(), hasSymbol = typeof Symbol == "function" && process.env._nodeLRUCacheForceNoSymbol !== "1", makeSymbol;
        hasSymbol ? makeSymbol = function(key2) {
          return Symbol(key2);
        } : makeSymbol = function(key2) {
          return "_" + key2;
        };
        var MAX = makeSymbol("max"), LENGTH = makeSymbol("length"), LENGTH_CALCULATOR = makeSymbol("lengthCalculator"), ALLOW_STALE = makeSymbol("allowStale"), MAX_AGE = makeSymbol("maxAge"), DISPOSE = makeSymbol("dispose"), NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet"), LRU_LIST = makeSymbol("lruList"), CACHE = makeSymbol("cache");
        function naiveLength() {
          return 1;
        }
        function LRUCache(options8) {
          if (!(this instanceof LRUCache))
            return new LRUCache(options8);
          typeof options8 == "number" && (options8 = { max: options8 }), options8 || (options8 = {});
          var max = this[MAX] = options8.max;
          (!max || typeof max != "number" || max <= 0) && (this[MAX] = 1 / 0);
          var lc = options8.length || naiveLength;
          typeof lc != "function" && (lc = naiveLength), this[LENGTH_CALCULATOR] = lc, this[ALLOW_STALE] = options8.stale || !1, this[MAX_AGE] = options8.maxAge || 0, this[DISPOSE] = options8.dispose, this[NO_DISPOSE_ON_SET] = options8.noDisposeOnSet || !1, this.reset();
        }
        Object.defineProperty(LRUCache.prototype, "max", {
          set: function(mL) {
            (!mL || typeof mL != "number" || mL <= 0) && (mL = 1 / 0), this[MAX] = mL, trim2(this);
          },
          get: function() {
            return this[MAX];
          },
          enumerable: !0
        }), Object.defineProperty(LRUCache.prototype, "allowStale", {
          set: function(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          },
          get: function() {
            return this[ALLOW_STALE];
          },
          enumerable: !0
        }), Object.defineProperty(LRUCache.prototype, "maxAge", {
          set: function(mA) {
            (!mA || typeof mA != "number" || mA < 0) && (mA = 0), this[MAX_AGE] = mA, trim2(this);
          },
          get: function() {
            return this[MAX_AGE];
          },
          enumerable: !0
        }), Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
          set: function(lC) {
            typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach(function(hit) {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
            }, this)), trim2(this);
          },
          get: function() {
            return this[LENGTH_CALCULATOR];
          },
          enumerable: !0
        }), Object.defineProperty(LRUCache.prototype, "length", {
          get: function() {
            return this[LENGTH];
          },
          enumerable: !0
        }), Object.defineProperty(LRUCache.prototype, "itemCount", {
          get: function() {
            return this[LRU_LIST].length;
          },
          enumerable: !0
        }), LRUCache.prototype.rforEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this[LRU_LIST].tail; walker !== null; ) {
            var prev = walker.prev;
            forEachStep(this, fn, walker, thisp), walker = prev;
          }
        };
        function forEachStep(self, fn, node, thisp) {
          var hit = node.value;
          isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
        }
        LRUCache.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this[LRU_LIST].head; walker !== null; ) {
            var next = walker.next;
            forEachStep(this, fn, walker, thisp), walker = next;
          }
        }, LRUCache.prototype.keys = function() {
          return this[LRU_LIST].toArray().map(function(k) {
            return k.key;
          }, this);
        }, LRUCache.prototype.values = function() {
          return this[LRU_LIST].toArray().map(function(k) {
            return k.value;
          }, this);
        }, LRUCache.prototype.reset = function() {
          this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(function(hit) {
            this[DISPOSE](hit.key, hit.value);
          }, this), this[CACHE] = new Map2(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
        }, LRUCache.prototype.dump = function() {
          return this[LRU_LIST].map(function(hit) {
            if (!isStale(this, hit))
              return {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
              };
          }, this).toArray().filter(function(h) {
            return h;
          });
        }, LRUCache.prototype.dumpLru = function() {
          return this[LRU_LIST];
        }, LRUCache.prototype.inspect = function(n, opts) {
          var str = "LRUCache {", extras = !1, as = this[ALLOW_STALE];
          as && (str += `
  allowStale: true`, extras = !0);
          var max = this[MAX];
          max && max !== 1 / 0 && (extras && (str += ","), str += `
  max: ` + util2.inspect(max, opts), extras = !0);
          var maxAge = this[MAX_AGE];
          maxAge && (extras && (str += ","), str += `
  maxAge: ` + util2.inspect(maxAge, opts), extras = !0);
          var lc = this[LENGTH_CALCULATOR];
          lc && lc !== naiveLength && (extras && (str += ","), str += `
  length: ` + util2.inspect(this[LENGTH], opts), extras = !0);
          var didFirst = !1;
          return this[LRU_LIST].forEach(function(item) {
            didFirst ? str += `,
  ` : (extras && (str += `,
`), didFirst = !0, str += `
  `);
            var key2 = util2.inspect(item.key).split(`
`).join(`
  `), val = { value: item.value };
            item.maxAge !== maxAge && (val.maxAge = item.maxAge), lc !== naiveLength && (val.length = item.length), isStale(this, item) && (val.stale = !0), val = util2.inspect(val, opts).split(`
`).join(`
  `), str += key2 + " => " + val;
          }), (didFirst || extras) && (str += `
`), str += "}", str;
        }, LRUCache.prototype.set = function(key2, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          var now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key2);
          if (this[CACHE].has(key2)) {
            if (len > this[MAX])
              return del(this, this[CACHE].get(key2)), !1;
            var node = this[CACHE].get(key2), item = node.value;
            return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key2, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key2), trim2(this), !0;
          }
          var hit = new Entry(key2, value, len, now, maxAge);
          return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key2, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key2, this[LRU_LIST].head), trim2(this), !0);
        }, LRUCache.prototype.has = function(key2) {
          if (!this[CACHE].has(key2)) return !1;
          var hit = this[CACHE].get(key2).value;
          return !isStale(this, hit);
        }, LRUCache.prototype.get = function(key2) {
          return get(this, key2, !0);
        }, LRUCache.prototype.peek = function(key2) {
          return get(this, key2, !1);
        }, LRUCache.prototype.pop = function() {
          var node = this[LRU_LIST].tail;
          return node ? (del(this, node), node.value) : null;
        }, LRUCache.prototype.del = function(key2) {
          del(this, this[CACHE].get(key2));
        }, LRUCache.prototype.load = function(arr) {
          this.reset();
          for (var now = Date.now(), l = arr.length - 1; l >= 0; l--) {
            var hit = arr[l], expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              var maxAge = expiresAt - now;
              maxAge > 0 && this.set(hit.k, hit.v, maxAge);
            }
          }
        }, LRUCache.prototype.prune = function() {
          var self = this;
          this[CACHE].forEach(function(value, key2) {
            get(self, key2, !1);
          });
        };
        function get(self, key2, doUse) {
          var node = self[CACHE].get(key2);
          if (node) {
            var hit = node.value;
            isStale(self, hit) ? (del(self, node), self[ALLOW_STALE] || (hit = void 0)) : doUse && self[LRU_LIST].unshiftNode(node), hit && (hit = hit.value);
          }
          return hit;
        }
        function isStale(self, hit) {
          if (!hit || !hit.maxAge && !self[MAX_AGE])
            return !1;
          var stale = !1, diff = Date.now() - hit.now;
          return hit.maxAge ? stale = diff > hit.maxAge : stale = self[MAX_AGE] && diff > self[MAX_AGE], stale;
        }
        function trim2(self) {
          if (self[LENGTH] > self[MAX])
            for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
              var prev = walker.prev;
              del(self, walker), walker = prev;
            }
        }
        function del(self, node) {
          if (node) {
            var hit = node.value;
            self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
          }
        }
        function Entry(key2, value, length, now, maxAge) {
          this.key = key2, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
        }
      }
    }), require_sigmund = __commonJS({
      "node_modules/sigmund/sigmund.js"(exports, module) {
        module.exports = sigmund;
        function sigmund(subject, maxSessions) {
          maxSessions = maxSessions || 10;
          var notes = [], analysis = "", RE = RegExp;
          function psychoAnalyze(subject2, session) {
            if (!(session > maxSessions) && !(typeof subject2 == "function" || typeof subject2 > "u")) {
              if (typeof subject2 != "object" || !subject2 || subject2 instanceof RE) {
                analysis += subject2;
                return;
              }
              notes.indexOf(subject2) !== -1 || session === maxSessions || (notes.push(subject2), analysis += "{", Object.keys(subject2).forEach(function(issue, _, __) {
                if (issue.charAt(0) !== "_") {
                  var to = typeof subject2[issue];
                  to === "function" || to === "undefined" || (analysis += issue, psychoAnalyze(subject2[issue], session + 1));
                }
              }));
            }
          }
          return psychoAnalyze(subject, 0), analysis;
        }
      }
    }), require_fnmatch = __commonJS({
      "node_modules/editorconfig/src/lib/fnmatch.js"(exports, module) {
        var platform = typeof process == "object" ? process.platform : "win32";
        module ? module.exports = minimatch : exports.minimatch = minimatch, minimatch.Minimatch = Minimatch;
        var LRU = require_lru_cache(), cache3 = minimatch.cache = new LRU({ max: 100 }), GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, sigmund = require_sigmund(), path15 = __require("path"), qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials = charSet("().*{}+?[]^$\\!");
        function charSet(s) {
          return s.split("").reduce(function(set, c2) {
            return set[c2] = !0, set;
          }, {});
        }
        var slashSplit = /\/+/;
        minimatch.monkeyPatch = monkeyPatch;
        function monkeyPatch() {
          var desc = Object.getOwnPropertyDescriptor(String.prototype, "match"), orig = desc.value;
          desc.value = function(p) {
            return p instanceof Minimatch ? p.match(this) : orig.call(this, p);
          }, Object.defineProperty(String.prototype, desc);
        }
        minimatch.filter = filter2;
        function filter2(pattern, options8) {
          return options8 = options8 || {}, function(p, i, list) {
            return minimatch(p, pattern, options8);
          };
        }
        function ext(a, b) {
          a = a || {}, b = b || {};
          var t = {};
          return Object.keys(b).forEach(function(k) {
            t[k] = b[k];
          }), Object.keys(a).forEach(function(k) {
            t[k] = a[k];
          }), t;
        }
        minimatch.defaults = function(def) {
          if (!def || !Object.keys(def).length) return minimatch;
          var orig = minimatch, m = function(p, pattern, options8) {
            return orig.minimatch(p, pattern, ext(def, options8));
          };
          return m.Minimatch = function(pattern, options8) {
            return new orig.Minimatch(pattern, ext(def, options8));
          }, m;
        }, Minimatch.defaults = function(def) {
          return !def || !Object.keys(def).length ? Minimatch : minimatch.defaults(def).Minimatch;
        };
        function minimatch(p, pattern, options8) {
          if (typeof pattern != "string")
            throw new TypeError("glob pattern string required");
          return options8 || (options8 = {}), !options8.nocomment && pattern.charAt(0) === "#" ? !1 : pattern.trim() === "" ? p === "" : new Minimatch(pattern, options8).match(p);
        }
        function Minimatch(pattern, options8) {
          if (!(this instanceof Minimatch))
            return new Minimatch(pattern, options8, cache3);
          if (typeof pattern != "string")
            throw new TypeError("glob pattern string required");
          options8 || (options8 = {}), platform === "win32" && (pattern = pattern.split("\\").join("/"));
          var cacheKey = pattern + `
` + sigmund(options8), cached = minimatch.cache.get(cacheKey);
          if (cached) return cached;
          minimatch.cache.set(cacheKey, this), this.options = options8, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.make();
        }
        Minimatch.prototype.make = make;
        function make() {
          if (!this._made) {
            var pattern = this.pattern, options8 = this.options;
            if (!options8.nocomment && pattern.charAt(0) === "#") {
              this.comment = !0;
              return;
            }
            if (!pattern) {
              this.empty = !0;
              return;
            }
            this.parseNegate();
            var set = this.globSet = this.braceExpand();
            options8.debug && console.error(this.pattern, set), set = this.globParts = set.map(function(s) {
              return s.split(slashSplit);
            }), options8.debug && console.error(this.pattern, set), set = set.map(function(s, si, set2) {
              return s.map(this.parse, this);
            }, this), options8.debug && console.error(this.pattern, set), set = set.filter(function(s) {
              return s.indexOf(!1) === -1;
            }), options8.debug && console.error(this.pattern, set), this.set = set;
          }
        }
        Minimatch.prototype.parseNegate = parseNegate;
        function parseNegate() {
          var pattern = this.pattern, negate = !1, options8 = this.options, negateOffset = 0;
          if (!options8.nonegate) {
            for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++)
              negate = !negate, negateOffset++;
            negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
          }
        }
        minimatch.braceExpand = function(pattern, options8) {
          return new Minimatch(pattern, options8).braceExpand();
        }, Minimatch.prototype.braceExpand = braceExpand;
        function braceExpand(pattern, options8) {
          if (options8 = options8 || this.options, pattern = typeof pattern > "u" ? this.pattern : pattern, typeof pattern > "u")
            throw new Error("undefined pattern");
          if (options8.nobrace || !pattern.match(/\{.*\}/))
            return [pattern];
          var escaping = !1;
          if (pattern.charAt(0) !== "{") {
            for (var prefix = null, i = 0, l = pattern.length; i < l; i++) {
              var c2 = pattern.charAt(i);
              if (c2 === "\\")
                escaping = !escaping;
              else if (c2 === "{" && !escaping) {
                prefix = pattern.substr(0, i);
                break;
              }
            }
            if (prefix === null)
              return [pattern];
            var tail = braceExpand(pattern.substr(i), options8);
            return tail.map(function(t) {
              return prefix + t;
            });
          }
          var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/);
          if (numset) {
            for (var suf = braceExpand(pattern.substr(numset[0].length), options8), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set = [], i = start; i != end + inc; i += inc)
              for (var ii = 0, ll = suf.length; ii < ll; ii++)
                set.push(i + suf[ii]);
            return set;
          }
          var i = 1, depth = 1, set = [], member = "", sawEnd = !1, escaping = !1;
          function addMember() {
            set.push(member), member = "";
          }
          FOR: for (i = 1, l = pattern.length; i < l; i++) {
            var c2 = pattern.charAt(i);
            if (escaping)
              escaping = !1, member += "\\" + c2;
            else
              switch (c2) {
                case "\\":
                  escaping = !0;
                  continue;
                case "{":
                  depth++, member += "{";
                  continue;
                case "}":
                  if (depth--, depth === 0) {
                    addMember(), i++;
                    break FOR;
                  } else {
                    member += c2;
                    continue;
                  }
                case ",":
                  depth === 1 ? addMember() : member += c2;
                  continue;
                default:
                  member += c2;
                  continue;
              }
          }
          if (depth !== 0)
            return braceExpand("\\" + pattern, options8);
          var suf = braceExpand(pattern.substr(i), options8), addBraces = set.length === 1;
          set = set.map(function(p) {
            return braceExpand(p, options8);
          }), set = set.reduce(function(l2, r) {
            return l2.concat(r);
          }), addBraces && (set = set.map(function(s) {
            return "{" + s + "}";
          }));
          for (var ret = [], i = 0, l = set.length; i < l; i++)
            for (var ii = 0, ll = suf.length; ii < ll; ii++)
              ret.push(set[i] + suf[ii]);
          return ret;
        }
        Minimatch.prototype.parse = parse7;
        var SUBPARSE = {};
        function parse7(pattern, isSub) {
          var options8 = this.options;
          if (!options8.noglobstar && pattern === "**") return GLOBSTAR;
          if (pattern === "") return "";
          var re = "", hasMagic = !!options8.nocase, escaping = !1, patternListStack = [], plType, stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options8.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
          function clearStateChar() {
            if (stateChar) {
              switch (stateChar) {
                case "*":
                  re += star, hasMagic = !0;
                  break;
                case "?":
                  re += qmark, hasMagic = !0;
                  break;
                default:
                  re += "\\" + stateChar;
                  break;
              }
              stateChar = !1;
            }
          }
          for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {
            if (options8.debug && console.error("%s	%s %s %j", pattern, i, re, c2), escaping && reSpecials[c2]) {
              re += "\\" + c2, escaping = !1;
              continue;
            }
            switch (c2) {
              case "/":
                return !1;
              case "\\":
                clearStateChar(), escaping = !0;
                continue;
              // the various stateChar values
              // for the "extglob" stuff.
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                if (options8.debug && console.error("%s	%s %s %j <-- stateChar", pattern, i, re, c2), inClass) {
                  c2 === "!" && i === classStart + 1 && (c2 = "^"), re += c2;
                  continue;
                }
                clearStateChar(), stateChar = c2, options8.noext && clearStateChar();
                continue;
              case "(":
                if (inClass) {
                  re += "(";
                  continue;
                }
                if (!stateChar) {
                  re += "\\(";
                  continue;
                }
                plType = stateChar, patternListStack.push({
                  type: plType,
                  start: i - 1,
                  reStart: re.length
                }), re += stateChar === "!" ? "(?:(?!" : "(?:", stateChar = !1;
                continue;
              case ")":
                if (inClass || !patternListStack.length) {
                  re += "\\)";
                  continue;
                }
                switch (hasMagic = !0, re += ")", plType = patternListStack.pop().type, plType) {
                  case "!":
                    re += "[^/]*?)";
                    break;
                  case "?":
                  case "+":
                  case "*":
                    re += plType;
                  case "@":
                    break;
                }
                continue;
              case "|":
                if (inClass || !patternListStack.length || escaping) {
                  re += "\\|", escaping = !1;
                  continue;
                }
                re += "|";
                continue;
              // these are mostly the same in regexp and glob
              case "[":
                if (clearStateChar(), inClass) {
                  re += "\\" + c2;
                  continue;
                }
                inClass = !0, classStart = i, reClassStart = re.length, re += c2;
                continue;
              case "]":
                if (i === classStart + 1 || !inClass) {
                  re += "\\" + c2, escaping = !1;
                  continue;
                }
                hasMagic = !0, inClass = !1, re += c2;
                continue;
              default:
                clearStateChar(), escaping ? escaping = !1 : reSpecials[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
            }
          }
          if (inClass) {
            var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1];
          }
          for (var pl; pl = patternListStack.pop(); ) {
            var tail = re.slice(pl.reStart + 3);
            tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_, $1, $2) {
              return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
            });
            var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
            hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
          }
          clearStateChar(), escaping && (re += "\\\\");
          var addPatternStart = !1;
          switch (re.charAt(0)) {
            case ".":
            case "[":
            case "(":
              addPatternStart = !0;
          }
          if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart + re), isSub === SUBPARSE)
            return [re, hasMagic];
          if (!hasMagic)
            return globUnescape(pattern);
          var flags = options8.nocase ? "i" : "", regExp = new RegExp("^" + re + "$", flags);
          return regExp._glob = pattern, regExp._src = re, regExp;
        }
        minimatch.makeRe = function(pattern, options8) {
          return new Minimatch(pattern, options8 || {}).makeRe();
        }, Minimatch.prototype.makeRe = makeRe;
        function makeRe() {
          if (this.regexp || this.regexp === !1) return this.regexp;
          var set = this.set;
          if (!set.length) return this.regexp = !1;
          var options8 = this.options, twoStar = options8.noglobstar ? star : options8.dot ? twoStarDot : twoStarNoDot, flags = options8.nocase ? "i" : "", re = set.map(function(pattern) {
            return pattern.map(function(p) {
              return p === GLOBSTAR ? twoStar : typeof p == "string" ? regExpEscape(p) : p._src;
            }).join("\\/");
          }).join("|");
          re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
          try {
            return this.regexp = new RegExp(re, flags);
          } catch {
            return this.regexp = !1;
          }
        }
        minimatch.match = function(list, pattern, options8) {
          var mm = new Minimatch(pattern, options8);
          return list = list.filter(function(f) {
            return mm.match(f);
          }), options8.nonull && !list.length && list.push(pattern), list;
        }, Minimatch.prototype.match = match;
        function match(f, partial) {
          if (this.comment) return !1;
          if (this.empty) return f === "";
          if (f === "/" && partial) return !0;
          var options8 = this.options;
          platform === "win32" && (f = f.split("\\").join("/")), f = f.split(slashSplit), options8.debug && console.error(this.pattern, "split", f);
          for (var set = this.set, i = 0, l = set.length; i < l; i++) {
            var pattern = set[i], hit = this.matchOne(f, pattern, partial);
            if (hit)
              return options8.flipNegate ? !0 : !this.negate;
          }
          return options8.flipNegate ? !1 : this.negate;
        }
        Minimatch.prototype.matchOne = function(file, pattern, partial) {
          var options8 = this.options;
          options8.debug && console.error(
            "matchOne",
            {
              this: this,
              file,
              pattern
            }
          ), options8.matchBase && pattern.length === 1 && (file = path15.basename(file.join("/")).split("/")), options8.debug && console.error("matchOne", file.length, pattern.length);
          for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            options8.debug && console.error("matchOne loop");
            var p = pattern[pi], f = file[fi];
            if (options8.debug && console.error(pattern, p, f), p === !1) return !1;
            if (p === GLOBSTAR) {
              options8.debug && console.error("GLOBSTAR", [pattern, p, f]);
              var fr = fi, pr = pi + 1;
              if (pr === pl) {
                for (options8.debug && console.error("** at the end"); fi < fl; fi++)
                  if (file[fi] === "." || file[fi] === ".." || !options8.dot && file[fi].charAt(0) === ".") return !1;
                return !0;
              }
              WHILE: for (; fr < fl; ) {
                var swallowee = file[fr];
                if (options8.debug && console.error(
                  `
globstar while`,
                  file,
                  fr,
                  pattern,
                  pr,
                  swallowee
                ), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
                  return options8.debug && console.error("globstar found match!", fr, fl, swallowee), !0;
                if (swallowee === "." || swallowee === ".." || !options8.dot && swallowee.charAt(0) === ".") {
                  options8.debug && console.error("dot detected!", file, fr, pattern, pr);
                  break WHILE;
                }
                options8.debug && console.error("globstar swallow a segment, and continue"), fr++;
              }
              return !!(partial && fr === fl);
            }
            var hit;
            if (typeof p == "string" ? (options8.nocase ? hit = f.toLowerCase() === p.toLowerCase() : hit = f === p, options8.debug && console.error("string match", p, f, hit)) : (hit = f.match(p), options8.debug && console.error("pattern match", p, f, hit)), !hit) return !1;
          }
          if (fi === fl && pi === pl)
            return !0;
          if (fi === fl)
            return partial;
          if (pi === pl) {
            var emptyFileEnd = fi === fl - 1 && file[fi] === "";
            return emptyFileEnd;
          }
          throw new Error("wtf?");
        };
        function globUnescape(s) {
          return s.replace(/\\(.)/g, "$1");
        }
        function regExpEscape(s) {
          return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
      }
    }), require_ini = __commonJS({
      "node_modules/editorconfig/src/lib/ini.js"(exports) {
        "use strict";
        var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve3, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve3(result.value) : new P(function(resolve4) {
                resolve4(result.value);
              }).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }, __generator = exports && exports.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            for (; _; ) try {
              if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  return _.label++, { value: op[1], done: !1 };
                case 5:
                  _.label++, y = op[1], op = [0];
                  continue;
                case 7:
                  op = _.ops.pop(), _.trys.pop();
                  continue;
                default:
                  if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1], t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2], _.ops.push(op);
                    break;
                  }
                  t[2] && _.ops.pop(), _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e], y = 0;
            } finally {
              f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: !0 };
          }
        }, __importStar = exports && exports.__importStar || function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
          return result.default = mod, result;
        };
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fs4 = __importStar(__require("fs")), regex = {
          section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
          param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
          comment: /^\s*[#;].*$/
        };
        function parse7(file) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, new Promise(function(resolve3, reject) {
                fs4.readFile(file, "utf8", function(err, data) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve3(parseString2(data));
                });
              })];
            });
          });
        }
        exports.parse = parse7;
        function parseSync(file) {
          return parseString2(fs4.readFileSync(file, "utf8"));
        }
        exports.parseSync = parseSync;
        function parseString2(data) {
          var sectionBody = {}, sectionName = null, value = [[sectionName, sectionBody]], lines = data.split(/\r\n|\r|\n/);
          return lines.forEach(function(line3) {
            var match;
            regex.comment.test(line3) || (regex.param.test(line3) ? (match = line3.match(regex.param), sectionBody[match[1]] = match[2]) : regex.section.test(line3) && (match = line3.match(regex.section), sectionName = match[1], sectionBody = {}, value.push([sectionName, sectionBody])));
          }), value;
        }
        exports.parseString = parseString2;
      }
    }), require_package = __commonJS({
      "node_modules/editorconfig/package.json"(exports, module) {
        module.exports = {
          name: "editorconfig",
          version: "0.15.3",
          description: "EditorConfig File Locator and Interpreter for Node.js",
          keywords: [
            "editorconfig",
            "core"
          ],
          main: "src/index.js",
          contributors: [
            "Hong Xu (topbug.net)",
            "Jed Mao (https://github.com/jedmao/)",
            "Trey Hunner (http://treyhunner.com)"
          ],
          directories: {
            bin: "./bin",
            lib: "./lib"
          },
          scripts: {
            clean: "rimraf dist",
            prebuild: "npm run clean",
            build: "tsc",
            pretest: "npm run lint && npm run build && npm run copy && cmake .",
            test: "ctest .",
            "pretest:ci": "npm run pretest",
            "test:ci": "ctest -VV --output-on-failure .",
            lint: "npm run eclint && npm run tslint",
            eclint: 'eclint check --indent_size ignore "src/**"',
            tslint: "tslint --project tsconfig.json --exclude package.json",
            copy: "cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib",
            prepub: "npm run lint && npm run build && npm run copy",
            pub: "npm publish ./dist"
          },
          repository: {
            type: "git",
            url: "git://github.com/editorconfig/editorconfig-core-js.git"
          },
          bugs: "https://github.com/editorconfig/editorconfig-core-js/issues",
          author: "EditorConfig Team",
          license: "MIT",
          dependencies: {
            commander: "^2.19.0",
            "lru-cache": "^4.1.5",
            semver: "^5.6.0",
            sigmund: "^1.0.1"
          },
          devDependencies: {
            "@types/mocha": "^5.2.6",
            "@types/node": "^10.12.29",
            "@types/semver": "^5.5.0",
            "cpy-cli": "^2.0.0",
            eclint: "^2.8.1",
            mocha: "^5.2.0",
            rimraf: "^2.6.3",
            should: "^13.2.3",
            tslint: "^5.13.1",
            typescript: "^3.3.3333"
          }
        };
      }
    }), require_src = __commonJS({
      "node_modules/editorconfig/src/index.js"(exports) {
        "use strict";
        var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve3, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve3(result.value) : new P(function(resolve4) {
                resolve4(result.value);
              }).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }, __generator = exports && exports.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            for (; _; ) try {
              if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  return _.label++, { value: op[1], done: !1 };
                case 5:
                  _.label++, y = op[1], op = [0];
                  continue;
                case 7:
                  op = _.ops.pop(), _.trys.pop();
                  continue;
                default:
                  if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1], t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2], _.ops.push(op);
                    break;
                  }
                  t[2] && _.ops.pop(), _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e], y = 0;
            } finally {
              f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: !0 };
          }
        }, __importStar = exports && exports.__importStar || function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
          return result.default = mod, result;
        }, __importDefault = exports && exports.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
        Object.defineProperty(exports, "__esModule", { value: !0 });
        var fs4 = __importStar(__require("fs")), path15 = __importStar(__require("path")), semver = {
          gte: require_gte()
        }, fnmatch_1 = __importDefault(require_fnmatch()), ini_1 = require_ini();
        exports.parseString = ini_1.parseString;
        var package_json_1 = __importDefault(require_package()), knownProps = {
          end_of_line: !0,
          indent_style: !0,
          indent_size: !0,
          insert_final_newline: !0,
          trim_trailing_whitespace: !0,
          charset: !0
        };
        function fnmatch(filepath, glob) {
          var matchOptions = { matchBase: !0, dot: !0, noext: !0 };
          return glob = glob.replace(/\*\*/g, "{*,**/**/**}"), fnmatch_1.default(filepath, glob, matchOptions);
        }
        function getConfigFileNames(filepath, options8) {
          var paths = [];
          do
            filepath = path15.dirname(filepath), paths.push(path15.join(filepath, options8.config));
          while (filepath !== options8.root);
          return paths;
        }
        function processMatches(matches, version) {
          return "indent_style" in matches && matches.indent_style === "tab" && !("indent_size" in matches) && semver.gte(version, "0.10.0") && (matches.indent_size = "tab"), "indent_size" in matches && !("tab_width" in matches) && matches.indent_size !== "tab" && (matches.tab_width = matches.indent_size), "indent_size" in matches && "tab_width" in matches && matches.indent_size === "tab" && (matches.indent_size = matches.tab_width), matches;
        }
        function processOptions(options8, filepath) {
          return options8 === void 0 && (options8 = {}), {
            config: options8.config || ".editorconfig",
            version: options8.version || package_json_1.default.version,
            root: path15.resolve(options8.root || path15.parse(filepath).root)
          };
        }
        function buildFullGlob(pathPrefix, glob) {
          switch (glob.indexOf("/")) {
            case -1:
              glob = "**/" + glob;
              break;
            case 0:
              glob = glob.substring(1);
              break;
            default:
              break;
          }
          return path15.join(pathPrefix, glob);
        }
        function extendProps(props, options8) {
          props === void 0 && (props = {}), options8 === void 0 && (options8 = {});
          for (var key2 in options8)
            if (options8.hasOwnProperty(key2)) {
              var value = options8[key2], key22 = key2.toLowerCase(), value2 = value;
              knownProps[key22] && (value2 = value.toLowerCase());
              try {
                value2 = JSON.parse(value);
              } catch {
              }
              (typeof value > "u" || value === null) && (value2 = String(value)), props[key22] = value2;
            }
          return props;
        }
        function parseFromConfigs(configs, filepath, options8) {
          return processMatches(configs.reverse().reduce(function(matches, file) {
            var pathPrefix = path15.dirname(file.name);
            return file.contents.forEach(function(section) {
              var glob = section[0], options22 = section[1];
              if (glob) {
                var fullGlob = buildFullGlob(pathPrefix, glob);
                fnmatch(filepath, fullGlob) && (matches = extendProps(matches, options22));
              }
            }), matches;
          }, {}), options8.version);
        }
        function getConfigsForFiles(files) {
          var configs = [];
          for (var i in files)
            if (files.hasOwnProperty(i)) {
              var file = files[i], contents = ini_1.parseString(file.contents);
              if (configs.push({
                name: file.name,
                contents
              }), (contents[0][1].root || "").toLowerCase() === "true")
                break;
            }
          return configs;
        }
        function readConfigFiles(filepaths) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, Promise.all(filepaths.map(function(name) {
                return new Promise(function(resolve3) {
                  fs4.readFile(name, "utf8", function(err, data) {
                    resolve3({
                      name,
                      contents: err ? "" : data
                    });
                  });
                });
              }))];
            });
          });
        }
        function readConfigFilesSync(filepaths) {
          var files = [], file;
          return filepaths.forEach(function(filepath) {
            try {
              file = fs4.readFileSync(filepath, "utf8");
            } catch {
              file = "";
            }
            files.push({
              name: filepath,
              contents: file
            });
          }), files;
        }
        function opts(filepath, options8) {
          options8 === void 0 && (options8 = {});
          var resolvedFilePath = path15.resolve(filepath);
          return [
            resolvedFilePath,
            processOptions(options8, resolvedFilePath)
          ];
        }
        function parseFromFiles(filepath, files, options8) {
          return options8 === void 0 && (options8 = {}), __awaiter(this, void 0, void 0, function() {
            var _a, resolvedFilePath, processedOptions;
            return __generator(this, function(_b) {
              return _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1], [2, files.then(getConfigsForFiles).then(function(configs) {
                return parseFromConfigs(configs, resolvedFilePath, processedOptions);
              })];
            });
          });
        }
        exports.parseFromFiles = parseFromFiles;
        function parseFromFilesSync(filepath, files, options8) {
          options8 === void 0 && (options8 = {});
          var _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1];
          return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
        }
        exports.parseFromFilesSync = parseFromFilesSync;
        function parse7(_filepath, _options) {
          return _options === void 0 && (_options = {}), __awaiter(this, void 0, void 0, function() {
            var _a, resolvedFilePath, processedOptions, filepaths;
            return __generator(this, function(_b) {
              return _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1], filepaths = getConfigFileNames(resolvedFilePath, processedOptions), [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {
                return parseFromConfigs(configs, resolvedFilePath, processedOptions);
              })];
            });
          });
        }
        exports.parse = parse7;
        function parseSync(_filepath, _options) {
          _options === void 0 && (_options = {});
          var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1], filepaths = getConfigFileNames(resolvedFilePath, processedOptions), files = readConfigFilesSync(filepaths);
          return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
        }
        exports.parseSync = parseSync;
      }
    }), require_js_tokens = __commonJS({
      "node_modules/@babel/code-frame/node_modules/js-tokens/index.js"(exports, module) {
        var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace, jsTokens2;
        RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y, NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y, WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu, LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y, MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y, SingleLineComment = /\/\/.*/y, JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y, JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y, JSXText = /[^<>{}]+/y, TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/, Newline = RegExp(LineTerminatorSequence.source), module.exports = jsTokens2 = function* (input, { jsx = !1 } = {}) {
          var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack2;
          for ({ length } = input, lastIndex = 0, lastSignificantToken = "", stack2 = [
            { tag: "JS" }
          ], braces = [], parenNesting = 0, postfixIncDec = !1; lastIndex < length; ) {
            switch (mode = stack2[stack2.length - 1], mode.tag) {
              case "JS":
              case "JSNonExpressionParen":
              case "InterpolationInTemplate":
              case "InterpolationInJSX":
                if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)) && (RegularExpressionLiteral.lastIndex = lastIndex, match = RegularExpressionLiteral.exec(input))) {
                  lastIndex = RegularExpressionLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
                    type: "RegularExpressionLiteral",
                    value: match[0],
                    closed: match[1] !== void 0 && match[1] !== "\\"
                  };
                  continue;
                }
                if (Punctuator.lastIndex = lastIndex, match = Punctuator.exec(input)) {
                  switch (punctuator = match[0], nextLastIndex = Punctuator.lastIndex, nextLastSignificantToken = punctuator, punctuator) {
                    case "(":
                      lastSignificantToken === "?NonExpressionParenKeyword" && stack2.push({
                        tag: "JSNonExpressionParen",
                        nesting: parenNesting
                      }), parenNesting++, postfixIncDec = !1;
                      break;
                    case ")":
                      parenNesting--, postfixIncDec = !0, mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting && (stack2.pop(), nextLastSignificantToken = "?NonExpressionParenEnd", postfixIncDec = !1);
                      break;
                    case "{":
                      Punctuator.lastIndex = 0, isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)), braces.push(isExpression), postfixIncDec = !1;
                      break;
                    case "}":
                      switch (mode.tag) {
                        case "InterpolationInTemplate":
                          if (braces.length === mode.nesting) {
                            Template.lastIndex = lastIndex, match = Template.exec(input), lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", postfixIncDec = !1, yield {
                              type: "TemplateMiddle",
                              value: match[0]
                            }) : (stack2.pop(), postfixIncDec = !0, yield {
                              type: "TemplateTail",
                              value: match[0],
                              closed: match[1] === "`"
                            });
                            continue;
                          }
                          break;
                        case "InterpolationInJSX":
                          if (braces.length === mode.nesting) {
                            stack2.pop(), lastIndex += 1, lastSignificantToken = "}", yield {
                              type: "JSXPunctuator",
                              value: "}"
                            };
                            continue;
                          }
                      }
                      postfixIncDec = braces.pop(), nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                      break;
                    case "]":
                      postfixIncDec = !0;
                      break;
                    case "++":
                    case "--":
                      nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                      break;
                    case "<":
                      if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                        stack2.push({ tag: "JSXTag" }), lastIndex += 1, lastSignificantToken = "<", yield {
                          type: "JSXPunctuator",
                          value: punctuator
                        };
                        continue;
                      }
                      postfixIncDec = !1;
                      break;
                    default:
                      postfixIncDec = !1;
                  }
                  lastIndex = nextLastIndex, lastSignificantToken = nextLastSignificantToken, yield {
                    type: "Punctuator",
                    value: punctuator
                  };
                  continue;
                }
                if (Identifier.lastIndex = lastIndex, match = Identifier.exec(input)) {
                  switch (lastIndex = Identifier.lastIndex, nextLastSignificantToken = match[0], match[0]) {
                    case "for":
                    case "if":
                    case "while":
                    case "with":
                      lastSignificantToken !== "." && lastSignificantToken !== "?." && (nextLastSignificantToken = "?NonExpressionParenKeyword");
                  }
                  lastSignificantToken = nextLastSignificantToken, postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]), yield {
                    type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
                    value: match[0]
                  };
                  continue;
                }
                if (StringLiteral.lastIndex = lastIndex, match = StringLiteral.exec(input)) {
                  lastIndex = StringLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
                    type: "StringLiteral",
                    value: match[0],
                    closed: match[2] !== void 0
                  };
                  continue;
                }
                if (NumericLiteral.lastIndex = lastIndex, match = NumericLiteral.exec(input)) {
                  lastIndex = NumericLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
                    type: "NumericLiteral",
                    value: match[0]
                  };
                  continue;
                }
                if (Template.lastIndex = lastIndex, match = Template.exec(input)) {
                  lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", stack2.push({
                    tag: "InterpolationInTemplate",
                    nesting: braces.length
                  }), postfixIncDec = !1, yield {
                    type: "TemplateHead",
                    value: match[0]
                  }) : (postfixIncDec = !0, yield {
                    type: "NoSubstitutionTemplate",
                    value: match[0],
                    closed: match[1] === "`"
                  });
                  continue;
                }
                break;
              case "JSXTag":
              case "JSXTagEnd":
                if (JSXPunctuator.lastIndex = lastIndex, match = JSXPunctuator.exec(input)) {
                  switch (lastIndex = JSXPunctuator.lastIndex, nextLastSignificantToken = match[0], match[0]) {
                    case "<":
                      stack2.push({ tag: "JSXTag" });
                      break;
                    case ">":
                      stack2.pop(), lastSignificantToken === "/" || mode.tag === "JSXTagEnd" ? (nextLastSignificantToken = "?JSX", postfixIncDec = !0) : stack2.push({ tag: "JSXChildren" });
                      break;
                    case "{":
                      stack2.push({
                        tag: "InterpolationInJSX",
                        nesting: braces.length
                      }), nextLastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1;
                      break;
                    case "/":
                      lastSignificantToken === "<" && (stack2.pop(), stack2[stack2.length - 1].tag === "JSXChildren" && stack2.pop(), stack2.push({ tag: "JSXTagEnd" }));
                  }
                  lastSignificantToken = nextLastSignificantToken, yield {
                    type: "JSXPunctuator",
                    value: match[0]
                  };
                  continue;
                }
                if (JSXIdentifier.lastIndex = lastIndex, match = JSXIdentifier.exec(input)) {
                  lastIndex = JSXIdentifier.lastIndex, lastSignificantToken = match[0], yield {
                    type: "JSXIdentifier",
                    value: match[0]
                  };
                  continue;
                }
                if (JSXString.lastIndex = lastIndex, match = JSXString.exec(input)) {
                  lastIndex = JSXString.lastIndex, lastSignificantToken = match[0], yield {
                    type: "JSXString",
                    value: match[0],
                    closed: match[2] !== void 0
                  };
                  continue;
                }
                break;
              case "JSXChildren":
                if (JSXText.lastIndex = lastIndex, match = JSXText.exec(input)) {
                  lastIndex = JSXText.lastIndex, lastSignificantToken = match[0], yield {
                    type: "JSXText",
                    value: match[0]
                  };
                  continue;
                }
                switch (input[lastIndex]) {
                  case "<":
                    stack2.push({ tag: "JSXTag" }), lastIndex++, lastSignificantToken = "<", yield {
                      type: "JSXPunctuator",
                      value: "<"
                    };
                    continue;
                  case "{":
                    stack2.push({
                      tag: "InterpolationInJSX",
                      nesting: braces.length
                    }), lastIndex++, lastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1, yield {
                      type: "JSXPunctuator",
                      value: "{"
                    };
                    continue;
                }
            }
            if (WhiteSpace.lastIndex = lastIndex, match = WhiteSpace.exec(input)) {
              lastIndex = WhiteSpace.lastIndex, yield {
                type: "WhiteSpace",
                value: match[0]
              };
              continue;
            }
            if (LineTerminatorSequence.lastIndex = lastIndex, match = LineTerminatorSequence.exec(input)) {
              lastIndex = LineTerminatorSequence.lastIndex, postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere"), yield {
                type: "LineTerminatorSequence",
                value: match[0]
              };
              continue;
            }
            if (MultiLineComment.lastIndex = lastIndex, match = MultiLineComment.exec(input)) {
              lastIndex = MultiLineComment.lastIndex, Newline.test(match[0]) && (postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere")), yield {
                type: "MultiLineComment",
                value: match[0],
                closed: match[1] !== void 0
              };
              continue;
            }
            if (SingleLineComment.lastIndex = lastIndex, match = SingleLineComment.exec(input)) {
              lastIndex = SingleLineComment.lastIndex, postfixIncDec = !1, yield {
                type: "SingleLineComment",
                value: match[0]
              };
              continue;
            }
            firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex)), lastIndex += firstCodePoint.length, lastSignificantToken = firstCodePoint, postfixIncDec = !1, yield {
              type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
              value: firstCodePoint
            };
          }
        };
      }
    }), require_readlines = __commonJS({
      "node_modules/n-readlines/readlines.js"(exports, module) {
        "use strict";
        var fs4 = __require("fs"), LineByLine = class {
          constructor(file, options8) {
            options8 = options8 || {}, options8.readChunk || (options8.readChunk = 1024), options8.newLineCharacter ? options8.newLineCharacter = options8.newLineCharacter.charCodeAt(0) : options8.newLineCharacter = 10, typeof file == "number" ? this.fd = file : this.fd = fs4.openSync(file, "r"), this.options = options8, this.newLineCharacter = options8.newLineCharacter, this.reset();
          }
          _searchInBuffer(buffer2, hexNeedle) {
            let found = -1;
            for (let i = 0; i <= buffer2.length; i++)
              if (buffer2[i] === hexNeedle) {
                found = i;
                break;
              }
            return found;
          }
          reset() {
            this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
          }
          close() {
            fs4.closeSync(this.fd), this.fd = null;
          }
          _extractLines(buffer2) {
            let line3, lines = [], bufferPosition = 0, lastNewLineBufferPosition = 0;
            for (; ; ) {
              let bufferPositionValue = buffer2[bufferPosition++];
              if (bufferPositionValue === this.newLineCharacter)
                line3 = buffer2.slice(lastNewLineBufferPosition, bufferPosition), lines.push(line3), lastNewLineBufferPosition = bufferPosition;
              else if (bufferPositionValue === void 0)
                break;
            }
            let leftovers = buffer2.slice(lastNewLineBufferPosition, bufferPosition);
            return leftovers.length && lines.push(leftovers), lines;
          }
          _readChunk(lineLeftovers) {
            let totalBytesRead = 0, bytesRead, buffers = [];
            do {
              let readBuffer = Buffer.alloc(this.options.readChunk);
              bytesRead = fs4.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition), totalBytesRead = totalBytesRead + bytesRead, this.fdPosition = this.fdPosition + bytesRead, buffers.push(readBuffer);
            } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);
            let bufferData = Buffer.concat(buffers);
            return bytesRead < this.options.readChunk && (this.eofReached = !0, bufferData = bufferData.slice(0, totalBytesRead)), totalBytesRead && (this.linesCache = this._extractLines(bufferData), lineLeftovers && (this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]))), totalBytesRead;
          }
          next() {
            if (!this.fd) return !1;
            let line3 = !1;
            if (this.eofReached && this.linesCache.length === 0)
              return line3;
            let bytesRead;
            return this.linesCache.length || (bytesRead = this._readChunk()), this.linesCache.length && (line3 = this.linesCache.shift(), line3[line3.length - 1] !== this.newLineCharacter && (bytesRead = this._readChunk(line3), bytesRead && (line3 = this.linesCache.shift()))), this.eofReached && this.linesCache.length === 0 && this.close(), line3 && line3[line3.length - 1] === this.newLineCharacter && (line3 = line3.slice(0, line3.length - 1)), line3;
          }
        };
        module.exports = LineByLine;
      }
    }), require_ignore = __commonJS({
      "node_modules/ignore/index.js"(exports, module) {
        function makeArray(subject) {
          return Array.isArray(subject) ? subject : [subject];
        }
        var UNDEFINED = void 0, EMPTY = "", SPACE = " ", ESCAPE = "\\", REGEX_TEST_BLANK_LINE = /^\s+$/, REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/, REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/, REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/, REGEX_SPLITALL_CRLF = /\r?\n/g, REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/, REGEX_TEST_TRAILING_SLASH = /\/$/, SLASH = "/", TMP_KEY_IGNORE = "node-ignore";
        typeof Symbol < "u" && (TMP_KEY_IGNORE = Symbol.for("node-ignore"));
        var KEY_IGNORE = TMP_KEY_IGNORE, define = (object, key2, value) => (Object.defineProperty(object, key2, { value }), value), REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g, RETURN_FALSE = () => !1, sanitizeRange = (range) => range.replace(
          REGEX_REGEXP_RANGE,
          (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
        ), cleanRangeBackSlash = (slashes) => {
          let { length } = slashes;
          return slashes.slice(0, length - length % 2);
        }, REPLACERS = [
          [
            // Remove BOM
            // TODO:
            // Other similar zero-width characters?
            /^\uFEFF/,
            () => EMPTY
          ],
          // > Trailing spaces are ignored unless they are quoted with backslash ("\")
          [
            // (a\ ) -> (a )
            // (a  ) -> (a)
            // (a ) -> (a)
            // (a \ ) -> (a  )
            /((?:\\\\)*?)(\\?\s+)$/,
            (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
          ],
          // Replace (\ ) with ' '
          // (\ ) -> ' '
          // (\\ ) -> '\\ '
          // (\\\ ) -> '\\ '
          [
            /(\\+?)\s/g,
            (_, m1) => {
              let { length } = m1;
              return m1.slice(0, length - length % 2) + SPACE;
            }
          ],
          // Escape metacharacters
          // which is written down by users but means special for regular expressions.
          // > There are 12 characters with special meanings:
          // > - the backslash \,
          // > - the caret ^,
          // > - the dollar sign $,
          // > - the period or dot .,
          // > - the vertical bar or pipe symbol |,
          // > - the question mark ?,
          // > - the asterisk or star *,
          // > - the plus sign +,
          // > - the opening parenthesis (,
          // > - the closing parenthesis ),
          // > - and the opening square bracket [,
          // > - the opening curly brace {,
          // > These special characters are often called "metacharacters".
          [
            /[\\$.|*+(){^]/g,
            (match) => `\\${match}`
          ],
          [
            // > a question mark (?) matches a single character
            /(?!\\)\?/g,
            () => "[^/]"
          ],
          // leading slash
          [
            // > A leading slash matches the beginning of the pathname.
            // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
            // A leading slash matches the beginning of the pathname
            /^\//,
            () => "^"
          ],
          // replace special metacharacter slash after the leading slash
          [
            /\//g,
            () => "\\/"
          ],
          [
            // > A leading "**" followed by a slash means match in all directories.
            // > For example, "**/foo" matches file or directory "foo" anywhere,
            // > the same as pattern "foo".
            // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
            // >   under directory "foo".
            // Notice that the '*'s have been replaced as '\\*'
            /^\^*\\\*\\\*\\\//,
            // '**/foo' <-> 'foo'
            () => "^(?:.*\\/)?"
          ],
          // starting
          [
            // there will be no leading '/'
            //   (which has been replaced by section "leading slash")
            // If starts with '**', adding a '^' to the regular expression also works
            /^(?=[^^])/,
            function() {
              return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
            }
          ],
          // two globstars
          [
            // Use lookahead assertions so that we could match more than one `'/**'`
            /\\\/\\\*\\\*(?=\\\/|$)/g,
            // Zero, one or several directories
            // should not use '*', or it will be replaced by the next replacer
            // Check if it is not the last `'/**'`
            (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
          ],
          // normal intermediate wildcards
          [
            // Never replace escaped '*'
            // ignore rule '\*' will match the path '*'
            // 'abc.*/' -> go
            // 'abc.*'  -> skip this rule,
            //    coz trailing single wildcard will be handed by [trailing wildcard]
            /(^|[^\\]+)(\\\*)+(?=.+)/g,
            // '*.js' matches '.js'
            // '*.js' doesn't match 'abc'
            (_, p1, p2) => {
              let unescaped = p2.replace(/\\\*/g, "[^\\/]*");
              return p1 + unescaped;
            }
          ],
          [
            // unescape, revert step 3 except for back slash
            // For example, if a user escape a '\\*',
            // after step 3, the result will be '\\\\\\*'
            /\\\\\\(?=[$.|*+(){^])/g,
            () => ESCAPE
          ],
          [
            // '\\\\' -> '\\'
            /\\\\/g,
            () => ESCAPE
          ],
          [
            // > The range notation, e.g. [a-zA-Z],
            // > can be used to match one of the characters in a range.
            // `\` is escaped by step 3
            /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
            (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" && endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]"
          ],
          // ending
          [
            // 'js' will not match 'js.'
            // 'ab' will not match 'abc'
            /(?:[^*])$/,
            // WTF!
            // https://git-scm.com/docs/gitignore
            // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
            // which re-fixes #24, #38
            // > If there is a separator at the end of the pattern then the pattern
            // > will only match directories, otherwise the pattern can match both
            // > files and directories.
            // 'js*' will not match 'a.js'
            // 'js/' will not match 'a.js'
            // 'js' will match 'a.js' and 'a.js/'
            (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
          ]
        ], REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/, MODE_IGNORE = "regex", MODE_CHECK_IGNORE = "checkRegex", UNDERSCORE = "_", TRAILING_WILD_CARD_REPLACERS = {
          [MODE_IGNORE](_, p1) {
            return `${p1 ? `${p1}[^/]+` : "[^/]*"}(?=$|\\/$)`;
          },
          [MODE_CHECK_IGNORE](_, p1) {
            return `${p1 ? `${p1}[^/]*` : "[^/]*"}(?=$|\\/$)`;
          }
        }, makeRegexPrefix = (pattern) => REPLACERS.reduce(
          (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
          pattern
        ), isString = (subject) => typeof subject == "string", checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean), IgnoreRule = class {
          constructor(pattern, mark, body, ignoreCase, negative, prefix) {
            this.pattern = pattern, this.mark = mark, this.negative = negative, define(this, "body", body), define(this, "ignoreCase", ignoreCase), define(this, "regexPrefix", prefix);
          }
          get regex() {
            let key2 = UNDERSCORE + MODE_IGNORE;
            return this[key2] ? this[key2] : this._make(MODE_IGNORE, key2);
          }
          get checkRegex() {
            let key2 = UNDERSCORE + MODE_CHECK_IGNORE;
            return this[key2] ? this[key2] : this._make(MODE_CHECK_IGNORE, key2);
          }
          _make(mode, key2) {
            let str = this.regexPrefix.replace(
              REGEX_REPLACE_TRAILING_WILDCARD,
              // It does not need to bind pattern
              TRAILING_WILD_CARD_REPLACERS[mode]
            ), regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
            return define(this, key2, regex);
          }
        }, createRule = ({
          pattern,
          mark
        }, ignoreCase) => {
          let negative = !1, body = pattern;
          body.indexOf("!") === 0 && (negative = !0, body = body.substr(1)), body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
          let regexPrefix = makeRegexPrefix(body);
          return new IgnoreRule(
            pattern,
            mark,
            body,
            ignoreCase,
            negative,
            regexPrefix
          );
        }, RuleManager = class {
          constructor(ignoreCase) {
            this._ignoreCase = ignoreCase, this._rules = [];
          }
          _add(pattern) {
            if (pattern && pattern[KEY_IGNORE]) {
              this._rules = this._rules.concat(pattern._rules._rules), this._added = !0;
              return;
            }
            if (isString(pattern) && (pattern = {
              pattern
            }), checkPattern(pattern.pattern)) {
              let rule = createRule(pattern, this._ignoreCase);
              this._added = !0, this._rules.push(rule);
            }
          }
          // @param {Array<string> | string | Ignore} pattern
          add(pattern) {
            return this._added = !1, makeArray(
              isString(pattern) ? splitPattern(pattern) : pattern
            ).forEach(this._add, this), this._added;
          }
          // Test one single path without recursively checking parent directories
          //
          // - checkUnignored `boolean` whether should check if the path is unignored,
          //   setting `checkUnignored` to `false` could reduce additional
          //   path matching.
          // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
          // @returns {TestResult} true if a file is ignored
          test(path15, checkUnignored, mode) {
            let ignored = !1, unignored = !1, matchedRule;
            this._rules.forEach((rule) => {
              let { negative } = rule;
              unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored || !rule[mode].test(path15) || (ignored = !negative, unignored = negative, matchedRule = negative ? UNDEFINED : rule);
            });
            let ret = {
              ignored,
              unignored
            };
            return matchedRule && (ret.rule = matchedRule), ret;
          }
        }, throwError = (message, Ctor) => {
          throw new Ctor(message);
        }, checkPath = (path15, originalPath, doThrow) => isString(path15) ? path15 ? checkPath.isNotRelative(path15) ? doThrow(
          `path should be a \`path.relative()\`d string, but got "${originalPath}"`,
          RangeError
        ) : !0 : doThrow("path must not be empty", TypeError) : doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        ), isNotRelative = (path15) => REGEX_TEST_INVALID_PATH.test(path15);
        checkPath.isNotRelative = isNotRelative, checkPath.convert = (p) => p;
        var Ignore = class {
          constructor({
            ignorecase = !0,
            ignoreCase = ignorecase,
            allowRelativePaths = !1
          } = {}) {
            define(this, KEY_IGNORE, !0), this._rules = new RuleManager(ignoreCase), this._strictPathCheck = !allowRelativePaths, this._initCache();
          }
          _initCache() {
            this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
          }
          add(pattern) {
            return this._rules.add(pattern) && this._initCache(), this;
          }
          // legacy
          addPattern(pattern) {
            return this.add(pattern);
          }
          // @returns {TestResult}
          _test(originalPath, cache3, checkUnignored, slices) {
            let path15 = originalPath && checkPath.convert(originalPath);
            return checkPath(
              path15,
              originalPath,
              this._strictPathCheck ? throwError : RETURN_FALSE
            ), this._t(path15, cache3, checkUnignored, slices);
          }
          checkIgnore(path15) {
            if (!REGEX_TEST_TRAILING_SLASH.test(path15))
              return this.test(path15);
            let slices = path15.split(SLASH).filter(Boolean);
            if (slices.pop(), slices.length) {
              let parent = this._t(
                slices.join(SLASH) + SLASH,
                this._testCache,
                !0,
                slices
              );
              if (parent.ignored)
                return parent;
            }
            return this._rules.test(path15, !1, MODE_CHECK_IGNORE);
          }
          _t(path15, cache3, checkUnignored, slices) {
            if (path15 in cache3)
              return cache3[path15];
            if (slices || (slices = path15.split(SLASH).filter(Boolean)), slices.pop(), !slices.length)
              return cache3[path15] = this._rules.test(path15, checkUnignored, MODE_IGNORE);
            let parent = this._t(
              slices.join(SLASH) + SLASH,
              cache3,
              checkUnignored,
              slices
            );
            return cache3[path15] = parent.ignored ? parent : this._rules.test(path15, checkUnignored, MODE_IGNORE);
          }
          ignores(path15) {
            return this._test(path15, this._ignoreCache, !1).ignored;
          }
          createFilter() {
            return (path15) => !this.ignores(path15);
          }
          filter(paths) {
            return makeArray(paths).filter(this.createFilter());
          }
          // @returns {TestResult}
          test(path15) {
            return this._test(path15, this._testCache, !0);
          }
        }, factory = (options8) => new Ignore(options8), isPathValid = (path15) => checkPath(path15 && checkPath.convert(path15), path15, RETURN_FALSE), setupWindows = () => {
          let makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
          checkPath.convert = makePosix;
          let REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
          checkPath.isNotRelative = (path15) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path15) || isNotRelative(path15);
        };
        // Detect `process` so that it can run in browsers.
        typeof process < "u" && process.platform === "win32" && setupWindows(), module.exports = factory, factory.default = factory, module.exports.isPathValid = isPathValid, define(module.exports, Symbol.for("setupWindows"), setupWindows);
      }
    }), index_exports = {};
    __export3(index_exports, {
      __debug: () => debugApis,
      __internal: () => sharedWithCli,
      check: () => check,
      clearConfigCache: () => clearCache3,
      doc: () => doc_exports,
      format: () => format2,
      formatWithCursor: () => formatWithCursor2,
      getFileInfo: () => get_file_info_default,
      getSupportInfo: () => getSupportInfo2,
      resolveConfig: () => resolveConfig,
      resolveConfigFile: () => resolveConfigFile,
      util: () => public_exports2,
      version: () => version_evaluate_default
    });
    Diff = class {
      diff(oldStr, newStr, options8 = {}) {
        let callback;
        typeof options8 == "function" ? (callback = options8, options8 = {}) : "callback" in options8 && (callback = options8.callback);
        let oldString = this.castInput(oldStr, options8), newString = this.castInput(newStr, options8), oldTokens = this.removeEmpty(this.tokenize(oldString, options8)), newTokens = this.removeEmpty(this.tokenize(newString, options8));
        return this.diffWithOptionsObj(oldTokens, newTokens, options8, callback);
      }
      diffWithOptionsObj(oldTokens, newTokens, options8, callback) {
        var _a;
        let done = (value) => {
          if (value = this.postProcess(value, options8), callback) {
            setTimeout(function() {
              callback(value);
            }, 0);
            return;
          } else
            return value;
        }, newLen = newTokens.length, oldLen = oldTokens.length, editLength = 1, maxEditLength = newLen + oldLen;
        options8.maxEditLength != null && (maxEditLength = Math.min(maxEditLength, options8.maxEditLength));
        let maxExecutionTime = (_a = options8.timeout) !== null && _a !== void 0 ? _a : 1 / 0, abortAfterTimestamp = Date.now() + maxExecutionTime, bestPath = [{ oldPos: -1, lastComponent: void 0 }], newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options8);
        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen)
          return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
        let minDiagonalToConsider = -1 / 0, maxDiagonalToConsider = 1 / 0, execEditLength = () => {
          for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
            let basePath, removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
            removePath && (bestPath[diagonalPath - 1] = void 0);
            let canAdd = !1;
            if (addPath) {
              let addPathNewPos = addPath.oldPos - diagonalPath;
              canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
            }
            let canRemove = removePath && removePath.oldPos + 1 < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos ? basePath = this.addToPath(addPath, !0, !1, 0, options8) : basePath = this.addToPath(removePath, !1, !0, 1, options8), newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options8), basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen)
              return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || !0;
            bestPath[diagonalPath] = basePath, basePath.oldPos + 1 >= oldLen && (maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1)), newPos + 1 >= newLen && (minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1));
          }
          editLength++;
        };
        if (callback)
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength || Date.now() > abortAfterTimestamp)
                return callback(void 0);
              execEditLength() || exec();
            }, 0);
          })();
        else
          for (; editLength <= maxEditLength && Date.now() <= abortAfterTimestamp; ) {
            let ret = execEditLength();
            if (ret)
              return ret;
          }
      }
      addToPath(path15, added, removed, oldPosInc, options8) {
        let last = path15.lastComponent;
        return last && !options8.oneChangePerToken && last.added === added && last.removed === removed ? {
          oldPos: path15.oldPos + oldPosInc,
          lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
        } : {
          oldPos: path15.oldPos + oldPosInc,
          lastComponent: { count: 1, added, removed, previousComponent: last }
        };
      }
      extractCommon(basePath, newTokens, oldTokens, diagonalPath, options8) {
        let newLen = newTokens.length, oldLen = oldTokens.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
        for (; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options8); )
          newPos++, oldPos++, commonCount++, options8.oneChangePerToken && (basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: !1, removed: !1 });
        return commonCount && !options8.oneChangePerToken && (basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: !1, removed: !1 }), basePath.oldPos = oldPos, newPos;
      }
      equals(left, right, options8) {
        return options8.comparator ? options8.comparator(left, right) : left === right || !!options8.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
      removeEmpty(array2) {
        let ret = [];
        for (let i = 0; i < array2.length; i++)
          array2[i] && ret.push(array2[i]);
        return ret;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      castInput(value, options8) {
        return value;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      tokenize(value, options8) {
        return Array.from(value);
      }
      join(chars) {
        return chars.join("");
      }
      postProcess(changeObjects, options8) {
        return changeObjects;
      }
      get useLongestToken() {
        return !1;
      }
      buildValues(lastComponent, newTokens, oldTokens) {
        let components = [], nextComponent;
        for (; lastComponent; )
          components.push(lastComponent), nextComponent = lastComponent.previousComponent, delete lastComponent.previousComponent, lastComponent = nextComponent;
        components.reverse();
        let componentLen = components.length, componentPos = 0, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          let component = components[componentPos];
          if (component.removed)
            component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count)), oldPos += component.count;
          else {
            if (!component.added && this.useLongestToken) {
              let value = newTokens.slice(newPos, newPos + component.count);
              value = value.map(function(value2, i) {
                let oldValue = oldTokens[oldPos + i];
                return oldValue.length > value2.length ? oldValue : value2;
              }), component.value = this.join(value);
            } else
              component.value = this.join(newTokens.slice(newPos, newPos + component.count));
            newPos += component.count, component.added || (oldPos += component.count);
          }
        }
        return components;
      }
    }, LineDiff = class extends Diff {
      constructor() {
        super(...arguments), this.tokenize = tokenize;
      }
      equals(left, right, options8) {
        return options8.ignoreWhitespace ? ((!options8.newlineIsToken || !left.includes(`
`)) && (left = left.trim()), (!options8.newlineIsToken || !right.includes(`
`)) && (right = right.trim())) : options8.ignoreNewlineAtEof && !options8.newlineIsToken && (left.endsWith(`
`) && (left = left.slice(0, -1)), right.endsWith(`
`) && (right = right.slice(0, -1))), super.equals(left, right, options8);
      }
    }, lineDiff = new LineDiff();
    ArrayDiff = class extends Diff {
      tokenize(value) {
        return value.slice();
      }
      join(value) {
        return value;
      }
      removeEmpty(value) {
        return value;
      }
    }, arrayDiff = new ArrayDiff();
    import_fast_glob = __toESM(require_out4(), 1), array = [], characterCodeCache = [];
    import_picocolors5 = __toESM(require_picocolors(), 1), apiDescriptor = {
      key: (key2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key2) ? key2 : JSON.stringify(key2),
      value(value) {
        if (value === null || typeof value != "object")
          return JSON.stringify(value);
        if (Array.isArray(value))
          return `[${value.map((subValue) => apiDescriptor.value(subValue)).join(", ")}]`;
        let keys = Object.keys(value);
        return keys.length === 0 ? "{}" : `{ ${keys.map((key2) => `${apiDescriptor.key(key2)}: ${apiDescriptor.value(value[key2])}`).join(", ")} }`;
      },
      pair: ({ key: key2, value }) => apiDescriptor.value({ [key2]: value })
    }, import_picocolors = __toESM(require_picocolors(), 1), commonDeprecatedHandler = (keyOrPair, redirectTo, { descriptor }) => {
      let messages2 = [
        `${import_picocolors.default.yellow(typeof keyOrPair == "string" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`
      ];
      return redirectTo && messages2.push(`we now treat it as ${import_picocolors.default.blue(typeof redirectTo == "string" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`), messages2.join("; ") + ".";
    }, import_picocolors2 = __toESM(require_picocolors(), 1), VALUE_NOT_EXIST = Symbol.for("vnopts.VALUE_NOT_EXIST"), VALUE_UNCHANGED = Symbol.for("vnopts.VALUE_UNCHANGED"), INDENTATION = " ".repeat(2), commonInvalidHandler = (key2, value, utils2) => {
      let { text, list } = utils2.normalizeExpectedResult(utils2.schemas[key2].expected(utils2)), descriptions = [];
      return text && descriptions.push(getDescription(key2, value, text, utils2.descriptor)), list && descriptions.push([getDescription(key2, value, list.title, utils2.descriptor)].concat(list.values.map((valueDescription) => getListDescription(valueDescription, utils2.loggerPrintWidth))).join(`
`)), chooseDescription(descriptions, utils2.loggerPrintWidth);
    };
    import_picocolors3 = __toESM(require_picocolors(), 1), levenUnknownHandler = (key2, value, { descriptor, logger, schemas }) => {
      let messages2 = [
        `Ignored unknown option ${import_picocolors3.default.yellow(descriptor.pair({ key: key2, value }))}.`
      ], suggestion = closestMatch(key2, Object.keys(schemas), { maxDistance: 3 });
      suggestion && messages2.push(`Did you mean ${import_picocolors3.default.blue(descriptor.key(suggestion))}?`), logger.warn(messages2.join(" "));
    }, HANDLER_KEYS = [
      "default",
      "expected",
      "validate",
      "deprecated",
      "forward",
      "redirect",
      "overlap",
      "preprocess",
      "postprocess"
    ];
    Schema = class {
      static create(parameters) {
        return createSchema(this, parameters);
      }
      constructor(parameters) {
        this.name = parameters.name;
      }
      default(_utils) {
      }
      // this is actually an abstract method but we need a placeholder to get `function.length`
      /* c8 ignore start */
      expected(_utils) {
        return "nothing";
      }
      /* c8 ignore stop */
      // this is actually an abstract method but we need a placeholder to get `function.length`
      /* c8 ignore start */
      validate(_value, _utils) {
        return !1;
      }
      /* c8 ignore stop */
      deprecated(_value, _utils) {
        return !1;
      }
      forward(_value, _utils) {
      }
      redirect(_value, _utils) {
      }
      overlap(currentValue, _newValue, _utils) {
        return currentValue;
      }
      preprocess(value, _utils) {
        return value;
      }
      postprocess(_value, _utils) {
        return VALUE_UNCHANGED;
      }
    };
    AliasSchema = class extends Schema {
      constructor(parameters) {
        super(parameters), this._sourceName = parameters.sourceName;
      }
      expected(utils2) {
        return utils2.schemas[this._sourceName].expected(utils2);
      }
      validate(value, utils2) {
        return utils2.schemas[this._sourceName].validate(value, utils2);
      }
      redirect(_value, _utils) {
        return this._sourceName;
      }
    }, AnySchema = class extends Schema {
      expected() {
        return "anything";
      }
      validate() {
        return !0;
      }
    }, ArraySchema = class extends Schema {
      constructor({ valueSchema, name = valueSchema.name, ...handlers }) {
        super({ ...handlers, name }), this._valueSchema = valueSchema;
      }
      expected(utils2) {
        let { text, list } = utils2.normalizeExpectedResult(this._valueSchema.expected(utils2));
        return {
          text: text && `an array of ${text}`,
          list: list && {
            title: "an array of the following values",
            values: [{ list }]
          }
        };
      }
      validate(value, utils2) {
        if (!Array.isArray(value))
          return !1;
        let invalidValues = [];
        for (let subValue of value) {
          let subValidateResult = utils2.normalizeValidateResult(this._valueSchema.validate(subValue, utils2), subValue);
          subValidateResult !== !0 && invalidValues.push(subValidateResult.value);
        }
        return invalidValues.length === 0 ? !0 : { value: invalidValues };
      }
      deprecated(value, utils2) {
        let deprecatedResult = [];
        for (let subValue of value) {
          let subDeprecatedResult = utils2.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils2), subValue);
          subDeprecatedResult !== !1 && deprecatedResult.push(...subDeprecatedResult.map(({ value: deprecatedValue }) => ({
            value: [deprecatedValue]
          })));
        }
        return deprecatedResult;
      }
      forward(value, utils2) {
        let forwardResult = [];
        for (let subValue of value) {
          let subForwardResult = utils2.normalizeForwardResult(this._valueSchema.forward(subValue, utils2), subValue);
          forwardResult.push(...subForwardResult.map(wrapTransferResult));
        }
        return forwardResult;
      }
      redirect(value, utils2) {
        let remain = [], redirect = [];
        for (let subValue of value) {
          let subRedirectResult = utils2.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils2), subValue);
          "remain" in subRedirectResult && remain.push(subRedirectResult.remain), redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));
        }
        return remain.length === 0 ? { redirect } : { redirect, remain };
      }
      overlap(currentValue, newValue) {
        return currentValue.concat(newValue);
      }
    };
    BooleanSchema = class extends Schema {
      expected() {
        return "true or false";
      }
      validate(value) {
        return typeof value == "boolean";
      }
    };
    ChoiceSchema = class extends Schema {
      constructor(parameters) {
        super(parameters), this._choices = mapFromArray(parameters.choices.map((choice) => choice && typeof choice == "object" ? choice : { value: choice }), "value");
      }
      expected({ descriptor }) {
        let choiceDescriptions = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter(({ hidden }) => !hidden).map((choiceInfo) => choiceInfo.value).sort(comparePrimitive).map(descriptor.value), head = choiceDescriptions.slice(0, -2), tail = choiceDescriptions.slice(-2);
        return {
          text: head.concat(tail.join(" or ")).join(", "),
          list: {
            title: "one of the following values",
            values: choiceDescriptions
          }
        };
      }
      validate(value) {
        return this._choices.has(value);
      }
      deprecated(value) {
        let choiceInfo = this._choices.get(value);
        return choiceInfo && choiceInfo.deprecated ? { value } : !1;
      }
      forward(value) {
        let choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.forward : void 0;
      }
      redirect(value) {
        let choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.redirect : void 0;
      }
    }, NumberSchema = class extends Schema {
      expected() {
        return "a number";
      }
      validate(value, _utils) {
        return typeof value == "number";
      }
    }, IntegerSchema = class extends NumberSchema {
      expected() {
        return "an integer";
      }
      validate(value, utils2) {
        return utils2.normalizeValidateResult(super.validate(value, utils2), value) === !0 && isInt(value);
      }
    }, StringSchema = class extends Schema {
      expected() {
        return "a string";
      }
      validate(value) {
        return typeof value == "string";
      }
    }, defaultDescriptor = apiDescriptor, defaultUnknownHandler = levenUnknownHandler, defaultInvalidHandler = commonInvalidHandler, defaultDeprecatedHandler = commonDeprecatedHandler, Normalizer = class {
      constructor(schemas, opts) {
        let { logger = console, loggerPrintWidth = 80, descriptor = defaultDescriptor, unknown = defaultUnknownHandler, invalid = defaultInvalidHandler, deprecated = defaultDeprecatedHandler, missing = () => !1, required = () => !1, preprocess = (x) => x, postprocess = () => VALUE_UNCHANGED } = opts || {};
        this._utils = {
          descriptor,
          logger: (
            /* c8 ignore next */
            logger || { warn: () => {
            } }
          ),
          loggerPrintWidth,
          schemas: recordFromArray(schemas, "name"),
          normalizeDefaultResult,
          normalizeExpectedResult,
          normalizeDeprecatedResult,
          normalizeForwardResult,
          normalizeRedirectResult,
          normalizeValidateResult
        }, this._unknownHandler = unknown, this._invalidHandler = normalizeInvalidHandler(invalid), this._deprecatedHandler = deprecated, this._identifyMissing = (k, o) => !(k in o) || missing(k, o), this._identifyRequired = required, this._preprocess = preprocess, this._postprocess = postprocess, this.cleanHistory();
      }
      cleanHistory() {
        this._hasDeprecationWarned = createAutoChecklist();
      }
      normalize(options8) {
        let newOptions = {}, restOptionsArray = [this._preprocess(options8, this._utils)], applyNormalization = () => {
          for (; restOptionsArray.length !== 0; ) {
            let currentOptions = restOptionsArray.shift(), transferredOptionsArray = this._applyNormalization(currentOptions, newOptions);
            restOptionsArray.push(...transferredOptionsArray);
          }
        };
        applyNormalization();
        for (let key2 of Object.keys(this._utils.schemas)) {
          let schema = this._utils.schemas[key2];
          if (!(key2 in newOptions)) {
            let defaultResult = normalizeDefaultResult(schema.default(this._utils));
            "value" in defaultResult && restOptionsArray.push({ [key2]: defaultResult.value });
          }
        }
        applyNormalization();
        for (let key2 of Object.keys(this._utils.schemas)) {
          if (!(key2 in newOptions))
            continue;
          let schema = this._utils.schemas[key2], value = newOptions[key2], newValue = schema.postprocess(value, this._utils);
          newValue !== VALUE_UNCHANGED && (this._applyValidation(newValue, key2, schema), newOptions[key2] = newValue);
        }
        return this._applyPostprocess(newOptions), this._applyRequiredCheck(newOptions), newOptions;
      }
      _applyNormalization(options8, newOptions) {
        let transferredOptionsArray = [], { knownKeys, unknownKeys } = this._partitionOptionKeys(options8);
        for (let key2 of knownKeys) {
          let schema = this._utils.schemas[key2], value = schema.preprocess(options8[key2], this._utils);
          this._applyValidation(value, key2, schema);
          let appendTransferredOptions = ({ from, to }) => {
            transferredOptionsArray.push(typeof to == "string" ? { [to]: from } : { [to.key]: to.value });
          }, warnDeprecated = ({ value: currentValue, redirectTo }) => {
            let deprecatedResult = normalizeDeprecatedResult(
              schema.deprecated(currentValue, this._utils),
              value,
              /* doNotNormalizeTrue */
              !0
            );
            if (deprecatedResult !== !1)
              if (deprecatedResult === !0)
                this._hasDeprecationWarned(key2) || this._utils.logger.warn(this._deprecatedHandler(key2, redirectTo, this._utils));
              else
                for (let { value: deprecatedValue } of deprecatedResult) {
                  let pair = { key: key2, value: deprecatedValue };
                  if (!this._hasDeprecationWarned(pair)) {
                    let redirectToPair = typeof redirectTo == "string" ? { key: redirectTo, value: deprecatedValue } : redirectTo;
                    this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));
                  }
                }
          };
          normalizeForwardResult(schema.forward(value, this._utils), value).forEach(appendTransferredOptions);
          let redirectResult = normalizeRedirectResult(schema.redirect(value, this._utils), value);
          if (redirectResult.redirect.forEach(appendTransferredOptions), "remain" in redirectResult) {
            let remainingValue = redirectResult.remain;
            newOptions[key2] = key2 in newOptions ? schema.overlap(newOptions[key2], remainingValue, this._utils) : remainingValue, warnDeprecated({ value: remainingValue });
          }
          for (let { from, to } of redirectResult.redirect)
            warnDeprecated({ value: from, redirectTo: to });
        }
        for (let key2 of unknownKeys) {
          let value = options8[key2];
          this._applyUnknownHandler(key2, value, newOptions, (knownResultKey, knownResultValue) => {
            transferredOptionsArray.push({ [knownResultKey]: knownResultValue });
          });
        }
        return transferredOptionsArray;
      }
      _applyRequiredCheck(options8) {
        for (let key2 of Object.keys(this._utils.schemas))
          if (this._identifyMissing(key2, options8) && this._identifyRequired(key2))
            throw this._invalidHandler(key2, VALUE_NOT_EXIST, this._utils);
      }
      _partitionOptionKeys(options8) {
        let [knownKeys, unknownKeys] = partition(Object.keys(options8).filter((key2) => !this._identifyMissing(key2, options8)), (key2) => key2 in this._utils.schemas);
        return { knownKeys, unknownKeys };
      }
      _applyValidation(value, key2, schema) {
        let validateResult = normalizeValidateResult(schema.validate(value, this._utils), value);
        if (validateResult !== !0)
          throw this._invalidHandler(key2, validateResult.value, this._utils);
      }
      _applyUnknownHandler(key2, value, newOptions, knownResultHandler) {
        let unknownResult = this._unknownHandler(key2, value, this._utils);
        if (unknownResult)
          for (let resultKey of Object.keys(unknownResult)) {
            if (this._identifyMissing(resultKey, unknownResult))
              continue;
            let resultValue = unknownResult[resultKey];
            resultKey in this._utils.schemas ? knownResultHandler(resultKey, resultValue) : newOptions[resultKey] = resultValue;
          }
      }
      _applyPostprocess(options8) {
        let postprocessed = this._postprocess(options8, this._utils);
        if (postprocessed !== VALUE_UNCHANGED) {
          if (postprocessed.delete)
            for (let deleteKey of postprocessed.delete)
              delete options8[deleteKey];
          if (postprocessed.override) {
            let { knownKeys, unknownKeys } = this._partitionOptionKeys(postprocessed.override);
            for (let key2 of knownKeys) {
              let value = postprocessed.override[key2];
              this._applyValidation(value, key2, this._utils.schemas[key2]), options8[key2] = value;
            }
            for (let key2 of unknownKeys) {
              let value = postprocessed.override[key2];
              this._applyUnknownHandler(key2, value, options8, (knownResultKey, knownResultValue) => {
                let schema = this._utils.schemas[knownResultKey];
                this._applyValidation(knownResultValue, knownResultKey, schema), options8[knownResultKey] = knownResultValue;
              });
            }
          }
        }
      }
    }, errors_exports = {};
    __export3(errors_exports, {
      ArgExpansionBailout: () => ArgExpansionBailout,
      ConfigError: () => ConfigError,
      UndefinedParserError: () => UndefinedParserError
    });
    ConfigError = class extends Error {
      name = "ConfigError";
    }, UndefinedParserError = class extends Error {
      name = "UndefinedParserError";
    }, ArgExpansionBailout = class extends Error {
      name = "ArgExpansionBailout";
    };
    create_mockable_default = createMockable, mockable = create_mockable_default({
      getPrettierConfigSearchStopDirectory: () => {
      }
    }), mockable_default = mockable.mocked, import_micromatch = __toESM(require_micromatch(), 1), URL_STRING_PREFIX = "file:", isUrlInstance = (value) => value instanceof URL, isUrlString = (value) => typeof value == "string" && value.startsWith(URL_STRING_PREFIX), isUrl = (urlOrPath) => isUrlInstance(urlOrPath) || isUrlString(urlOrPath), toPath = (urlOrPath) => isUrl(urlOrPath) ? url.fileURLToPath(urlOrPath) : urlOrPath, toAbsolutePath = (urlOrPath) => urlOrPath && path.resolve(isUrl(urlOrPath) ? url.fileURLToPath(urlOrPath) : urlOrPath);
    partition_default = partition2, import_editorconfig = __toESM(require_src(), 1), isFile = (stats) => stats?.isFile(), isDirectory = (stats) => stats?.isDirectory();
    iterate_directory_up_default = iterateDirectoryUp, Searcher = class {
      #stopDirectory;
      #cache;
      #resultCache = /* @__PURE__ */ new Map();
      #searchWithoutCache;
      /**
      @protected
      @type {typeof findFile | typeof findDirectory}
      */
      findInDirectory;
      /**
      @param {NameOrNames} nameOrNames
      @param {SearcherOptions} [options]
      */
      constructor(nameOrNames, { allowSymlinks, filter: filter2, stopDirectory, cache: cache3 } = {}) {
        this.#stopDirectory = stopDirectory, this.#cache = cache3 ?? !0, this.#searchWithoutCache = (directory) => this.findInDirectory(nameOrNames, { cwd: directory, filter: filter2, allowSymlinks });
      }
      #search(directory, cache3 = !0) {
        let resultCache = this.#resultCache;
        return (!cache3 || !resultCache.has(directory)) && resultCache.set(directory, this.#searchWithoutCache(directory)), resultCache.get(directory);
      }
      /**
        Find closest file or directory matches name or names.
      
        @param {OptionalUrlOrPath} [startDirectory]
        @param {SearchOptions} [options]
        @returns {SearchResult}
        */
      async search(startDirectory, options8) {
        for (let directory of iterate_directory_up_default(
          startDirectory,
          this.#stopDirectory
        )) {
          let result = await this.#search(
            directory,
            options8?.cache ?? this.#cache
          );
          if (result)
            return result;
        }
      }
      /**
        Clear caches.
      
        @returns {void}
        */
      clearCache() {
        this.#resultCache.clear();
      }
    }, FileSearcher = class extends Searcher {
      /** @protected */
      findInDirectory = findFile;
    }, DirectorySearcher = class extends Searcher {
      /** @protected */
      findInDirectory = findDirectory;
    }, DIRECTORIES = [".git", ".hg"];
    isPositiveInteger = (value) => Number.isSafeInteger(value) && value > 0;
    editorconfig_to_prettier_default = editorConfigToPrettier, editorconfigCache = /* @__PURE__ */ new Map();
    Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    }, util = {
      isSpaceSeparator(c2) {
        return typeof c2 == "string" && unicode.Space_Separator.test(c2);
      },
      isIdStartChar(c2) {
        return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
      },
      isIdContinueChar(c2) {
        return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
      },
      isDigit(c2) {
        return typeof c2 == "string" && /[0-9]/.test(c2);
      },
      isHexDigit(c2) {
        return typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2);
      }
    }, parse2 = function(text, reviver) {
      source = String(text), parseState = "start", stack = [], pos = 0, line2 = 1, column = 0, token = void 0, key = void 0, root = void 0;
      do
        token = lex(), parseStates[parseState]();
      while (token.type !== "eof");
      return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
    };
    lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read(), lexState = "comment";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineComment";
            return;
          case "/":
            read(), lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read(), lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read(), lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read(), lexState = "default";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            return read(), literal("ull"), newToken("null", null);
          case "t":
            return read(), literal("rue"), newToken("boolean", !0);
          case "f":
            return read(), literal("alse"), newToken("boolean", !1);
          case "-":
          case "+":
            read() === "-" && (sign = -1), lexState = "sign";
            return;
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", 1 / 0);
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"', buffer = "", lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        let u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read(), lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        let u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read(), lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read(), lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read(), lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read(), buffer += escape();
            return;
          case '"':
            if (doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case "'":
            if (!doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case `
`:
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read(), lexState = "identifierName";
            return;
          case "\\":
            read(), lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"', lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read(), lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":")
          return newToken("punctuator", read());
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]")
          return newToken("punctuator", read());
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    parseStates = {
      start() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value, parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof")
          throw invalidEOF();
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof")
          throw invalidEOF();
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    dist_default = { parse: parse2 }, import_picocolors4 = __toESM(require_picocolors(), 1), import_js_tokens = __toESM(require_js_tokens(), 1), nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    compose = (f, g) => (v) => f(g(v));
    defsOn = buildDefs((0, import_picocolors4.createColors)(!0)), defsOff = buildDefs((0, import_picocolors4.createColors)(!1));
    sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/;
    {
      let getTokenType = function(token2) {
        if (token2.type === "IdentifierName") {
          if (isKeyword(token2.value) || isStrictReservedWord(token2.value, !0) || sometimesKeywords.has(token2.value))
            return "keyword";
          if (token2.value[0] !== token2.value[0].toLowerCase())
            return "capitalized";
        }
        if (token2.type === "Punctuator" && BRACKET.test(token2.value))
          return "uncolored";
        if (token2.type === "Invalid" && token2.value === "@")
          return "punctuator";
        switch (token2.type) {
          case "NumericLiteral":
            return "number";
          case "StringLiteral":
          case "JSXString":
          case "NoSubstitutionTemplate":
            return "string";
          case "RegularExpressionLiteral":
            return "regex";
          case "Punctuator":
          case "JSXPunctuator":
            return "punctuator";
          case "MultiLineComment":
          case "SingleLineComment":
            return "comment";
          case "Invalid":
          case "JSXInvalid":
            return "invalid";
          case "JSXIdentifier":
            return "jsxIdentifier";
          default:
            return "uncolored";
        }
      };
      tokenize2 = function* (text) {
        for (let token2 of (0, import_js_tokens.default)(text, {
          jsx: !0
        }))
          switch (token2.type) {
            case "TemplateHead":
              yield {
                type: "string",
                value: token2.value.slice(0, -2)
              }, yield {
                type: "punctuator",
                value: "${"
              };
              break;
            case "TemplateMiddle":
              yield {
                type: "punctuator",
                value: "}"
              }, yield {
                type: "string",
                value: token2.value.slice(1, -2)
              }, yield {
                type: "punctuator",
                value: "${"
              };
              break;
            case "TemplateTail":
              yield {
                type: "punctuator",
                value: "}"
              }, yield {
                type: "string",
                value: token2.value.slice(1)
              };
              break;
            default:
              yield {
                type: getTokenType(token2),
                value: token2.value
              };
          }
      };
    }
    NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    getOffsets = ({
      oneBased,
      oneBasedLine = oneBased,
      oneBasedColumn = oneBased
    } = {}) => [oneBasedLine ? 1 : 0, oneBasedColumn ? 1 : 0];
    getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`, JSONError = class _JSONError extends Error {
      name = "JSONError";
      fileName;
      #input;
      #jsonParseError;
      #message;
      #codeFrame;
      #rawCodeFrame;
      constructor(messageOrOptions) {
        if (typeof messageOrOptions == "string")
          super(), this.#message = messageOrOptions;
        else {
          let { jsonParseError, fileName, input } = messageOrOptions;
          super(void 0, { cause: jsonParseError }), this.#input = input, this.#jsonParseError = jsonParseError, this.fileName = fileName;
        }
        Error.captureStackTrace?.(this, _JSONError);
      }
      get message() {
        this.#message ?? (this.#message = `${addCodePointToUnexpectedToken(this.#jsonParseError.message)}${this.#input === "" ? " while parsing empty string" : ""}`);
        let { codeFrame } = this;
        return `${this.#message}${this.fileName ? ` in ${this.fileName}` : ""}${codeFrame ? `

${codeFrame}
` : ""}`;
      }
      set message(message) {
        this.#message = message;
      }
      #getCodeFrame(highlightCode) {
        if (!this.#jsonParseError)
          return;
        let input = this.#input, location = getErrorLocation(input, this.#jsonParseError.message);
        if (location)
          return codeFrameColumns(input, { start: location }, { highlightCode });
      }
      get codeFrame() {
        return this.#codeFrame ?? (this.#codeFrame = this.#getCodeFrame(
          /* highlightCode */
          !0
        )), this.#codeFrame;
      }
      get rawCodeFrame() {
        return this.#rawCodeFrame ?? (this.#rawCodeFrame = this.#getCodeFrame(
          /* highlightCode */
          !1
        )), this.#rawCodeFrame;
      }
    }, getErrorLocation = (string, message) => {
      let match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
      if (!match)
        return;
      let { index, line: line3, column: column2 } = match.groups;
      return line3 && column2 ? { line: Number(line3), column: Number(column2) } : indexToPosition(string, Number(index), { oneBased: !0 });
    }, addCodePointToUnexpectedToken = (message) => message.replace(
      // TODO[engine:node@>=20]: The token always quoted after Node.js 20
      /(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/,
      (_, _quote, token2) => `"${token2}"(${getCodePoint(token2)})`
    );
    TomlError = class extends Error {
      line;
      column;
      codeblock;
      constructor(message, options8) {
        let [line3, column2] = getLineColFromPtr(options8.toml, options8.ptr), codeblock = makeCodeBlock(options8.toml, line3, column2);
        super(`Invalid TOML document: ${message}

${codeblock}`, options8), this.line = line3, this.column = column2, this.codeblock = codeblock;
      }
    };
    DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i, TomlDate = class _TomlDate extends Date {
      #hasDate = !1;
      #hasTime = !1;
      #offset = null;
      constructor(date) {
        let hasDate = !0, hasTime = !0, offset = "Z";
        if (typeof date == "string") {
          let match = date.match(DATE_TIME_RE);
          match ? (match[1] || (hasDate = !1, date = `0000-01-01T${date}`), hasTime = !!match[2], hasTime && date[10] === " " && (date = date.replace(" ", "T")), match[2] && +match[2] > 23 ? date = "" : (offset = match[3] || null, date = date.toUpperCase(), !offset && hasTime && (date += "Z"))) : date = "";
        }
        super(date), isNaN(this.getTime()) || (this.#hasDate = hasDate, this.#hasTime = hasTime, this.#offset = offset);
      }
      isDateTime() {
        return this.#hasDate && this.#hasTime;
      }
      isLocal() {
        return !this.#hasDate || !this.#hasTime || !this.#offset;
      }
      isDate() {
        return this.#hasDate && !this.#hasTime;
      }
      isTime() {
        return this.#hasTime && !this.#hasDate;
      }
      isValid() {
        return this.#hasDate || this.#hasTime;
      }
      toISOString() {
        let iso = super.toISOString();
        if (this.isDate())
          return iso.slice(0, 10);
        if (this.isTime())
          return iso.slice(11, 23);
        if (this.#offset === null)
          return iso.slice(0, -1);
        if (this.#offset === "Z")
          return iso;
        let offset = +this.#offset.slice(1, 3) * 60 + +this.#offset.slice(4, 6);
        return offset = this.#offset[0] === "-" ? offset : -offset, new Date(this.getTime() - offset * 6e4).toISOString().slice(0, -1) + this.#offset;
      }
      static wrapAsOffsetDateTime(jsDate, offset = "Z") {
        let date = new _TomlDate(jsDate);
        return date.#offset = offset, date;
      }
      static wrapAsLocalDateTime(jsDate) {
        let date = new _TomlDate(jsDate);
        return date.#offset = null, date;
      }
      static wrapAsLocalDate(jsDate) {
        let date = new _TomlDate(jsDate);
        return date.#hasTime = !1, date.#offset = null, date;
      }
      static wrapAsLocalTime(jsDate) {
        let date = new _TomlDate(jsDate);
        return date.#hasDate = !1, date.#offset = null, date;
      }
    }, INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, LEADING_ZERO = /^[+-]?0[0-9_]/, ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i, ESC_MAP = {
      b: "\b",
      t: "	",
      n: `
`,
      f: "\f",
      r: "\r",
      '"': '"',
      "\\": "\\"
    };
    KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
    read_file_default = readFile;
    loadConfigFromPackageJson = process.versions.bun ? async function(file) {
      let { prettier } = await readBunPackageJson(file);
      return prettier;
    } : async function(file) {
      let { prettier } = await readJson(file);
      return prettier;
    };
    loaders = {
      ".toml": loadToml,
      ".json5": loadJson5,
      ".json": readJson,
      ".js": importModuleDefault,
      ".mjs": importModuleDefault,
      ".cjs": importModuleDefault,
      ".ts": importModuleDefault,
      ".mts": importModuleDefault,
      ".cts": importModuleDefault,
      ".yaml": loadYaml,
      ".yml": loadYaml,
      // No extension
      "": loadYaml
    }, loaders_default = loaders, CONFIG_FILE_NAMES = [
      "package.json",
      "package.yaml",
      ".prettierrc",
      ".prettierrc.json",
      ".prettierrc.yml",
      ".prettierrc.yaml",
      ".prettierrc.json5",
      ".prettierrc.js",
      "prettier.config.js",
      ".prettierrc.ts",
      "prettier.config.ts",
      ".prettierrc.mjs",
      "prettier.config.mjs",
      ".prettierrc.mts",
      "prettier.config.mts",
      ".prettierrc.cjs",
      "prettier.config.cjs",
      ".prettierrc.cts",
      "prettier.config.cts",
      ".prettierrc.toml"
    ];
    config_searcher_default = getSearcher, own = {}.hasOwnProperty, classRegExp = /^([A-Z][a-z\d]*)+$/, kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]), codes = {};
    messages = /* @__PURE__ */ new Map(), nodeInternalPrefix = "__node_internal_";
    codes.ERR_INVALID_ARG_TYPE = createError(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name, expected, actual) => {
        assert2.ok(typeof name == "string", "'name' must be a string"), Array.isArray(expected) || (expected = [expected]);
        let message = "The ";
        if (name.endsWith(" argument"))
          message += `${name} `;
        else {
          let type = name.includes(".") ? "property" : "argument";
          message += `"${name}" ${type} `;
        }
        message += "must be ";
        let types = [], instances = [], other = [];
        for (let value of expected)
          assert2.ok(
            typeof value == "string",
            "All expected entries have to be of type string"
          ), kTypes.has(value) ? types.push(value.toLowerCase()) : classRegExp.exec(value) === null ? (assert2.ok(
            value !== "object",
            'The value "object" should be written as "Object"'
          ), other.push(value)) : instances.push(value);
        if (instances.length > 0) {
          let pos2 = types.indexOf("object");
          pos2 !== -1 && (types.slice(pos2, 1), instances.push("Object"));
        }
        return types.length > 0 && (message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
          types,
          "or"
        )}`, (instances.length > 0 || other.length > 0) && (message += " or ")), instances.length > 0 && (message += `an instance of ${formatList(instances, "or")}`, other.length > 0 && (message += " or ")), other.length > 0 && (other.length > 1 ? message += `one of ${formatList(other, "or")}` : (other[0].toLowerCase() !== other[0] && (message += "an "), message += `${other[0]}`)), message += `. Received ${determineSpecificType(actual)}`, message;
      },
      TypeError
    );
    codes.ERR_INVALID_MODULE_SPECIFIER = createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`,
      TypeError
    );
    codes.ERR_INVALID_PACKAGE_CONFIG = createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path15, base, message) => `Invalid package config ${path15}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`,
      Error
    );
    codes.ERR_INVALID_PACKAGE_TARGET = createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key2, target, isImport = !1, base = void 0) => {
        let relatedError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
        return key2 === "." ? (assert2.ok(isImport === !1), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key2}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    codes.ERR_MODULE_NOT_FOUND = createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path15, base, exactUrl = !1) => `Cannot find ${exactUrl ? "module" : "package"} '${path15}' imported from ${base}`,
      Error
    );
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`,
      TypeError
    );
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => subpath === "." ? `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`,
      Error
    );
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension, path15) => `Unknown file extension "${extension}" for ${path15}`,
      TypeError
    );
    codes.ERR_INVALID_ARG_VALUE = createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        return inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`), `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error) {
        let stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        return stackTraceLimitIsWritable && (userStackTraceLimit = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit), error;
      }
    );
    hasOwnProperty = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG } = codes, cache = /* @__PURE__ */ new Map();
    ({ ERR_UNKNOWN_FILE_EXTENSION } = codes), hasOwnProperty2 = {}.hasOwnProperty, extensionFormatMap = {
      // @ts-expect-error: hush.
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    protocolHandlers = {
      // @ts-expect-error: hush.
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
    ({ ERR_INVALID_ARG_VALUE } = codes), DEFAULT_CONDITIONS = Object.freeze(["node", "import"]), DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
    RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace], {
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes, own2 = {}.hasOwnProperty, invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, invalidPackageNameRegEx = /^\.|%|\\/, patternRegEx = /\*/g, encodedSeparatorRegEx = /%2f|%5c/i, emittedPackageWarnings = /* @__PURE__ */ new Set(), doubleSlashRegEx = /[/\\]{2}/;
    import_from_file_default = importFromFile;
    require_from_file_default = requireFromFile, requireErrorCodesShouldBeIgnored = /* @__PURE__ */ new Set([
      "MODULE_NOT_FOUND",
      "ERR_REQUIRE_ESM",
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      "ERR_REQUIRE_ASYNC_MODULE"
    ]);
    load_external_config_default = loadExternalConfig;
    load_config_default = loadConfig, loadCache = /* @__PURE__ */ new Map(), searchCache = /* @__PURE__ */ new Map();
    OPTIONAL_OBJECT2 = 1, createMethodShim2 = (methodName, getImplementation) => (flags, object, ...arguments_) => flags | OPTIONAL_OBJECT2 && object == null ? void 0 : (getImplementation.call(object) ?? object[methodName]).apply(object, arguments_), stringReplaceAll2 = String.prototype.replaceAll ?? function(pattern, replacement) {
      return pattern.global ? this.replace(pattern, replacement) : this.split(pattern).join(replacement);
    }, replaceAll2 = createMethodShim2("replaceAll", function() {
      if (typeof this == "string")
        return stringReplaceAll2;
    }), method_replace_all_default2 = replaceAll2, OPTION_CR2 = "cr", OPTION_CRLF2 = "crlf", OPTION_LF = "lf", DEFAULT_OPTION = OPTION_LF, CHARACTER_CR2 = "\r", CHARACTER_CRLF2 = `\r
`, CHARACTER_LF2 = `
`, DEFAULT_EOL2 = CHARACTER_LF2;
    regexps = /* @__PURE__ */ new Map([[CHARACTER_LF2, /\n/gu], [CHARACTER_CR2, /\r/gu], [CHARACTER_CRLF2, /\r\n/gu]]);
    END_OF_LINE_REGEXP = /\r\n?/gu;
    at2 = createMethodShim2("at", function() {
      if (Array.isArray(this) || typeof this == "string")
        return stringOrArrayAt2;
    }), method_at_default2 = at2, noop2 = () => {
    }, noop_default2 = noop2, DOC_TYPE_CURSOR2 = /** @type {const} */
    "cursor", DOC_TYPE_INDENT2 = /** @type {const} */
    "indent", DOC_TYPE_ALIGN2 = /** @type {const} */
    "align", DOC_TYPE_TRIM2 = /** @type {const} */
    "trim", DOC_TYPE_GROUP2 = /** @type {const} */
    "group", DOC_TYPE_FILL2 = /** @type {const} */
    "fill", DOC_TYPE_IF_BREAK2 = /** @type {const} */
    "if-break", DOC_TYPE_INDENT_IF_BREAK2 = /** @type {const} */
    "indent-if-break", DOC_TYPE_LINE_SUFFIX2 = /** @type {const} */
    "line-suffix", DOC_TYPE_LINE_SUFFIX_BOUNDARY2 = /** @type {const} */
    "line-suffix-boundary", DOC_TYPE_LINE2 = /** @type {const} */
    "line", DOC_TYPE_LABEL2 = /** @type {const} */
    "label", DOC_TYPE_BREAK_PARENT2 = /** @type {const} */
    "break-parent";
    emoji_regex_default2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    narrow_emojis_evaluate_default2 = "\xA9\xAE\u203C\u2049\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21A9\u21AA\u2328\u23CF\u23F1\u23F2\u23F8\u23F9\u23FA\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600\u2601\u2602\u2603\u2604\u260E\u2611\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638\u2639\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694\u2695\u2696\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F1\u26F7\u26F8\u26F9\u2702\u2708\u2709\u270C\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u2764\u27A1\u2934\u2935\u2B05\u2B06\u2B07", notAsciiRegex2 = /[^\x20-\x7F]/u, narrowEmojisSet2 = new Set(narrow_emojis_evaluate_default2);
    get_string_width_default2 = getStringWidth2;
    get_alignment_size_default = getAlignmentSize, AstPath = class {
      constructor(value) {
        this.stack = [value];
      }
      /** @type {string | null} */
      get key() {
        let {
          stack: stack2,
          siblings
        } = this;
        return method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          stack2,
          siblings === null ? -2 : -4
        ) ?? null;
      }
      /** @type {number | null} */
      get index() {
        return this.siblings === null ? null : method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          this.stack,
          -2
        );
      }
      /** @type {object} */
      get node() {
        return method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          this.stack,
          -1
        );
      }
      /** @type {object | null} */
      get parent() {
        return this.getNode(1);
      }
      /** @type {object | null} */
      get grandparent() {
        return this.getNode(2);
      }
      /** @type {boolean} */
      get isInArray() {
        return this.siblings !== null;
      }
      /** @type {object[] | null} */
      get siblings() {
        let {
          stack: stack2
        } = this, maybeArray = method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          stack2,
          -3
        );
        return Array.isArray(maybeArray) ? maybeArray : null;
      }
      /** @type {object | null} */
      get next() {
        let {
          siblings
        } = this;
        return siblings === null ? null : siblings[this.index + 1];
      }
      /** @type {object | null} */
      get previous() {
        let {
          siblings
        } = this;
        return siblings === null ? null : siblings[this.index - 1];
      }
      /** @type {boolean} */
      get isFirst() {
        return this.index === 0;
      }
      /** @type {boolean} */
      get isLast() {
        let {
          siblings,
          index
        } = this;
        return siblings !== null && index === siblings.length - 1;
      }
      /** @type {boolean} */
      get isRoot() {
        return this.stack.length === 1;
      }
      /** @type {object} */
      get root() {
        return this.stack[0];
      }
      /** @type {object[]} */
      get ancestors() {
        return [...this.#getAncestors()];
      }
      // The name of the current property is always the penultimate element of
      // this.stack, and always a string/number/symbol.
      getName() {
        let {
          stack: stack2
        } = this, {
          length
        } = stack2;
        return length > 1 ? method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          stack2,
          -2
        ) : null;
      }
      // The value of the current property is always the final element of
      // this.stack.
      getValue() {
        return method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          this.stack,
          -1
        );
      }
      getNode(count = 0) {
        let stackIndex = this.#getNodeStackIndex(count);
        return stackIndex === -1 ? null : this.stack[stackIndex];
      }
      getParentNode(count = 0) {
        return this.getNode(count + 1);
      }
      #getNodeStackIndex(count) {
        let {
          stack: stack2
        } = this;
        for (let i = stack2.length - 1; i >= 0; i -= 2)
          if (!Array.isArray(stack2[i]) && --count < 0)
            return i;
        return -1;
      }
      // Temporarily push properties named by string arguments given after the
      // callback function onto this.stack, then call the callback with a
      // reference to this (modified) AstPath object. Note that the stack will
      // be restored to its original state after the callback is finished, so it
      // is probably a mistake to retain a reference to the path.
      call(callback, ...names) {
        let {
          stack: stack2
        } = this, {
          length
        } = stack2, value = method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          stack2,
          -1
        );
        for (let name of names)
          value = value?.[name], stack2.push(name, value);
        try {
          return callback(this);
        } finally {
          stack2.length = length;
        }
      }
      /**
       * @template {(path: AstPath) => any} T
       * @param {T} callback
       * @param {number} [count=0]
       * @returns {ReturnType<T>}
       */
      callParent(callback, count = 0) {
        let stackIndex = this.#getNodeStackIndex(count + 1), parentValues = this.stack.splice(stackIndex + 1);
        try {
          return callback(this);
        } finally {
          this.stack.push(...parentValues);
        }
      }
      // Similar to AstPath.prototype.call, except that the value obtained by
      // accessing this.getValue()[name1][name2]... should be array. The
      // callback will be called with a reference to this path object for each
      // element of the array.
      each(callback, ...names) {
        let {
          stack: stack2
        } = this, {
          length
        } = stack2, value = method_at_default2(
          /* OPTIONAL_OBJECT: false */
          0,
          stack2,
          -1
        );
        for (let name of names)
          value = value[name], stack2.push(name, value);
        try {
          for (let i = 0; i < value.length; ++i)
            stack2.push(i, value[i]), callback(this, i, value), stack2.length -= 2;
        } finally {
          stack2.length = length;
        }
      }
      // Similar to AstPath.prototype.each, except that the results of the
      // callback function invocations are stored in an array and returned at
      // the end of the iteration.
      map(callback, ...names) {
        let result = [];
        return this.each((path15, index, value) => {
          result[index] = callback(path15, index, value);
        }, ...names), result;
      }
      /**
       * @param {...(
       *   | ((node: any, name: string | null, number: number | null) => boolean)
       *   | undefined
       * )} predicates
       */
      match(...predicates) {
        let stackPointer = this.stack.length - 1, name = null, node = this.stack[stackPointer--];
        for (let predicate of predicates) {
          if (node === void 0)
            return !1;
          let number = null;
          if (typeof name == "number" && (number = name, name = this.stack[stackPointer--], node = this.stack[stackPointer--]), predicate && !predicate(node, name, number))
            return !1;
          name = this.stack[stackPointer--], node = this.stack[stackPointer--];
        }
        return !0;
      }
      /**
       * Traverses the ancestors of the current node heading toward the tree root
       * until it finds a node that matches the provided predicate function. Will
       * return the first matching ancestor. If no such node exists, returns undefined.
       * @param {(node: any) => boolean} predicate
       * @internal Unstable API. Don't use in plugins for now.
       */
      findAncestor(predicate) {
        for (let node of this.#getAncestors())
          if (predicate(node))
            return node;
      }
      /**
       * Traverses the ancestors of the current node heading toward the tree root
       * until it finds a node that matches the provided predicate function.
       * returns true if matched node found.
       * @param {(node: any) => boolean} predicate
       * @returns {boolean}
       * @internal Unstable API. Don't use in plugins for now.
       */
      hasAncestor(predicate) {
        for (let node of this.#getAncestors())
          if (predicate(node))
            return !0;
        return !1;
      }
      *#getAncestors() {
        let {
          stack: stack2
        } = this;
        for (let index = stack2.length - 3; index >= 0; index -= 2) {
          let value = stack2[index];
          Array.isArray(value) || (yield value);
        }
      }
    }, ast_path_default = AstPath;
    is_object_default = isObject;
    skipWhitespace = skip(/\s/u), skipSpaces = skip(" 	"), skipToLineEnd = skip(",; 	"), skipEverythingButNewLine = skip(/[^\n\r]/u), isNewlineCharacter = (character) => character === `
` || character === "\r" || character === "\u2028" || character === "\u2029";
    skip_newline_default = skipNewline;
    has_newline_default = hasNewline;
    is_non_empty_array_default = isNonEmptyArray;
    get_sorted_child_nodes_default = getSortedChildNodes;
    childNodesCache = /* @__PURE__ */ new WeakMap();
    returnFalse = () => !1;
    isAllEmptyAndNoLineBreak = (text) => !/[\S\n\u2028\u2029]/u.test(text);
    is_previous_line_empty_default = isPreviousLineEmpty, {
      breakParent: breakParent2,
      hardline: hardline2,
      indent: indent2,
      join: join3,
      line: line22,
      lineSuffix: lineSuffix2
    } = builders;
    create_print_pre_check_function_default = () => noop_default2, core_options_evaluate_default = {
      checkIgnorePragma: {
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.",
        cliCategory: "Other"
      },
      cursorOffset: {
        category: "Special",
        type: "int",
        default: -1,
        range: {
          start: -1,
          end: 1 / 0,
          step: 1
        },
        description: "Print (to stderr) where a cursor at the given position would move to after formatting.",
        cliCategory: "Editor"
      },
      endOfLine: {
        category: "Global",
        type: "choice",
        default: "lf",
        description: "Which end of line characters to apply.",
        choices: [
          {
            value: "lf",
            description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
          },
          {
            value: "crlf",
            description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
          },
          {
            value: "cr",
            description: "Carriage Return character only (\\r), used very rarely"
          },
          {
            value: "auto",
            description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`
          }
        ]
      },
      filepath: {
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
      },
      insertPragma: {
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
      },
      parser: {
        category: "Global",
        type: "choice",
        default: void 0,
        description: "Which parser to use.",
        exception: (value) => typeof value == "string" || typeof value == "function",
        choices: [
          {
            value: "flow",
            description: "Flow"
          },
          {
            value: "babel",
            description: "JavaScript"
          },
          {
            value: "babel-flow",
            description: "Flow"
          },
          {
            value: "babel-ts",
            description: "TypeScript"
          },
          {
            value: "typescript",
            description: "TypeScript"
          },
          {
            value: "acorn",
            description: "JavaScript"
          },
          {
            value: "espree",
            description: "JavaScript"
          },
          {
            value: "meriyah",
            description: "JavaScript"
          },
          {
            value: "css",
            description: "CSS"
          },
          {
            value: "less",
            description: "Less"
          },
          {
            value: "scss",
            description: "SCSS"
          },
          {
            value: "json",
            description: "JSON"
          },
          {
            value: "json5",
            description: "JSON5"
          },
          {
            value: "jsonc",
            description: "JSON with Comments"
          },
          {
            value: "json-stringify",
            description: "JSON.stringify"
          },
          {
            value: "graphql",
            description: "GraphQL"
          },
          {
            value: "markdown",
            description: "Markdown"
          },
          {
            value: "mdx",
            description: "MDX"
          },
          {
            value: "vue",
            description: "Vue"
          },
          {
            value: "yaml",
            description: "YAML"
          },
          {
            value: "glimmer",
            description: "Ember / Handlebars"
          },
          {
            value: "html",
            description: "HTML"
          },
          {
            value: "angular",
            description: "Angular"
          },
          {
            value: "lwc",
            description: "Lightning Web Components"
          },
          {
            value: "mjml",
            description: "MJML"
          }
        ]
      },
      plugins: {
        type: "path",
        array: !0,
        default: [
          {
            value: []
          }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (value) => typeof value == "string" || typeof value == "object",
        cliName: "plugin",
        cliCategory: "Config"
      },
      printWidth: {
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
          start: 0,
          end: 1 / 0,
          step: 1
        }
      },
      rangeEnd: {
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
          start: 0,
          end: 1 / 0,
          step: 1
        },
        description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`,
        cliCategory: "Editor"
      },
      rangeStart: {
        category: "Special",
        type: "int",
        default: 0,
        range: {
          start: 0,
          end: 1 / 0,
          step: 1
        },
        description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`,
        cliCategory: "Editor"
      },
      requirePragma: {
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.",
        cliCategory: "Other"
      },
      tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
          start: 0,
          end: 1 / 0,
          step: 1
        }
      },
      useTabs: {
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
      },
      embeddedLanguageFormatting: {
        category: "Global",
        type: "choice",
        default: "auto",
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
          {
            value: "auto",
            description: "Format embedded code if Prettier can automatically identify it."
          },
          {
            value: "off",
            description: "Never automatically format embedded code."
          }
        ]
      }
    };
    arrayToReversed = Array.prototype.toReversed ?? function() {
      return [...this].reverse();
    }, toReversed = createMethodShim2("toReversed", function() {
      if (Array.isArray(this))
        return arrayToReversed;
    }), method_to_reversed_default = toReversed, import_n_readlines = __toESM(require_readlines(), 1);
    get_interpreter_default = getInterpreter, getFileBasename = (file) => {
      try {
        return path11.basename(toPath(file));
      } catch {
        return "";
      }
    };
    getLanguageByInterpreter = getLanguageByInterpreterNodejs;
    infer_parser_default = inferParser;
    normalize_options_default = normalizeOptions, arrayFindLast = Array.prototype.findLast ?? function(callback) {
      for (let index = this.length - 1; index >= 0; index--) {
        let element = this[index];
        if (callback(element, index, this))
          return element;
      }
    }, findLast = createMethodShim2("findLast", function() {
      if (Array.isArray(this))
        return arrayFindLast;
    }), method_find_last_default = findLast, FRONT_MATTER_MARK = Symbol.for("PRETTIER_IS_FRONT_MATTER"), FRONT_MATTER_VISITOR_KEYS = [];
    is_front_matter_default = isFrontMatter, {
      hardline: hardline22,
      markAsRoot: markAsRoot2
    } = builders, SUPPORTED_EMBED_LANGUAGES = /* @__PURE__ */ new Set(["yaml", "toml"]), isEmbedFrontMatter = ({
      node
    }) => is_front_matter_default(node) && SUPPORTED_EMBED_LANGUAGES.has(node.language);
    clean_default = clean;
    print_default = printFrontMatter, nonTraversableKeys = /* @__PURE__ */ new Set([
      "tokens",
      "comments",
      "parent",
      "enclosingNode",
      "precedingNode",
      "followingNode"
    ]), defaultGetVisitorKeys = (node) => Object.keys(node).filter((key2) => !nonTraversableKeys.has(key2));
    create_get_visitor_keys_function_default = createGetVisitorKeysFunction;
    normalizedPrinters = /* @__PURE__ */ new WeakMap(), PRINTER_NORMALIZED_MARK = Symbol("PRINTER_NORMALIZED_MARK");
    PRINTER_FRONT_MATTER_SUPPORT_FEATURES = ["clean", "embed", "print"], PRINTER_FRONT_MATTER_SUPPORT_OFF = Object.fromEntries(PRINTER_FRONT_MATTER_SUPPORT_FEATURES.map((feature) => [feature, !1]));
    formatOptionsHiddenDefaults = {
      astFormat: "estree",
      printer: {},
      originalText: void 0,
      locStart: null,
      locEnd: null,
      getVisitorKeys: null
    };
    normalize_format_options_default = normalizeFormatOptions;
    parse_default = parse5, {
      stripTrailingHardline: stripTrailingHardline2
    } = utils;
    print_ignored_default = printIgnored, {
      cursor: cursor2
    } = builders;
    get_cursor_node_default = getCursorLocation;
    massage_ast_default = massageAst, arrayFindLastIndex = Array.prototype.findLastIndex ?? function(callback) {
      for (let index = this.length - 1; index >= 0; index--) {
        let element = this[index];
        if (callback(element, index, this))
          return index;
      }
      return -1;
    }, findLastIndex = createMethodShim2("findLastIndex", function() {
      if (Array.isArray(this))
        return arrayFindLastIndex;
    }), method_find_last_index_default = findLastIndex, isJsonParser = ({
      parser
    }) => parser === "json" || parser === "json5" || parser === "jsonc" || parser === "json-stringify";
    jsonSourceElements = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), graphqlSourceElements = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
    ({
      addAlignmentToDoc: addAlignmentToDoc2,
      hardline: hardline3
    } = builders), {
      printDocToString: printDocToStringWithoutNormalizeOptions
    } = printer, BOM = "\uFEFF", CURSOR = Symbol("cursor");
    option_categories_exports = {};
    __export3(option_categories_exports, {
      CATEGORY_CONFIG: () => CATEGORY_CONFIG,
      CATEGORY_EDITOR: () => CATEGORY_EDITOR,
      CATEGORY_FORMAT: () => CATEGORY_FORMAT,
      CATEGORY_GLOBAL: () => CATEGORY_GLOBAL,
      CATEGORY_OTHER: () => CATEGORY_OTHER,
      CATEGORY_OUTPUT: () => CATEGORY_OUTPUT,
      CATEGORY_SPECIAL: () => CATEGORY_SPECIAL
    });
    CATEGORY_CONFIG = "Config", CATEGORY_EDITOR = "Editor", CATEGORY_FORMAT = "Format", CATEGORY_OTHER = "Other", CATEGORY_OUTPUT = "Output", CATEGORY_GLOBAL = "Global", CATEGORY_SPECIAL = "Special", languages_evaluate_default = [
      {
        name: "CSS",
        type: "markup",
        aceMode: "css",
        extensions: [
          ".css",
          ".wxss"
        ],
        tmScope: "source.css",
        codemirrorMode: "css",
        codemirrorMimeType: "text/css",
        parsers: [
          "css"
        ],
        vscodeLanguageIds: [
          "css"
        ],
        linguistLanguageId: 50
      },
      {
        name: "PostCSS",
        type: "markup",
        aceMode: "text",
        extensions: [
          ".pcss",
          ".postcss"
        ],
        tmScope: "source.postcss",
        group: "CSS",
        parsers: [
          "css"
        ],
        vscodeLanguageIds: [
          "postcss"
        ],
        linguistLanguageId: 262764437
      },
      {
        name: "Less",
        type: "markup",
        aceMode: "less",
        extensions: [
          ".less"
        ],
        tmScope: "source.css.less",
        aliases: [
          "less-css"
        ],
        codemirrorMode: "css",
        codemirrorMimeType: "text/x-less",
        parsers: [
          "less"
        ],
        vscodeLanguageIds: [
          "less"
        ],
        linguistLanguageId: 198
      },
      {
        name: "SCSS",
        type: "markup",
        aceMode: "scss",
        extensions: [
          ".scss"
        ],
        tmScope: "source.css.scss",
        codemirrorMode: "css",
        codemirrorMimeType: "text/x-scss",
        parsers: [
          "scss"
        ],
        vscodeLanguageIds: [
          "scss"
        ],
        linguistLanguageId: 329
      }
    ], common_options_evaluate_default = {
      bracketSpacing: {
        category: "Common",
        type: "boolean",
        default: !0,
        description: "Print spaces between brackets.",
        oppositeDescription: "Do not print spaces between brackets."
      },
      objectWrap: {
        category: "Common",
        type: "choice",
        default: "preserve",
        description: "How to wrap object literals.",
        choices: [
          {
            value: "preserve",
            description: "Keep as multi-line, if there is a newline between the opening brace and first property."
          },
          {
            value: "collapse",
            description: "Fit to a single line when possible."
          }
        ]
      },
      singleQuote: {
        category: "Common",
        type: "boolean",
        default: !1,
        description: "Use single quotes instead of double quotes."
      },
      proseWrap: {
        category: "Common",
        type: "choice",
        default: "preserve",
        description: "How to wrap prose.",
        choices: [
          {
            value: "always",
            description: "Wrap prose if it exceeds the print width."
          },
          {
            value: "never",
            description: "Do not wrap prose."
          },
          {
            value: "preserve",
            description: "Wrap prose as-is."
          }
        ]
      },
      bracketSameLine: {
        category: "Common",
        type: "boolean",
        default: !1,
        description: "Put > of opening tags on the last line instead of on a new line."
      },
      singleAttributePerLine: {
        category: "Common",
        type: "boolean",
        default: !1,
        description: "Enforce single attribute per line in HTML, Vue and JSX."
      }
    }, options = {
      singleQuote: common_options_evaluate_default.singleQuote
    }, options_default = options, languages_evaluate_default2 = [
      {
        name: "GraphQL",
        type: "data",
        aceMode: "graphqlschema",
        extensions: [
          ".graphql",
          ".gql",
          ".graphqls"
        ],
        tmScope: "source.graphql",
        parsers: [
          "graphql"
        ],
        vscodeLanguageIds: [
          "graphql"
        ],
        linguistLanguageId: 139
      }
    ], options2 = {
      bracketSpacing: common_options_evaluate_default.bracketSpacing
    }, options_default2 = options2, languages_evaluate_default3 = [
      {
        name: "Handlebars",
        type: "markup",
        aceMode: "handlebars",
        extensions: [
          ".handlebars",
          ".hbs"
        ],
        tmScope: "text.html.handlebars",
        aliases: [
          "hbs",
          "htmlbars"
        ],
        parsers: [
          "glimmer"
        ],
        vscodeLanguageIds: [
          "handlebars"
        ],
        linguistLanguageId: 155
      }
    ], languages_evaluate_default4 = [
      {
        name: "Angular",
        type: "markup",
        aceMode: "html",
        extensions: [
          ".component.html"
        ],
        tmScope: "text.html.basic",
        aliases: [
          "xhtml"
        ],
        codemirrorMode: "htmlmixed",
        codemirrorMimeType: "text/html",
        parsers: [
          "angular"
        ],
        vscodeLanguageIds: [
          "html"
        ],
        filenames: [],
        linguistLanguageId: 146
      },
      {
        name: "HTML",
        type: "markup",
        aceMode: "html",
        extensions: [
          ".html",
          ".hta",
          ".htm",
          ".html.hl",
          ".inc",
          ".xht",
          ".xhtml"
        ],
        tmScope: "text.html.basic",
        aliases: [
          "xhtml"
        ],
        codemirrorMode: "htmlmixed",
        codemirrorMimeType: "text/html",
        parsers: [
          "html"
        ],
        vscodeLanguageIds: [
          "html"
        ],
        linguistLanguageId: 146
      },
      {
        name: "Lightning Web Components",
        type: "markup",
        aceMode: "html",
        extensions: [],
        tmScope: "text.html.basic",
        aliases: [
          "xhtml"
        ],
        codemirrorMode: "htmlmixed",
        codemirrorMimeType: "text/html",
        parsers: [
          "lwc"
        ],
        vscodeLanguageIds: [
          "html"
        ],
        filenames: [],
        linguistLanguageId: 146
      },
      {
        name: "MJML",
        type: "markup",
        aceMode: "html",
        extensions: [
          ".mjml"
        ],
        tmScope: "text.mjml.basic",
        aliases: [
          "MJML",
          "mjml"
        ],
        codemirrorMode: "htmlmixed",
        codemirrorMimeType: "text/html",
        parsers: [
          "mjml"
        ],
        filenames: [],
        vscodeLanguageIds: [
          "mjml"
        ],
        linguistLanguageId: 146
      },
      {
        name: "Vue",
        type: "markup",
        aceMode: "vue",
        extensions: [
          ".vue"
        ],
        tmScope: "source.vue",
        codemirrorMode: "vue",
        codemirrorMimeType: "text/x-vue",
        parsers: [
          "vue"
        ],
        vscodeLanguageIds: [
          "vue"
        ],
        linguistLanguageId: 391
      }
    ], CATEGORY_HTML = "HTML", options3 = {
      bracketSameLine: common_options_evaluate_default.bracketSameLine,
      htmlWhitespaceSensitivity: {
        category: CATEGORY_HTML,
        type: "choice",
        default: "css",
        description: "How to handle whitespaces in HTML.",
        choices: [
          {
            value: "css",
            description: "Respect the default value of CSS display property."
          },
          {
            value: "strict",
            description: "Whitespaces are considered sensitive."
          },
          {
            value: "ignore",
            description: "Whitespaces are considered insensitive."
          }
        ]
      },
      singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine,
      vueIndentScriptAndStyle: {
        category: CATEGORY_HTML,
        type: "boolean",
        default: !1,
        description: "Indent script and style tags in Vue files."
      }
    }, options_default3 = options3, languages_evaluate_default5 = [
      {
        name: "JavaScript",
        type: "programming",
        aceMode: "javascript",
        extensions: [
          ".js",
          "._js",
          ".bones",
          ".cjs",
          ".es",
          ".es6",
          ".gs",
          ".jake",
          ".javascript",
          ".jsb",
          ".jscad",
          ".jsfl",
          ".jslib",
          ".jsm",
          ".jspre",
          ".jss",
          ".mjs",
          ".njs",
          ".pac",
          ".sjs",
          ".ssjs",
          ".xsjs",
          ".xsjslib",
          ".start.frag",
          ".end.frag",
          ".wxs"
        ],
        filenames: [
          "Jakefile",
          "start.frag",
          "end.frag"
        ],
        tmScope: "source.js",
        aliases: [
          "js",
          "node"
        ],
        codemirrorMode: "javascript",
        codemirrorMimeType: "text/javascript",
        interpreters: [
          "chakra",
          "d8",
          "gjs",
          "js",
          "node",
          "nodejs",
          "qjs",
          "rhino",
          "v8",
          "v8-shell",
          "zx"
        ],
        parsers: [
          "babel",
          "acorn",
          "espree",
          "meriyah",
          "babel-flow",
          "babel-ts",
          "flow",
          "typescript"
        ],
        vscodeLanguageIds: [
          "javascript",
          "mongo"
        ],
        linguistLanguageId: 183
      },
      {
        name: "Flow",
        type: "programming",
        aceMode: "javascript",
        extensions: [
          ".js.flow"
        ],
        filenames: [],
        tmScope: "source.js",
        aliases: [],
        codemirrorMode: "javascript",
        codemirrorMimeType: "text/javascript",
        interpreters: [
          "chakra",
          "d8",
          "gjs",
          "js",
          "node",
          "nodejs",
          "qjs",
          "rhino",
          "v8",
          "v8-shell"
        ],
        parsers: [
          "flow",
          "babel-flow"
        ],
        vscodeLanguageIds: [
          "javascript"
        ],
        linguistLanguageId: 183
      },
      {
        name: "JSX",
        type: "programming",
        aceMode: "javascript",
        extensions: [
          ".jsx"
        ],
        filenames: void 0,
        tmScope: "source.js.jsx",
        aliases: void 0,
        codemirrorMode: "jsx",
        codemirrorMimeType: "text/jsx",
        interpreters: void 0,
        parsers: [
          "babel",
          "babel-flow",
          "babel-ts",
          "flow",
          "typescript",
          "espree",
          "meriyah"
        ],
        vscodeLanguageIds: [
          "javascriptreact"
        ],
        group: "JavaScript",
        linguistLanguageId: 183
      },
      {
        name: "TypeScript",
        type: "programming",
        aceMode: "typescript",
        extensions: [
          ".ts",
          ".cts",
          ".mts"
        ],
        tmScope: "source.ts",
        aliases: [
          "ts"
        ],
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/typescript",
        interpreters: [
          "bun",
          "deno",
          "ts-node",
          "tsx"
        ],
        parsers: [
          "typescript",
          "babel-ts"
        ],
        vscodeLanguageIds: [
          "typescript"
        ],
        linguistLanguageId: 378
      },
      {
        name: "TSX",
        type: "programming",
        aceMode: "tsx",
        extensions: [
          ".tsx"
        ],
        tmScope: "source.tsx",
        codemirrorMode: "jsx",
        codemirrorMimeType: "text/typescript-jsx",
        group: "TypeScript",
        parsers: [
          "typescript",
          "babel-ts"
        ],
        vscodeLanguageIds: [
          "typescriptreact"
        ],
        linguistLanguageId: 94901924
      }
    ], CATEGORY_JAVASCRIPT = "JavaScript", options4 = {
      arrowParens: {
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: "always",
        description: "Include parentheses around a sole arrow function parameter.",
        choices: [
          {
            value: "always",
            description: "Always include parens. Example: `(x) => x`"
          },
          {
            value: "avoid",
            description: "Omit parens when possible. Example: `x => x`"
          }
        ]
      },
      bracketSameLine: common_options_evaluate_default.bracketSameLine,
      objectWrap: common_options_evaluate_default.objectWrap,
      bracketSpacing: common_options_evaluate_default.bracketSpacing,
      jsxBracketSameLine: {
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        description: "Put > on the last line instead of at a new line.",
        deprecated: "2.4.0"
      },
      semi: {
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        default: !0,
        description: "Print semicolons.",
        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
      },
      experimentalOperatorPosition: {
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: "end",
        description: "Where to print operators when binary expressions wrap lines.",
        choices: [
          {
            value: "start",
            description: "Print operators at the start of new lines."
          },
          {
            value: "end",
            description: "Print operators at the end of previous lines."
          }
        ]
      },
      experimentalTernaries: {
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        default: !1,
        description: "Use curious ternaries, with the question mark after the condition.",
        oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent."
      },
      singleQuote: common_options_evaluate_default.singleQuote,
      jsxSingleQuote: {
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        default: !1,
        description: "Use single quotes in JSX."
      },
      quoteProps: {
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: "as-needed",
        description: "Change when properties in objects are quoted.",
        choices: [
          {
            value: "as-needed",
            description: "Only add quotes around object properties where required."
          },
          {
            value: "consistent",
            description: "If at least one property in an object requires quotes, quote all properties."
          },
          {
            value: "preserve",
            description: "Respect the input use of quotes in object properties."
          }
        ]
      },
      trailingComma: {
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: "all",
        description: "Print trailing commas wherever possible when multi-line.",
        choices: [
          {
            value: "all",
            description: "Trailing commas wherever possible (including function arguments)."
          },
          {
            value: "es5",
            description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
          },
          { value: "none", description: "No trailing commas." }
        ]
      },
      singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine
    }, options_default4 = options4, languages_evaluate_default6 = [
      {
        name: "JSON.stringify",
        type: "data",
        aceMode: "json",
        extensions: [
          ".importmap"
        ],
        filenames: [
          "package.json",
          "package-lock.json",
          "composer.json"
        ],
        tmScope: "source.json",
        aliases: [
          "geojson",
          "jsonl",
          "sarif",
          "topojson"
        ],
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/json",
        parsers: [
          "json-stringify"
        ],
        vscodeLanguageIds: [
          "json"
        ],
        linguistLanguageId: 174
      },
      {
        name: "JSON",
        type: "data",
        aceMode: "json",
        extensions: [
          ".json",
          ".4DForm",
          ".4DProject",
          ".avsc",
          ".geojson",
          ".gltf",
          ".har",
          ".ice",
          ".JSON-tmLanguage",
          ".json.example",
          ".mcmeta",
          ".sarif",
          ".tact",
          ".tfstate",
          ".tfstate.backup",
          ".topojson",
          ".webapp",
          ".webmanifest",
          ".yy",
          ".yyp"
        ],
        filenames: [
          ".all-contributorsrc",
          ".arcconfig",
          ".auto-changelog",
          ".c8rc",
          ".htmlhintrc",
          ".imgbotconfig",
          ".nycrc",
          ".tern-config",
          ".tern-project",
          ".watchmanconfig",
          ".babelrc",
          ".jscsrc",
          ".jshintrc",
          ".jslintrc",
          ".swcrc"
        ],
        tmScope: "source.json",
        aliases: [
          "geojson",
          "jsonl",
          "sarif",
          "topojson"
        ],
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/json",
        parsers: [
          "json"
        ],
        vscodeLanguageIds: [
          "json"
        ],
        linguistLanguageId: 174
      },
      {
        name: "JSON with Comments",
        type: "data",
        aceMode: "javascript",
        extensions: [
          ".jsonc",
          ".code-snippets",
          ".code-workspace",
          ".sublime-build",
          ".sublime-color-scheme",
          ".sublime-commands",
          ".sublime-completions",
          ".sublime-keymap",
          ".sublime-macro",
          ".sublime-menu",
          ".sublime-mousemap",
          ".sublime-project",
          ".sublime-settings",
          ".sublime-theme",
          ".sublime-workspace",
          ".sublime_metrics",
          ".sublime_session"
        ],
        filenames: [],
        tmScope: "source.json.comments",
        aliases: [
          "jsonc"
        ],
        codemirrorMode: "javascript",
        codemirrorMimeType: "text/javascript",
        group: "JSON",
        parsers: [
          "jsonc"
        ],
        vscodeLanguageIds: [
          "jsonc"
        ],
        linguistLanguageId: 423
      },
      {
        name: "JSON5",
        type: "data",
        aceMode: "json5",
        extensions: [
          ".json5"
        ],
        tmScope: "source.js",
        codemirrorMode: "javascript",
        codemirrorMimeType: "application/json",
        parsers: [
          "json5"
        ],
        vscodeLanguageIds: [
          "json5"
        ],
        linguistLanguageId: 175
      }
    ], languages_evaluate_default7 = [
      {
        name: "Markdown",
        type: "prose",
        aceMode: "markdown",
        extensions: [
          ".md",
          ".livemd",
          ".markdown",
          ".mdown",
          ".mdwn",
          ".mkd",
          ".mkdn",
          ".mkdown",
          ".ronn",
          ".scd",
          ".workbook"
        ],
        filenames: [
          "contents.lr",
          "README"
        ],
        tmScope: "text.md",
        aliases: [
          "md",
          "pandoc"
        ],
        codemirrorMode: "gfm",
        codemirrorMimeType: "text/x-gfm",
        wrap: !0,
        parsers: [
          "markdown"
        ],
        vscodeLanguageIds: [
          "markdown"
        ],
        linguistLanguageId: 222
      },
      {
        name: "MDX",
        type: "prose",
        aceMode: "markdown",
        extensions: [
          ".mdx"
        ],
        filenames: [],
        tmScope: "text.md",
        aliases: [
          "md",
          "pandoc"
        ],
        codemirrorMode: "gfm",
        codemirrorMimeType: "text/x-gfm",
        wrap: !0,
        parsers: [
          "mdx"
        ],
        vscodeLanguageIds: [
          "mdx"
        ],
        linguistLanguageId: 222
      }
    ], options5 = {
      proseWrap: common_options_evaluate_default.proseWrap,
      singleQuote: common_options_evaluate_default.singleQuote
    }, options_default5 = options5, languages_evaluate_default8 = [
      {
        name: "YAML",
        type: "data",
        aceMode: "yaml",
        extensions: [
          ".yml",
          ".mir",
          ".reek",
          ".rviz",
          ".sublime-syntax",
          ".syntax",
          ".yaml",
          ".yaml-tmlanguage",
          ".yaml.sed",
          ".yml.mysql"
        ],
        filenames: [
          ".clang-format",
          ".clang-tidy",
          ".clangd",
          ".gemrc",
          "CITATION.cff",
          "glide.lock",
          "pixi.lock",
          ".prettierrc",
          ".stylelintrc",
          ".lintstagedrc"
        ],
        tmScope: "source.yaml",
        aliases: [
          "yml"
        ],
        codemirrorMode: "yaml",
        codemirrorMimeType: "text/x-yaml",
        parsers: [
          "yaml"
        ],
        vscodeLanguageIds: [
          "yaml",
          "ansible",
          "dockercompose",
          "github-actions-workflow",
          "home-assistant"
        ],
        linguistLanguageId: 407
      }
    ], options6 = {
      bracketSpacing: common_options_evaluate_default.bracketSpacing,
      singleQuote: common_options_evaluate_default.singleQuote,
      proseWrap: common_options_evaluate_default.proseWrap
    }, options_default6 = options6;
    estreePlugin = createParsersAndPrinters([
      {
        importPlugin: () => import("./estree-PY6WKTNG.js"),
        printers: ["estree", "estree-json"]
      }
    ]), options7 = {
      ...options_default,
      ...options_default2,
      ...options_default3,
      ...options_default4,
      ...options_default5,
      ...options_default6
    }, languages = [
      ...languages_evaluate_default,
      ...languages_evaluate_default2,
      ...languages_evaluate_default3,
      ...languages_evaluate_default4,
      ...languages_evaluate_default5,
      ...languages_evaluate_default6,
      ...languages_evaluate_default7,
      ...languages_evaluate_default8
    ], { parsers, printers } = createParsersAndPrinters([
      {
        importPlugin: () => import("./acorn-45LE5Z2A.js"),
        parsers: ["acorn", "espree"]
      },
      {
        importPlugin: () => import("./angular-Z5FPQPLR.js"),
        parsers: [
          "__ng_action",
          "__ng_binding",
          "__ng_interpolation",
          "__ng_directive"
        ]
      },
      {
        importPlugin: () => import("./babel-TRRZ6QQY.js"),
        parsers: [
          "babel",
          "babel-flow",
          "babel-ts",
          "__js_expression",
          "__ts_expression",
          "__vue_expression",
          "__vue_ts_expression",
          "__vue_event_binding",
          "__vue_ts_event_binding",
          "__babel_estree",
          "json",
          "json5",
          "jsonc",
          "json-stringify"
        ]
      },
      {
        importPlugin: () => import("./flow-YN54TSCB.js"),
        parsers: ["flow"]
      },
      {
        importPlugin: () => import("./glimmer-RMPUUUDS.js"),
        parsers: ["glimmer"],
        printers: ["glimmer"]
      },
      {
        importPlugin: () => import("./graphql-PPLVYWBL.js"),
        parsers: ["graphql"],
        printers: ["graphql"]
      },
      {
        importPlugin: () => import("./html-3U6QZZZ4.js"),
        parsers: ["html", "angular", "vue", "lwc", "mjml"],
        printers: ["html"]
      },
      {
        importPlugin: () => import("./markdown-RHRQTUMC.js"),
        parsers: ["markdown", "mdx", "remark"],
        printers: ["mdast"]
      },
      {
        importPlugin: () => import("./meriyah-7MIMHTWQ.js"),
        parsers: ["meriyah"]
      },
      {
        importPlugin: () => import("./postcss-MSOPGY7M.js"),
        parsers: ["css", "less", "scss"],
        printers: ["postcss"]
      },
      {
        importPlugin: () => import("./typescript-ZSZVUJZX.js"),
        parsers: ["typescript"]
      },
      {
        importPlugin: () => import("./yaml-6GALFXQY.js"),
        parsers: ["yaml"],
        printers: ["yaml"]
      }
    ]), builtin_plugins_proxy_default = [estreePlugin, { options: options7, languages, parsers, printers }];
    load_builtin_plugins_default = loadBuiltinPlugins;
    import_from_directory_default = importFromDirectory;
    cache2 = /* @__PURE__ */ new Map();
    load_plugins_default = loadPlugins, import_ignore = __toESM(require_ignore(), 1), slash = path14.sep === "\\" ? (filePath) => method_replace_all_default2(
      /* OPTIONAL_OBJECT: false */
      0,
      filePath,
      "\\",
      "/"
    ) : (filePath) => filePath;
    object_omit_default = omit;
    get_file_info_default = getFileInfo, version_evaluate_default = "3.7.4", public_exports2 = {};
    __export3(public_exports2, {
      addDanglingComment: () => addDanglingComment,
      addLeadingComment: () => addLeadingComment,
      addTrailingComment: () => addTrailingComment,
      getAlignmentSize: () => get_alignment_size_default,
      getIndentSize: () => get_indent_size_default,
      getMaxContinuousCount: () => get_max_continuous_count_default,
      getNextNonSpaceNonCommentCharacter: () => get_next_non_space_non_comment_character_default,
      getNextNonSpaceNonCommentCharacterIndex: () => getNextNonSpaceNonCommentCharacterIndex2,
      getPreferredQuote: () => get_preferred_quote_default,
      getStringWidth: () => get_string_width_default2,
      hasNewline: () => has_newline_default,
      hasNewlineInRange: () => has_newline_in_range_default,
      hasSpaces: () => has_spaces_default,
      isNextLineEmpty: () => isNextLineEmpty2,
      isNextLineEmptyAfterIndex: () => is_next_line_empty_default,
      isPreviousLineEmpty: () => isPreviousLineEmpty2,
      makeString: () => makeString,
      skip: () => skip,
      skipEverythingButNewLine: () => skipEverythingButNewLine,
      skipInlineComment: () => skip_inline_comment_default,
      skipNewline: () => skip_newline_default,
      skipSpaces: () => skipSpaces,
      skipToLineEnd: () => skipToLineEnd,
      skipTrailingComment: () => skip_trailing_comment_default,
      skipWhitespace: () => skipWhitespace
    });
    skip_inline_comment_default = skipInlineComment;
    skip_trailing_comment_default = skipTrailingComment;
    get_next_non_space_non_comment_character_index_default = getNextNonSpaceNonCommentCharacterIndex;
    is_next_line_empty_default = isNextLineEmpty;
    get_indent_size_default = getIndentSize;
    get_max_continuous_count_default = getMaxContinuousCount;
    get_next_non_space_non_comment_character_default = getNextNonSpaceNonCommentCharacter, SINGLE_QUOTE = "'", DOUBLE_QUOTE = '"', SINGLE_QUOTE_DATA = Object.freeze({
      character: SINGLE_QUOTE,
      codePoint: 39
    }), DOUBLE_QUOTE_DATA = Object.freeze({
      character: DOUBLE_QUOTE,
      codePoint: 34
    }), SINGLE_QUOTE_SETTINGS = Object.freeze({
      preferred: SINGLE_QUOTE_DATA,
      alternate: DOUBLE_QUOTE_DATA
    }), DOUBLE_QUOTE_SETTINGS = Object.freeze({
      preferred: DOUBLE_QUOTE_DATA,
      alternate: SINGLE_QUOTE_DATA
    });
    get_preferred_quote_default = getPreferredQuote;
    has_newline_in_range_default = hasNewlineInRange;
    has_spaces_default = hasSpaces;
    formatWithCursor2 = withPlugins(formatWithCursor);
    getSupportInfo2 = withPlugins(getSupportInfo, 0), inferParser2 = withPlugins(
      (file, options8) => infer_parser_default(options8, { physicalFile: file })
    ), sharedWithCli = {
      errors: errors_exports,
      optionCategories: option_categories_exports,
      createIsIgnoredFunction,
      formatOptionsHiddenDefaults,
      normalizeOptions: normalize_options_default,
      getSupportInfoWithoutPlugins: getSupportInfo,
      normalizeOptionSettings,
      inferParser: (file, options8) => Promise.resolve(options8?.parser ?? inferParser2(file, options8)),
      vnopts: {
        ChoiceSchema,
        apiDescriptor
      },
      fastGlob: import_fast_glob.default,
      createTwoFilesPatch,
      picocolors: import_picocolors5.default,
      closetLevenshteinMatch: closestMatch,
      utilities: {
        omit: object_omit_default,
        createMockable: create_mockable_default
      }
    }, debugApis = {
      parse: withPlugins(parse6),
      formatAST: withPlugins(formatAst),
      formatDoc: withPlugins(formatDoc),
      printToDoc: withPlugins(printToDoc),
      printDocToString: withPlugins(printDocToString2),
      // Exposed for tests
      mockable
    };
  }
});
init_prettier();
export {
  debugApis as __debug,
  sharedWithCli as __internal,
  check,
  clearCache3 as clearConfigCache,
  index_exports as default,
  doc_exports as doc,
  format2 as format,
  formatWithCursor2 as formatWithCursor,
  get_file_info_default as getFileInfo,
  getSupportInfo2 as getSupportInfo,
  resolveConfig,
  resolveConfigFile,
  public_exports2 as util,
  version_evaluate_default as version
};
//# sourceMappingURL=prettier-2ITB6I34.js.map
