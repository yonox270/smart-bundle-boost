import {
  __esm,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/plugins/angular.mjs
function on({ start: e22, end: t }, n) {
  let s = e22, r = t;
  for (; r !== s && /\s/.test(n[r - 1]); ) r--;
  for (; s !== r && /\s/.test(n[s]); ) s++;
  return { start: s, end: r };
}
function Us({ start: e22, end: t }, n) {
  let s = e22, r = t;
  for (; r !== n.length && /\s/.test(n[r]); ) r++;
  for (; s !== 0 && /\s/.test(n[s - 1]); ) s--;
  return { start: s, end: r };
}
function Ws(e22, t) {
  return t[e22.start - 1] === "(" && t[e22.end] === ")" ? { start: e22.start - 1, end: e22.end + 1 } : e22;
}
function ln(e22, t, n) {
  let s = 0, r = { start: e22.start, end: e22.end };
  for (; ; ) {
    let i = Us(r, t), o = Ws(i, t);
    if (i.start === o.start && i.end === o.end) break;
    r.start = o.start, r.end = o.end, s++;
  }
  return { hasParens: (n ? s - 1 : s) !== 0, outerSpan: on(n ? { start: r.start + 1, end: r.end - 1 } : r, t), innerSpan: on(e22, t) };
}
function cn(e22) {
  return typeof e22 == "string" ? (t) => t === e22 : (t) => e22.test(t);
}
function un(e22, t, n) {
  let s = cn(t);
  for (let r = n; r >= 0; r--) {
    let i = e22[r];
    if (s(i)) return r;
  }
  throw new Error(`Cannot find front char ${t} from index ${n} in ${JSON.stringify(e22)}`);
}
function hn(e22, t, n) {
  let s = cn(t);
  for (let r = n; r < e22.length; r++) {
    let i = e22[r];
    if (s(i)) return r;
  }
  throw new Error(`Cannot find character ${t} from index ${n} in ${JSON.stringify(e22)}`);
}
function pn(e22) {
  return e22.slice(0, 1).toLowerCase() + e22.slice(1);
}
function Ee(e22) {
  let { start: t, end: n } = e22;
  return { start: t, end: n, range: [t, n] };
}
function qs(e22, t) {
  return e22 == null || t == null ? e22 == t : e22.isEquivalent(t);
}
function js(e22, t, n) {
  let s = e22.length;
  if (s !== t.length) return !1;
  for (let r = 0; r < s; r++) if (!n(e22[r], t[r])) return !1;
  return !0;
}
function at(e22, t) {
  return js(e22, t, (n, s) => n.isEquivalent(s));
}
function zs(e22, t, n) {
  return new Je(e22, t, n);
}
function pr(e22) {
  return e22 >= as && e22 <= os || e22 == ds;
}
function W(e22) {
  return tr <= e22 && e22 <= nr;
}
function Lt(e22) {
  return e22 >= ps && e22 <= fs || e22 >= Ut && e22 <= Wt;
}
function Mn(e22) {
  return e22 === cs || e22 === ls || e22 === Pt;
}
function _e(e22, t, n) {
  return new I(e22, t, p.Character, n, String.fromCharCode(n));
}
function Tr(e22, t, n) {
  return new I(e22, t, p.Identifier, 0, n);
}
function br(e22, t, n) {
  return new I(e22, t, p.PrivateIdentifier, 0, n);
}
function Ar(e22, t, n) {
  return new I(e22, t, p.Keyword, 0, n);
}
function Ce(e22, t, n) {
  return new I(e22, t, p.Operator, 0, n);
}
function Ir(e22, t, n) {
  return new I(e22, t, p.Number, n, "");
}
function Nr(e22, t, n) {
  return new I(e22, t, p.Error, 0, n);
}
function Pr(e22, t, n) {
  return new I(e22, t, p.RegExpBody, 0, n);
}
function Lr(e22, t, n) {
  return new I(e22, t, p.RegExpFlags, 0, n);
}
function Zn(e22) {
  return ps <= e22 && e22 <= fs || Ut <= e22 && e22 <= Wt || e22 == ot || e22 == Ht;
}
function es(e22) {
  return Lt(e22) || W(e22) || e22 == ot || e22 == Ht;
}
function Mr(e22) {
  return e22 == ir || e22 == sr;
}
function Rr(e22) {
  return e22 == hs || e22 == us;
}
function $r(e22) {
  switch (e22) {
    case or:
      return Xe;
    case ar:
      return Xs;
    case lr:
      return Js;
    case cr:
      return as;
    case hr:
      return Gs;
    default:
      return e22;
  }
}
function Dr(e22) {
  let t = parseInt(e22);
  if (isNaN(t)) throw new Error("Invalid integer literal when parsing " + e22);
  return t;
}
function O(e22) {
  return e22.start.toString() || "(unknown)";
}
function oe(e22, t, n, s) {
  n.length > 0 && (n = ` ${n} `);
  let r = O(s), i = `Parser Error: ${e22}${n}[${t}] in ${r}`;
  return new Mt(s, i);
}
function Br(e22) {
  let t = /* @__PURE__ */ new Map(), n = 0, s = 0, r = 0;
  for (; r < e22.length; ) {
    let i = e22[r];
    if (i.type === 9) {
      let [o, c] = i.parts;
      n += c.length, s += o.length;
    } else {
      let o = i.parts.reduce((c, h) => c + h.length, 0);
      s += o, n += o;
    }
    t.set(s, n), r++;
  }
  return t;
}
function D(e22) {
  return (t) => t.kind === e22;
}
function Ne(e22, t) {
  return (n) => n.kind === e22 && t === n.expression instanceof rt;
}
function Fr(e22) {
  return (e22.kind === f.Property || e22.kind === f.TwoWayProperty) && !(e22.expression instanceof rt);
}
function it(e22) {
  return e22.slice(e22.length - 1);
}
function qe(e22 = "test.html") {
  let t = new et(new tt("", e22), 0, 0, 0);
  return new nt(t, t);
}
function Ur(e22, t) {
  let n = t ? Hr(e22) : null;
  if (n === null) return { text: e22, comments: [] };
  let s = { type: "CommentLine", value: e22.slice(n + 2), ...Ee({ start: n, end: e22.length }) };
  return { text: e22.slice(0, n), comments: [s] };
}
function je(e22, t = !0) {
  return (n) => {
    let s = new we(new Ue()), { text: r, comments: i } = Ur(n, t), o = e22(r, s);
    if (o.errors.length !== 0) {
      let [{ message: c }] = o.errors;
      throw new SyntaxError(c.replace(/^Parser Error: | at column \d+ in [^]*$/g, ""));
    }
    return { result: o, comments: i, text: r };
  };
}
function qr(e22) {
  return this[e22 < 0 ? this.length + e22 : e22];
}
function ct(e22) {
  return !!e22.extra?.parenthesized;
}
function te(e22) {
  return ct(e22) ? e22.extra.parenStart : e22.start;
}
function ne(e22) {
  return ct(e22) ? e22.extra.parenEnd : e22.end;
}
function zt(e22) {
  return e22.type === "TSNonNullExpression" && !ct(e22) ? zt(e22.expression) : (e22.type === "OptionalCallExpression" || e22.type === "OptionalMemberExpression") && !ct(e22);
}
function Ts(e22, t) {
  let { start: n, end: s } = e22.sourceSpan;
  return n >= s || /^\s+$/.test(t.slice(n, s));
}
function bs(e22, t) {
  return new Gt(e22, t).node;
}
function As(e22) {
  return e22 instanceof He;
}
function Is(e22) {
  return e22 instanceof ge;
}
function Ds(e22, t) {
  return new zr(e22, t).expressions;
}
function ut({ result: { ast: e22 }, text: t, comments: n }) {
  return Object.assign(bs(e22, t), { comments: n });
}
function Bs({ result: { templateBindings: e22 }, text: t }) {
  return Ds(e22, t);
}
function en(e22) {
  let t = e22.range?.[0] ?? e22.start, n = (e22.declaration?.decorators ?? e22.decorators)?.[0];
  return n ? Math.min(en(n), t) : t;
}
function Os(e22) {
  return e22.range?.[1] ?? e22.end;
}
function pt(e22) {
  return { astFormat: "estree", parse(t) {
    let n = e22(t), { comments: s } = n;
    return delete n.comments, e22 === ht && n.type !== "NGChainedExpression" && (n = { ...n, type: "NGChainedExpression", expressions: [n] }), { type: "NGRoot", node: n, comments: s };
  }, locStart: en, locEnd: Os };
}
var Hs, rn, an, ft, U, ze, dt, x, Fs, tn, ei, fn, dn, mn, L, gn, vn, xn, wn, Sn, En, yn, _n, u, _, Je, gt, vt, xt, wt, Ye, St, Et, w, yt, _t, Ct, kt, Qe, Tt, bt, ti, Cn, a, l, At, ni, kn, Y, v, Pe, A, Q, It, Le, Me, X, ce, ue, he, be, Re, k, $e, De, Vt, y, J, K, Z, ee, Be, Oe, pe, fe, de, me, Fe, Ve, B, F, ge, He, Nt, Tn, bn, M, An, ye, as, Xe, Gs, Xs, Js, os, Ys, ls, Qs, Ht, Ks, In, cs, Ae, q, Nn, us, re, hs, ke, Ke, j, Te, Zs, b, er, Pn, tr, nr, Ut, sr, Wt, le, mt, G, rr, ot, ps, ir, ar, or, lr, cr, ur, hr, fs, Ze, Ln, ie, ds, Pt, et, tt, nt, st, Mt, Rn, $n, Dn, fr, ms, dr, Rt, mr, gr, qt, ii, ai, vr, oi, xr, li, gs, ci, ui, wr, Sr, Er, hi, pi, fi, f, ve, Bn, On, Fn, R, Vn, Hn, Un, Wn, $, qn, jn, yr, vs, We, jt, di, mi, gi, rt, xe, zn, Gn, Xn, Jn, $t, vi, Yn, Qn, xi, wi, Si, Ei, yi, _r, Cr, Kn, xs, _i, Ci, p, V, kr, Ue, I, Ie, Ge, Dt, Bt, Ot, we, ae, ts, z, Ft, Or, ki, Ti, bi, Ai, Ii, Ni, Pi, Li, Mi, Ri, $i, ns, Di, Bi, ss, rs, ws, Oi, Fi, is, Vi, Hr, Ss, Wr, Es, ys, _s, Cs, jr, lt, ks, Gt, Se, se, m, Ps, T, Xt, Jt, Yt, Ls, Ms, Rs, $s, Ns, zr, Qt, Kt, ht, Zt, Gr, Xr, Jr, Yr, init_angular = __esm({
  "../../node_modules/.pnpm/prettier@3.7.4/node_modules/prettier/plugins/angular.mjs"() {
    init_cjs_shims();
    Hs = Object.defineProperty, rn = (e22) => {
      throw TypeError(e22);
    }, an = (e22, t) => {
      for (var n in t) Hs(e22, n, { get: t[n], enumerable: !0 });
    }, ft = (e22, t, n) => t.has(e22) || rn("Cannot " + n), U = (e22, t, n) => (ft(e22, t, "read from private field"), n ? n.call(e22) : t.get(e22)), ze = (e22, t, n) => t.has(e22) ? rn("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e22) : t.set(e22, n), dt = (e22, t, n, s) => (ft(e22, t, "write to private field"), s ? s.call(e22, n) : t.set(e22, n), n), x = (e22, t, n) => (ft(e22, t, "access private method"), n), Fs = {};
    an(Fs, { parsers: () => tn });
    tn = {};
    an(tn, { __ng_action: () => Gr, __ng_binding: () => Xr, __ng_directive: () => Yr, __ng_interpolation: () => Jr });
    ei = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
    (function(e22) {
      e22[e22.Emulated = 0] = "Emulated", e22[e22.None = 2] = "None", e22[e22.ShadowDom = 3] = "ShadowDom", e22[e22.ExperimentalIsolatedShadowDom = 4] = "ExperimentalIsolatedShadowDom";
    })(fn || (fn = {}));
    (function(e22) {
      e22[e22.OnPush = 0] = "OnPush", e22[e22.Default = 1] = "Default";
    })(dn || (dn = {}));
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.SignalBased = 1] = "SignalBased", e22[e22.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
    })(mn || (mn = {}));
    (function(e22) {
      e22[e22.NONE = 0] = "NONE", e22[e22.HTML = 1] = "HTML", e22[e22.STYLE = 2] = "STYLE", e22[e22.SCRIPT = 3] = "SCRIPT", e22[e22.URL = 4] = "URL", e22[e22.RESOURCE_URL = 5] = "RESOURCE_URL", e22[e22.ATTRIBUTE_NO_BINDING = 6] = "ATTRIBUTE_NO_BINDING";
    })(L || (L = {}));
    (function(e22) {
      e22[e22.Error = 0] = "Error", e22[e22.Warning = 1] = "Warning", e22[e22.Ignore = 2] = "Ignore";
    })(gn || (gn = {}));
    (function(e22) {
      e22[e22.Directive = 0] = "Directive", e22[e22.Component = 1] = "Component", e22[e22.Injectable = 2] = "Injectable", e22[e22.Pipe = 3] = "Pipe", e22[e22.NgModule = 4] = "NgModule";
    })(vn || (vn = {}));
    (function(e22) {
      e22[e22.Directive = 0] = "Directive", e22[e22.Pipe = 1] = "Pipe", e22[e22.NgModule = 2] = "NgModule";
    })(xn || (xn = {}));
    (function(e22) {
      e22[e22.Emulated = 0] = "Emulated", e22[e22.None = 2] = "None", e22[e22.ShadowDom = 3] = "ShadowDom", e22[e22.ExperimentalIsolatedShadowDom = 4] = "ExperimentalIsolatedShadowDom";
    })(wn || (wn = {}));
    (function(e22) {
      e22[e22.Little = 0] = "Little", e22[e22.Big = 1] = "Big";
    })(Sn || (Sn = {}));
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.Const = 1] = "Const";
    })(En || (En = {}));
    (function(e22) {
      e22[e22.Dynamic = 0] = "Dynamic", e22[e22.Bool = 1] = "Bool", e22[e22.String = 2] = "String", e22[e22.Int = 3] = "Int", e22[e22.Number = 4] = "Number", e22[e22.Function = 5] = "Function", e22[e22.Inferred = 6] = "Inferred", e22[e22.None = 7] = "None";
    })(yn || (yn = {}));
    (function(e22) {
      e22[e22.Minus = 0] = "Minus", e22[e22.Plus = 1] = "Plus";
    })(_n || (_n = {}));
    (function(e22) {
      e22[e22.Equals = 0] = "Equals", e22[e22.NotEquals = 1] = "NotEquals", e22[e22.Assign = 2] = "Assign", e22[e22.Identical = 3] = "Identical", e22[e22.NotIdentical = 4] = "NotIdentical", e22[e22.Minus = 5] = "Minus", e22[e22.Plus = 6] = "Plus", e22[e22.Divide = 7] = "Divide", e22[e22.Multiply = 8] = "Multiply", e22[e22.Modulo = 9] = "Modulo", e22[e22.And = 10] = "And", e22[e22.Or = 11] = "Or", e22[e22.BitwiseOr = 12] = "BitwiseOr", e22[e22.BitwiseAnd = 13] = "BitwiseAnd", e22[e22.Lower = 14] = "Lower", e22[e22.LowerEquals = 15] = "LowerEquals", e22[e22.Bigger = 16] = "Bigger", e22[e22.BiggerEquals = 17] = "BiggerEquals", e22[e22.NullishCoalesce = 18] = "NullishCoalesce", e22[e22.Exponentiation = 19] = "Exponentiation", e22[e22.In = 20] = "In", e22[e22.AdditionAssignment = 21] = "AdditionAssignment", e22[e22.SubtractionAssignment = 22] = "SubtractionAssignment", e22[e22.MultiplicationAssignment = 23] = "MultiplicationAssignment", e22[e22.DivisionAssignment = 24] = "DivisionAssignment", e22[e22.RemainderAssignment = 25] = "RemainderAssignment", e22[e22.ExponentiationAssignment = 26] = "ExponentiationAssignment", e22[e22.AndAssignment = 27] = "AndAssignment", e22[e22.OrAssignment = 28] = "OrAssignment", e22[e22.NullishCoalesceAssignment = 29] = "NullishCoalesceAssignment";
    })(u || (u = {}));
    _ = class {
      type;
      sourceSpan;
      constructor(t, n) {
        this.type = t || null, this.sourceSpan = n || null;
      }
      prop(t, n) {
        return new yt(this, t, null, n);
      }
      key(t, n, s) {
        return new _t(this, t, n, s);
      }
      callFn(t, n, s) {
        return new vt(this, t, null, n, s);
      }
      instantiate(t, n, s) {
        return new xt(this, t, n, s);
      }
      conditional(t, n = null, s) {
        return new Et(this, t, n, null, s);
      }
      equals(t, n) {
        return new w(u.Equals, this, t, null, n);
      }
      notEquals(t, n) {
        return new w(u.NotEquals, this, t, null, n);
      }
      identical(t, n) {
        return new w(u.Identical, this, t, null, n);
      }
      notIdentical(t, n) {
        return new w(u.NotIdentical, this, t, null, n);
      }
      minus(t, n) {
        return new w(u.Minus, this, t, null, n);
      }
      plus(t, n) {
        return new w(u.Plus, this, t, null, n);
      }
      divide(t, n) {
        return new w(u.Divide, this, t, null, n);
      }
      multiply(t, n) {
        return new w(u.Multiply, this, t, null, n);
      }
      modulo(t, n) {
        return new w(u.Modulo, this, t, null, n);
      }
      power(t, n) {
        return new w(u.Exponentiation, this, t, null, n);
      }
      and(t, n) {
        return new w(u.And, this, t, null, n);
      }
      bitwiseOr(t, n) {
        return new w(u.BitwiseOr, this, t, null, n);
      }
      bitwiseAnd(t, n) {
        return new w(u.BitwiseAnd, this, t, null, n);
      }
      or(t, n) {
        return new w(u.Or, this, t, null, n);
      }
      lower(t, n) {
        return new w(u.Lower, this, t, null, n);
      }
      lowerEquals(t, n) {
        return new w(u.LowerEquals, this, t, null, n);
      }
      bigger(t, n) {
        return new w(u.Bigger, this, t, null, n);
      }
      biggerEquals(t, n) {
        return new w(u.BiggerEquals, this, t, null, n);
      }
      isBlank(t) {
        return this.equals(TYPED_NULL_EXPR, t);
      }
      nullishCoalesce(t, n) {
        return new w(u.NullishCoalesce, this, t, null, n);
      }
      toStmt() {
        return new bt(this, null);
      }
    }, Je = class e extends _ {
      name;
      constructor(t, n, s) {
        super(n, s), this.name = t;
      }
      isEquivalent(t) {
        return t instanceof e && this.name === t.name;
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitReadVarExpr(this, n);
      }
      clone() {
        return new e(this.name, this.type, this.sourceSpan);
      }
      set(t) {
        return new w(u.Assign, this, t, null, this.sourceSpan);
      }
    }, gt = class e2 extends _ {
      expr;
      constructor(t, n, s) {
        super(n, s), this.expr = t;
      }
      visitExpression(t, n) {
        return t.visitTypeofExpr(this, n);
      }
      isEquivalent(t) {
        return t instanceof e2 && t.expr.isEquivalent(this.expr);
      }
      isConstant() {
        return this.expr.isConstant();
      }
      clone() {
        return new e2(this.expr.clone());
      }
    }, vt = class e3 extends _ {
      fn;
      args;
      pure;
      constructor(t, n, s, r, i = !1) {
        super(s, r), this.fn = t, this.args = n, this.pure = i;
      }
      get receiver() {
        return this.fn;
      }
      isEquivalent(t) {
        return t instanceof e3 && this.fn.isEquivalent(t.fn) && at(this.args, t.args) && this.pure === t.pure;
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitInvokeFunctionExpr(this, n);
      }
      clone() {
        return new e3(this.fn.clone(), this.args.map((t) => t.clone()), this.type, this.sourceSpan, this.pure);
      }
    }, xt = class e4 extends _ {
      classExpr;
      args;
      constructor(t, n, s, r) {
        super(s, r), this.classExpr = t, this.args = n;
      }
      isEquivalent(t) {
        return t instanceof e4 && this.classExpr.isEquivalent(t.classExpr) && at(this.args, t.args);
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitInstantiateExpr(this, n);
      }
      clone() {
        return new e4(this.classExpr.clone(), this.args.map((t) => t.clone()), this.type, this.sourceSpan);
      }
    }, wt = class e5 extends _ {
      body;
      flags;
      constructor(t, n, s) {
        super(null, s), this.body = t, this.flags = n;
      }
      isEquivalent(t) {
        return t instanceof e5 && this.body === t.body && this.flags === t.flags;
      }
      isConstant() {
        return !0;
      }
      visitExpression(t, n) {
        return t.visitRegularExpressionLiteral(this, n);
      }
      clone() {
        return new e5(this.body, this.flags, this.sourceSpan);
      }
    }, Ye = class e6 extends _ {
      value;
      constructor(t, n, s) {
        super(n, s), this.value = t;
      }
      isEquivalent(t) {
        return t instanceof e6 && this.value === t.value;
      }
      isConstant() {
        return !0;
      }
      visitExpression(t, n) {
        return t.visitLiteralExpr(this, n);
      }
      clone() {
        return new e6(this.value, this.type, this.sourceSpan);
      }
    }, St = class e7 extends _ {
      value;
      typeParams;
      constructor(t, n, s = null, r) {
        super(n, r), this.value = t, this.typeParams = s;
      }
      isEquivalent(t) {
        return t instanceof e7 && this.value.name === t.value.name && this.value.moduleName === t.value.moduleName;
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitExternalExpr(this, n);
      }
      clone() {
        return new e7(this.value, this.type, this.typeParams, this.sourceSpan);
      }
    }, Et = class e8 extends _ {
      condition;
      falseCase;
      trueCase;
      constructor(t, n, s = null, r, i) {
        super(r || n.type, i), this.condition = t, this.falseCase = s, this.trueCase = n;
      }
      isEquivalent(t) {
        return t instanceof e8 && this.condition.isEquivalent(t.condition) && this.trueCase.isEquivalent(t.trueCase) && qs(this.falseCase, t.falseCase);
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitConditionalExpr(this, n);
      }
      clone() {
        return new e8(this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type, this.sourceSpan);
      }
    }, w = class e9 extends _ {
      operator;
      rhs;
      lhs;
      constructor(t, n, s, r, i) {
        super(r || n.type, i), this.operator = t, this.rhs = s, this.lhs = n;
      }
      isEquivalent(t) {
        return t instanceof e9 && this.operator === t.operator && this.lhs.isEquivalent(t.lhs) && this.rhs.isEquivalent(t.rhs);
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitBinaryOperatorExpr(this, n);
      }
      clone() {
        return new e9(this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan);
      }
      isAssignment() {
        let t = this.operator;
        return t === u.Assign || t === u.AdditionAssignment || t === u.SubtractionAssignment || t === u.MultiplicationAssignment || t === u.DivisionAssignment || t === u.RemainderAssignment || t === u.ExponentiationAssignment || t === u.AndAssignment || t === u.OrAssignment || t === u.NullishCoalesceAssignment;
      }
    }, yt = class e10 extends _ {
      receiver;
      name;
      constructor(t, n, s, r) {
        super(s, r), this.receiver = t, this.name = n;
      }
      get index() {
        return this.name;
      }
      isEquivalent(t) {
        return t instanceof e10 && this.receiver.isEquivalent(t.receiver) && this.name === t.name;
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitReadPropExpr(this, n);
      }
      set(t) {
        return new w(u.Assign, this.receiver.prop(this.name), t, null, this.sourceSpan);
      }
      clone() {
        return new e10(this.receiver.clone(), this.name, this.type, this.sourceSpan);
      }
    }, _t = class e11 extends _ {
      receiver;
      index;
      constructor(t, n, s, r) {
        super(s, r), this.receiver = t, this.index = n;
      }
      isEquivalent(t) {
        return t instanceof e11 && this.receiver.isEquivalent(t.receiver) && this.index.isEquivalent(t.index);
      }
      isConstant() {
        return !1;
      }
      visitExpression(t, n) {
        return t.visitReadKeyExpr(this, n);
      }
      set(t) {
        return new w(u.Assign, this.receiver.key(this.index), t, null, this.sourceSpan);
      }
      clone() {
        return new e11(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);
      }
    }, Ct = class e12 extends _ {
      entries;
      constructor(t, n, s) {
        super(n, s), this.entries = t;
      }
      isConstant() {
        return this.entries.every((t) => t.isConstant());
      }
      isEquivalent(t) {
        return t instanceof e12 && at(this.entries, t.entries);
      }
      visitExpression(t, n) {
        return t.visitLiteralArrayExpr(this, n);
      }
      clone() {
        return new e12(this.entries.map((t) => t.clone()), this.type, this.sourceSpan);
      }
    }, kt = class e13 extends _ {
      entries;
      valueType = null;
      constructor(t, n, s) {
        super(n, s), this.entries = t, n && (this.valueType = n.valueType);
      }
      isEquivalent(t) {
        return t instanceof e13 && at(this.entries, t.entries);
      }
      isConstant() {
        return this.entries.every((t) => t.value.isConstant());
      }
      visitExpression(t, n) {
        return t.visitLiteralMapExpr(this, n);
      }
      clone() {
        let t = this.entries.map((n) => n.clone());
        return new e13(t, this.type, this.sourceSpan);
      }
    };
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.Final = 1] = "Final", e22[e22.Private = 2] = "Private", e22[e22.Exported = 4] = "Exported", e22[e22.Static = 8] = "Static";
    })(Qe || (Qe = {}));
    Tt = class {
      modifiers;
      sourceSpan;
      leadingComments;
      constructor(t = Qe.None, n = null, s) {
        this.modifiers = t, this.sourceSpan = n, this.leadingComments = s;
      }
      hasModifier(t) {
        return (this.modifiers & t) !== 0;
      }
      addLeadingComment(t) {
        this.leadingComments = this.leadingComments ?? [], this.leadingComments.push(t);
      }
    }, bt = class e14 extends Tt {
      expr;
      constructor(t, n, s) {
        super(Qe.None, n, s), this.expr = t;
      }
      isEquivalent(t) {
        return t instanceof e14 && this.expr.isEquivalent(t.expr);
      }
      visitStatement(t, n) {
        return t.visitExpressionStmt(this, n);
      }
    };
    ti = zs("<unknown>"), Cn = class e15 {
      static INSTANCE = new e15();
      keyOf(t) {
        if (t instanceof Ye && typeof t.value == "string") return `"${t.value}"`;
        if (t instanceof Ye) return String(t.value);
        if (t instanceof wt) return `/${t.body}/${t.flags ?? ""}`;
        if (t instanceof Ct) {
          let n = [];
          for (let s of t.entries) n.push(this.keyOf(s));
          return `[${n.join(",")}]`;
        } else if (t instanceof kt) {
          let n = [];
          for (let s of t.entries) {
            let r = s.key;
            s.quoted && (r = `"${r}"`), n.push(r + ":" + this.keyOf(s.value));
          }
          return `{${n.join(",")}}`;
        } else {
          if (t instanceof St) return `import("${t.value.moduleName}", ${t.value.name})`;
          if (t instanceof Je) return `read(${t.name})`;
          if (t instanceof gt) return `typeof(${this.keyOf(t.expr)})`;
          throw new Error(`${this.constructor.name} does not handle expressions of type ${t.constructor.name}`);
        }
      }
    }, a = "@angular/core", l = class {
      static NEW_METHOD = "factory";
      static TRANSFORM_METHOD = "transform";
      static PATCH_DEPS = "patchedDeps";
      static core = { name: null, moduleName: a };
      static namespaceHTML = { name: "\u0275\u0275namespaceHTML", moduleName: a };
      static namespaceMathML = { name: "\u0275\u0275namespaceMathML", moduleName: a };
      static namespaceSVG = { name: "\u0275\u0275namespaceSVG", moduleName: a };
      static element = { name: "\u0275\u0275element", moduleName: a };
      static elementStart = { name: "\u0275\u0275elementStart", moduleName: a };
      static elementEnd = { name: "\u0275\u0275elementEnd", moduleName: a };
      static domElement = { name: "\u0275\u0275domElement", moduleName: a };
      static domElementStart = { name: "\u0275\u0275domElementStart", moduleName: a };
      static domElementEnd = { name: "\u0275\u0275domElementEnd", moduleName: a };
      static domElementContainer = { name: "\u0275\u0275domElementContainer", moduleName: a };
      static domElementContainerStart = { name: "\u0275\u0275domElementContainerStart", moduleName: a };
      static domElementContainerEnd = { name: "\u0275\u0275domElementContainerEnd", moduleName: a };
      static domTemplate = { name: "\u0275\u0275domTemplate", moduleName: a };
      static domListener = { name: "\u0275\u0275domListener", moduleName: a };
      static advance = { name: "\u0275\u0275advance", moduleName: a };
      static syntheticHostProperty = { name: "\u0275\u0275syntheticHostProperty", moduleName: a };
      static syntheticHostListener = { name: "\u0275\u0275syntheticHostListener", moduleName: a };
      static attribute = { name: "\u0275\u0275attribute", moduleName: a };
      static classProp = { name: "\u0275\u0275classProp", moduleName: a };
      static elementContainerStart = { name: "\u0275\u0275elementContainerStart", moduleName: a };
      static elementContainerEnd = { name: "\u0275\u0275elementContainerEnd", moduleName: a };
      static elementContainer = { name: "\u0275\u0275elementContainer", moduleName: a };
      static styleMap = { name: "\u0275\u0275styleMap", moduleName: a };
      static classMap = { name: "\u0275\u0275classMap", moduleName: a };
      static styleProp = { name: "\u0275\u0275styleProp", moduleName: a };
      static interpolate = { name: "\u0275\u0275interpolate", moduleName: a };
      static interpolate1 = { name: "\u0275\u0275interpolate1", moduleName: a };
      static interpolate2 = { name: "\u0275\u0275interpolate2", moduleName: a };
      static interpolate3 = { name: "\u0275\u0275interpolate3", moduleName: a };
      static interpolate4 = { name: "\u0275\u0275interpolate4", moduleName: a };
      static interpolate5 = { name: "\u0275\u0275interpolate5", moduleName: a };
      static interpolate6 = { name: "\u0275\u0275interpolate6", moduleName: a };
      static interpolate7 = { name: "\u0275\u0275interpolate7", moduleName: a };
      static interpolate8 = { name: "\u0275\u0275interpolate8", moduleName: a };
      static interpolateV = { name: "\u0275\u0275interpolateV", moduleName: a };
      static nextContext = { name: "\u0275\u0275nextContext", moduleName: a };
      static resetView = { name: "\u0275\u0275resetView", moduleName: a };
      static templateCreate = { name: "\u0275\u0275template", moduleName: a };
      static defer = { name: "\u0275\u0275defer", moduleName: a };
      static deferWhen = { name: "\u0275\u0275deferWhen", moduleName: a };
      static deferOnIdle = { name: "\u0275\u0275deferOnIdle", moduleName: a };
      static deferOnImmediate = { name: "\u0275\u0275deferOnImmediate", moduleName: a };
      static deferOnTimer = { name: "\u0275\u0275deferOnTimer", moduleName: a };
      static deferOnHover = { name: "\u0275\u0275deferOnHover", moduleName: a };
      static deferOnInteraction = { name: "\u0275\u0275deferOnInteraction", moduleName: a };
      static deferOnViewport = { name: "\u0275\u0275deferOnViewport", moduleName: a };
      static deferPrefetchWhen = { name: "\u0275\u0275deferPrefetchWhen", moduleName: a };
      static deferPrefetchOnIdle = { name: "\u0275\u0275deferPrefetchOnIdle", moduleName: a };
      static deferPrefetchOnImmediate = { name: "\u0275\u0275deferPrefetchOnImmediate", moduleName: a };
      static deferPrefetchOnTimer = { name: "\u0275\u0275deferPrefetchOnTimer", moduleName: a };
      static deferPrefetchOnHover = { name: "\u0275\u0275deferPrefetchOnHover", moduleName: a };
      static deferPrefetchOnInteraction = { name: "\u0275\u0275deferPrefetchOnInteraction", moduleName: a };
      static deferPrefetchOnViewport = { name: "\u0275\u0275deferPrefetchOnViewport", moduleName: a };
      static deferHydrateWhen = { name: "\u0275\u0275deferHydrateWhen", moduleName: a };
      static deferHydrateNever = { name: "\u0275\u0275deferHydrateNever", moduleName: a };
      static deferHydrateOnIdle = { name: "\u0275\u0275deferHydrateOnIdle", moduleName: a };
      static deferHydrateOnImmediate = { name: "\u0275\u0275deferHydrateOnImmediate", moduleName: a };
      static deferHydrateOnTimer = { name: "\u0275\u0275deferHydrateOnTimer", moduleName: a };
      static deferHydrateOnHover = { name: "\u0275\u0275deferHydrateOnHover", moduleName: a };
      static deferHydrateOnInteraction = { name: "\u0275\u0275deferHydrateOnInteraction", moduleName: a };
      static deferHydrateOnViewport = { name: "\u0275\u0275deferHydrateOnViewport", moduleName: a };
      static deferEnableTimerScheduling = { name: "\u0275\u0275deferEnableTimerScheduling", moduleName: a };
      static conditionalCreate = { name: "\u0275\u0275conditionalCreate", moduleName: a };
      static conditionalBranchCreate = { name: "\u0275\u0275conditionalBranchCreate", moduleName: a };
      static conditional = { name: "\u0275\u0275conditional", moduleName: a };
      static repeater = { name: "\u0275\u0275repeater", moduleName: a };
      static repeaterCreate = { name: "\u0275\u0275repeaterCreate", moduleName: a };
      static repeaterTrackByIndex = { name: "\u0275\u0275repeaterTrackByIndex", moduleName: a };
      static repeaterTrackByIdentity = { name: "\u0275\u0275repeaterTrackByIdentity", moduleName: a };
      static componentInstance = { name: "\u0275\u0275componentInstance", moduleName: a };
      static text = { name: "\u0275\u0275text", moduleName: a };
      static enableBindings = { name: "\u0275\u0275enableBindings", moduleName: a };
      static disableBindings = { name: "\u0275\u0275disableBindings", moduleName: a };
      static getCurrentView = { name: "\u0275\u0275getCurrentView", moduleName: a };
      static textInterpolate = { name: "\u0275\u0275textInterpolate", moduleName: a };
      static textInterpolate1 = { name: "\u0275\u0275textInterpolate1", moduleName: a };
      static textInterpolate2 = { name: "\u0275\u0275textInterpolate2", moduleName: a };
      static textInterpolate3 = { name: "\u0275\u0275textInterpolate3", moduleName: a };
      static textInterpolate4 = { name: "\u0275\u0275textInterpolate4", moduleName: a };
      static textInterpolate5 = { name: "\u0275\u0275textInterpolate5", moduleName: a };
      static textInterpolate6 = { name: "\u0275\u0275textInterpolate6", moduleName: a };
      static textInterpolate7 = { name: "\u0275\u0275textInterpolate7", moduleName: a };
      static textInterpolate8 = { name: "\u0275\u0275textInterpolate8", moduleName: a };
      static textInterpolateV = { name: "\u0275\u0275textInterpolateV", moduleName: a };
      static restoreView = { name: "\u0275\u0275restoreView", moduleName: a };
      static pureFunction0 = { name: "\u0275\u0275pureFunction0", moduleName: a };
      static pureFunction1 = { name: "\u0275\u0275pureFunction1", moduleName: a };
      static pureFunction2 = { name: "\u0275\u0275pureFunction2", moduleName: a };
      static pureFunction3 = { name: "\u0275\u0275pureFunction3", moduleName: a };
      static pureFunction4 = { name: "\u0275\u0275pureFunction4", moduleName: a };
      static pureFunction5 = { name: "\u0275\u0275pureFunction5", moduleName: a };
      static pureFunction6 = { name: "\u0275\u0275pureFunction6", moduleName: a };
      static pureFunction7 = { name: "\u0275\u0275pureFunction7", moduleName: a };
      static pureFunction8 = { name: "\u0275\u0275pureFunction8", moduleName: a };
      static pureFunctionV = { name: "\u0275\u0275pureFunctionV", moduleName: a };
      static pipeBind1 = { name: "\u0275\u0275pipeBind1", moduleName: a };
      static pipeBind2 = { name: "\u0275\u0275pipeBind2", moduleName: a };
      static pipeBind3 = { name: "\u0275\u0275pipeBind3", moduleName: a };
      static pipeBind4 = { name: "\u0275\u0275pipeBind4", moduleName: a };
      static pipeBindV = { name: "\u0275\u0275pipeBindV", moduleName: a };
      static domProperty = { name: "\u0275\u0275domProperty", moduleName: a };
      static ariaProperty = { name: "\u0275\u0275ariaProperty", moduleName: a };
      static property = { name: "\u0275\u0275property", moduleName: a };
      static control = { name: "\u0275\u0275control", moduleName: a };
      static controlCreate = { name: "\u0275\u0275controlCreate", moduleName: a };
      static animationEnterListener = { name: "\u0275\u0275animateEnterListener", moduleName: a };
      static animationLeaveListener = { name: "\u0275\u0275animateLeaveListener", moduleName: a };
      static animationEnter = { name: "\u0275\u0275animateEnter", moduleName: a };
      static animationLeave = { name: "\u0275\u0275animateLeave", moduleName: a };
      static i18n = { name: "\u0275\u0275i18n", moduleName: a };
      static i18nAttributes = { name: "\u0275\u0275i18nAttributes", moduleName: a };
      static i18nExp = { name: "\u0275\u0275i18nExp", moduleName: a };
      static i18nStart = { name: "\u0275\u0275i18nStart", moduleName: a };
      static i18nEnd = { name: "\u0275\u0275i18nEnd", moduleName: a };
      static i18nApply = { name: "\u0275\u0275i18nApply", moduleName: a };
      static i18nPostprocess = { name: "\u0275\u0275i18nPostprocess", moduleName: a };
      static pipe = { name: "\u0275\u0275pipe", moduleName: a };
      static projection = { name: "\u0275\u0275projection", moduleName: a };
      static projectionDef = { name: "\u0275\u0275projectionDef", moduleName: a };
      static reference = { name: "\u0275\u0275reference", moduleName: a };
      static inject = { name: "\u0275\u0275inject", moduleName: a };
      static injectAttribute = { name: "\u0275\u0275injectAttribute", moduleName: a };
      static directiveInject = { name: "\u0275\u0275directiveInject", moduleName: a };
      static invalidFactory = { name: "\u0275\u0275invalidFactory", moduleName: a };
      static invalidFactoryDep = { name: "\u0275\u0275invalidFactoryDep", moduleName: a };
      static templateRefExtractor = { name: "\u0275\u0275templateRefExtractor", moduleName: a };
      static forwardRef = { name: "forwardRef", moduleName: a };
      static resolveForwardRef = { name: "resolveForwardRef", moduleName: a };
      static replaceMetadata = { name: "\u0275\u0275replaceMetadata", moduleName: a };
      static getReplaceMetadataURL = { name: "\u0275\u0275getReplaceMetadataURL", moduleName: a };
      static \u0275\u0275defineInjectable = { name: "\u0275\u0275defineInjectable", moduleName: a };
      static declareInjectable = { name: "\u0275\u0275ngDeclareInjectable", moduleName: a };
      static InjectableDeclaration = { name: "\u0275\u0275InjectableDeclaration", moduleName: a };
      static resolveWindow = { name: "\u0275\u0275resolveWindow", moduleName: a };
      static resolveDocument = { name: "\u0275\u0275resolveDocument", moduleName: a };
      static resolveBody = { name: "\u0275\u0275resolveBody", moduleName: a };
      static getComponentDepsFactory = { name: "\u0275\u0275getComponentDepsFactory", moduleName: a };
      static defineComponent = { name: "\u0275\u0275defineComponent", moduleName: a };
      static declareComponent = { name: "\u0275\u0275ngDeclareComponent", moduleName: a };
      static setComponentScope = { name: "\u0275\u0275setComponentScope", moduleName: a };
      static ChangeDetectionStrategy = { name: "ChangeDetectionStrategy", moduleName: a };
      static ViewEncapsulation = { name: "ViewEncapsulation", moduleName: a };
      static ComponentDeclaration = { name: "\u0275\u0275ComponentDeclaration", moduleName: a };
      static FactoryDeclaration = { name: "\u0275\u0275FactoryDeclaration", moduleName: a };
      static declareFactory = { name: "\u0275\u0275ngDeclareFactory", moduleName: a };
      static FactoryTarget = { name: "\u0275\u0275FactoryTarget", moduleName: a };
      static defineDirective = { name: "\u0275\u0275defineDirective", moduleName: a };
      static declareDirective = { name: "\u0275\u0275ngDeclareDirective", moduleName: a };
      static DirectiveDeclaration = { name: "\u0275\u0275DirectiveDeclaration", moduleName: a };
      static InjectorDef = { name: "\u0275\u0275InjectorDef", moduleName: a };
      static InjectorDeclaration = { name: "\u0275\u0275InjectorDeclaration", moduleName: a };
      static defineInjector = { name: "\u0275\u0275defineInjector", moduleName: a };
      static declareInjector = { name: "\u0275\u0275ngDeclareInjector", moduleName: a };
      static NgModuleDeclaration = { name: "\u0275\u0275NgModuleDeclaration", moduleName: a };
      static ModuleWithProviders = { name: "ModuleWithProviders", moduleName: a };
      static defineNgModule = { name: "\u0275\u0275defineNgModule", moduleName: a };
      static declareNgModule = { name: "\u0275\u0275ngDeclareNgModule", moduleName: a };
      static setNgModuleScope = { name: "\u0275\u0275setNgModuleScope", moduleName: a };
      static registerNgModuleType = { name: "\u0275\u0275registerNgModuleType", moduleName: a };
      static PipeDeclaration = { name: "\u0275\u0275PipeDeclaration", moduleName: a };
      static definePipe = { name: "\u0275\u0275definePipe", moduleName: a };
      static declarePipe = { name: "\u0275\u0275ngDeclarePipe", moduleName: a };
      static declareClassMetadata = { name: "\u0275\u0275ngDeclareClassMetadata", moduleName: a };
      static declareClassMetadataAsync = { name: "\u0275\u0275ngDeclareClassMetadataAsync", moduleName: a };
      static setClassMetadata = { name: "\u0275setClassMetadata", moduleName: a };
      static setClassMetadataAsync = { name: "\u0275setClassMetadataAsync", moduleName: a };
      static setClassDebugInfo = { name: "\u0275setClassDebugInfo", moduleName: a };
      static queryRefresh = { name: "\u0275\u0275queryRefresh", moduleName: a };
      static viewQuery = { name: "\u0275\u0275viewQuery", moduleName: a };
      static loadQuery = { name: "\u0275\u0275loadQuery", moduleName: a };
      static contentQuery = { name: "\u0275\u0275contentQuery", moduleName: a };
      static viewQuerySignal = { name: "\u0275\u0275viewQuerySignal", moduleName: a };
      static contentQuerySignal = { name: "\u0275\u0275contentQuerySignal", moduleName: a };
      static queryAdvance = { name: "\u0275\u0275queryAdvance", moduleName: a };
      static twoWayProperty = { name: "\u0275\u0275twoWayProperty", moduleName: a };
      static twoWayBindingSet = { name: "\u0275\u0275twoWayBindingSet", moduleName: a };
      static twoWayListener = { name: "\u0275\u0275twoWayListener", moduleName: a };
      static declareLet = { name: "\u0275\u0275declareLet", moduleName: a };
      static storeLet = { name: "\u0275\u0275storeLet", moduleName: a };
      static readContextLet = { name: "\u0275\u0275readContextLet", moduleName: a };
      static attachSourceLocations = { name: "\u0275\u0275attachSourceLocations", moduleName: a };
      static NgOnChangesFeature = { name: "\u0275\u0275NgOnChangesFeature", moduleName: a };
      static InheritDefinitionFeature = { name: "\u0275\u0275InheritDefinitionFeature", moduleName: a };
      static ProvidersFeature = { name: "\u0275\u0275ProvidersFeature", moduleName: a };
      static HostDirectivesFeature = { name: "\u0275\u0275HostDirectivesFeature", moduleName: a };
      static ExternalStylesFeature = { name: "\u0275\u0275ExternalStylesFeature", moduleName: a };
      static listener = { name: "\u0275\u0275listener", moduleName: a };
      static getInheritedFactory = { name: "\u0275\u0275getInheritedFactory", moduleName: a };
      static sanitizeHtml = { name: "\u0275\u0275sanitizeHtml", moduleName: a };
      static sanitizeStyle = { name: "\u0275\u0275sanitizeStyle", moduleName: a };
      static validateAttribute = { name: "\u0275\u0275validateAttribute", moduleName: a };
      static sanitizeResourceUrl = { name: "\u0275\u0275sanitizeResourceUrl", moduleName: a };
      static sanitizeScript = { name: "\u0275\u0275sanitizeScript", moduleName: a };
      static sanitizeUrl = { name: "\u0275\u0275sanitizeUrl", moduleName: a };
      static sanitizeUrlOrResourceUrl = { name: "\u0275\u0275sanitizeUrlOrResourceUrl", moduleName: a };
      static trustConstantHtml = { name: "\u0275\u0275trustConstantHtml", moduleName: a };
      static trustConstantResourceUrl = { name: "\u0275\u0275trustConstantResourceUrl", moduleName: a };
      static inputDecorator = { name: "Input", moduleName: a };
      static outputDecorator = { name: "Output", moduleName: a };
      static viewChildDecorator = { name: "ViewChild", moduleName: a };
      static viewChildrenDecorator = { name: "ViewChildren", moduleName: a };
      static contentChildDecorator = { name: "ContentChild", moduleName: a };
      static contentChildrenDecorator = { name: "ContentChildren", moduleName: a };
      static InputSignalBrandWriteType = { name: "\u0275INPUT_SIGNAL_BRAND_WRITE_TYPE", moduleName: a };
      static UnwrapDirectiveSignalInputs = { name: "\u0275UnwrapDirectiveSignalInputs", moduleName: a };
      static unwrapWritableSignal = { name: "\u0275unwrapWritableSignal", moduleName: a };
      static assertType = { name: "\u0275assertType", moduleName: a };
    }, At = class {
      full;
      major;
      minor;
      patch;
      constructor(t) {
        this.full = t;
        let n = t.split(".");
        this.major = n[0], this.minor = n[1], this.patch = n.slice(2).join(".");
      }
    }, ni = /* @__PURE__ */ new Map([[u.And, "&&"], [u.Bigger, ">"], [u.BiggerEquals, ">="], [u.BitwiseOr, "|"], [u.BitwiseAnd, "&"], [u.Divide, "/"], [u.Assign, "="], [u.Equals, "=="], [u.Identical, "==="], [u.Lower, "<"], [u.LowerEquals, "<="], [u.Minus, "-"], [u.Modulo, "%"], [u.Exponentiation, "**"], [u.Multiply, "*"], [u.NotEquals, "!="], [u.NotIdentical, "!=="], [u.NullishCoalesce, "??"], [u.Or, "||"], [u.Plus, "+"], [u.In, "in"], [u.AdditionAssignment, "+="], [u.SubtractionAssignment, "-="], [u.MultiplicationAssignment, "*="], [u.DivisionAssignment, "/="], [u.RemainderAssignment, "%="], [u.ExponentiationAssignment, "**="], [u.AndAssignment, "&&="], [u.OrAssignment, "||="], [u.NullishCoalesceAssignment, "??="]]);
    (function(e22) {
      e22[e22.Class = 0] = "Class", e22[e22.Function = 1] = "Function";
    })(kn || (kn = {}));
    Y = class {
      start;
      end;
      constructor(t, n) {
        this.start = t, this.end = n;
      }
      toAbsolute(t) {
        return new B(t + this.start, t + this.end);
      }
    }, v = class {
      span;
      sourceSpan;
      constructor(t, n) {
        this.span = t, this.sourceSpan = n;
      }
      toString() {
        return "AST";
      }
    }, Pe = class extends v {
      nameSpan;
      constructor(t, n, s) {
        super(t, n), this.nameSpan = s;
      }
    }, A = class extends v {
      visit(t, n = null) {
      }
    }, Q = class extends v {
      visit(t, n = null) {
        return t.visitImplicitReceiver(this, n);
      }
    }, It = class extends Q {
      visit(t, n = null) {
        return t.visitThisReceiver?.(this, n);
      }
    }, Le = class extends v {
      expressions;
      constructor(t, n, s) {
        super(t, n), this.expressions = s;
      }
      visit(t, n = null) {
        return t.visitChain(this, n);
      }
    }, Me = class extends v {
      condition;
      trueExp;
      falseExp;
      constructor(t, n, s, r, i) {
        super(t, n), this.condition = s, this.trueExp = r, this.falseExp = i;
      }
      visit(t, n = null) {
        return t.visitConditional(this, n);
      }
    }, X = class extends Pe {
      receiver;
      name;
      constructor(t, n, s, r, i) {
        super(t, n, s), this.receiver = r, this.name = i;
      }
      visit(t, n = null) {
        return t.visitPropertyRead(this, n);
      }
    }, ce = class extends Pe {
      receiver;
      name;
      constructor(t, n, s, r, i) {
        super(t, n, s), this.receiver = r, this.name = i;
      }
      visit(t, n = null) {
        return t.visitSafePropertyRead(this, n);
      }
    }, ue = class extends v {
      receiver;
      key;
      constructor(t, n, s, r) {
        super(t, n), this.receiver = s, this.key = r;
      }
      visit(t, n = null) {
        return t.visitKeyedRead(this, n);
      }
    }, he = class extends v {
      receiver;
      key;
      constructor(t, n, s, r) {
        super(t, n), this.receiver = s, this.key = r;
      }
      visit(t, n = null) {
        return t.visitSafeKeyedRead(this, n);
      }
    };
    (function(e22) {
      e22[e22.ReferencedByName = 0] = "ReferencedByName", e22[e22.ReferencedDirectly = 1] = "ReferencedDirectly";
    })(be || (be = {}));
    Re = class extends Pe {
      exp;
      name;
      args;
      type;
      constructor(t, n, s, r, i, o, c) {
        super(t, n, c), this.exp = s, this.name = r, this.args = i, this.type = o;
      }
      visit(t, n = null) {
        return t.visitPipe(this, n);
      }
    }, k = class extends v {
      value;
      constructor(t, n, s) {
        super(t, n), this.value = s;
      }
      visit(t, n = null) {
        return t.visitLiteralPrimitive(this, n);
      }
    }, $e = class extends v {
      expressions;
      constructor(t, n, s) {
        super(t, n), this.expressions = s;
      }
      visit(t, n = null) {
        return t.visitLiteralArray(this, n);
      }
    }, De = class extends v {
      keys;
      values;
      constructor(t, n, s, r) {
        super(t, n), this.keys = s, this.values = r;
      }
      visit(t, n = null) {
        return t.visitLiteralMap(this, n);
      }
    }, Vt = class extends v {
      strings;
      expressions;
      constructor(t, n, s, r) {
        super(t, n), this.strings = s, this.expressions = r;
      }
      visit(t, n = null) {
        return t.visitInterpolation(this, n);
      }
    }, y = class extends v {
      operation;
      left;
      right;
      constructor(t, n, s, r, i) {
        super(t, n), this.operation = s, this.left = r, this.right = i;
      }
      visit(t, n = null) {
        return t.visitBinary(this, n);
      }
      static isAssignmentOperation(t) {
        return t === "=" || t === "+=" || t === "-=" || t === "*=" || t === "/=" || t === "%=" || t === "**=" || t === "&&=" || t === "||=" || t === "??=";
      }
    }, J = class e16 extends y {
      operator;
      expr;
      left = null;
      right = null;
      operation = null;
      static createMinus(t, n, s) {
        return new e16(t, n, "-", s, "-", new k(t, n, 0), s);
      }
      static createPlus(t, n, s) {
        return new e16(t, n, "+", s, "-", s, new k(t, n, 0));
      }
      constructor(t, n, s, r, i, o, c) {
        super(t, n, i, o, c), this.operator = s, this.expr = r;
      }
      visit(t, n = null) {
        return t.visitUnary !== void 0 ? t.visitUnary(this, n) : t.visitBinary(this, n);
      }
    }, K = class extends v {
      expression;
      constructor(t, n, s) {
        super(t, n), this.expression = s;
      }
      visit(t, n = null) {
        return t.visitPrefixNot(this, n);
      }
    }, Z = class extends v {
      expression;
      constructor(t, n, s) {
        super(t, n), this.expression = s;
      }
      visit(t, n = null) {
        return t.visitTypeofExpression(this, n);
      }
    }, ee = class extends v {
      expression;
      constructor(t, n, s) {
        super(t, n), this.expression = s;
      }
      visit(t, n = null) {
        return t.visitVoidExpression(this, n);
      }
    }, Be = class extends v {
      expression;
      constructor(t, n, s) {
        super(t, n), this.expression = s;
      }
      visit(t, n = null) {
        return t.visitNonNullAssert(this, n);
      }
    }, Oe = class extends v {
      receiver;
      args;
      argumentSpan;
      constructor(t, n, s, r, i) {
        super(t, n), this.receiver = s, this.args = r, this.argumentSpan = i;
      }
      visit(t, n = null) {
        return t.visitCall(this, n);
      }
    }, pe = class extends v {
      receiver;
      args;
      argumentSpan;
      constructor(t, n, s, r, i) {
        super(t, n), this.receiver = s, this.args = r, this.argumentSpan = i;
      }
      visit(t, n = null) {
        return t.visitSafeCall(this, n);
      }
    }, fe = class extends v {
      tag;
      template;
      constructor(t, n, s, r) {
        super(t, n), this.tag = s, this.template = r;
      }
      visit(t, n) {
        return t.visitTaggedTemplateLiteral(this, n);
      }
    }, de = class extends v {
      elements;
      expressions;
      constructor(t, n, s, r) {
        super(t, n), this.elements = s, this.expressions = r;
      }
      visit(t, n) {
        return t.visitTemplateLiteral(this, n);
      }
    }, me = class extends v {
      text;
      constructor(t, n, s) {
        super(t, n), this.text = s;
      }
      visit(t, n) {
        return t.visitTemplateLiteralElement(this, n);
      }
    }, Fe = class extends v {
      expression;
      constructor(t, n, s) {
        super(t, n), this.expression = s;
      }
      visit(t, n) {
        return t.visitParenthesizedExpression(this, n);
      }
    }, Ve = class extends v {
      body;
      flags;
      constructor(t, n, s, r) {
        super(t, n), this.body = s, this.flags = r;
      }
      visit(t, n) {
        return t.visitRegularExpressionLiteral(this, n);
      }
    }, B = class {
      start;
      end;
      constructor(t, n) {
        this.start = t, this.end = n;
      }
    }, F = class extends v {
      ast;
      source;
      location;
      errors;
      constructor(t, n, s, r, i) {
        super(new Y(0, n === null ? 0 : n.length), new B(r, n === null ? r : r + n.length)), this.ast = t, this.source = n, this.location = s, this.errors = i;
      }
      visit(t, n = null) {
        return t.visitASTWithSource ? t.visitASTWithSource(this, n) : this.ast.visit(t, n);
      }
      toString() {
        return `${this.source} in ${this.location}`;
      }
    }, ge = class {
      sourceSpan;
      key;
      value;
      constructor(t, n, s) {
        this.sourceSpan = t, this.key = n, this.value = s;
      }
    }, He = class {
      sourceSpan;
      key;
      value;
      constructor(t, n, s) {
        this.sourceSpan = t, this.key = n, this.value = s;
      }
    }, Nt = class {
      visit(t, n) {
        t.visit(this, n);
      }
      visitUnary(t, n) {
        this.visit(t.expr, n);
      }
      visitBinary(t, n) {
        this.visit(t.left, n), this.visit(t.right, n);
      }
      visitChain(t, n) {
        this.visitAll(t.expressions, n);
      }
      visitConditional(t, n) {
        this.visit(t.condition, n), this.visit(t.trueExp, n), this.visit(t.falseExp, n);
      }
      visitPipe(t, n) {
        this.visit(t.exp, n), this.visitAll(t.args, n);
      }
      visitImplicitReceiver(t, n) {
      }
      visitThisReceiver(t, n) {
      }
      visitInterpolation(t, n) {
        this.visitAll(t.expressions, n);
      }
      visitKeyedRead(t, n) {
        this.visit(t.receiver, n), this.visit(t.key, n);
      }
      visitLiteralArray(t, n) {
        this.visitAll(t.expressions, n);
      }
      visitLiteralMap(t, n) {
        this.visitAll(t.values, n);
      }
      visitLiteralPrimitive(t, n) {
      }
      visitPrefixNot(t, n) {
        this.visit(t.expression, n);
      }
      visitTypeofExpression(t, n) {
        this.visit(t.expression, n);
      }
      visitVoidExpression(t, n) {
        this.visit(t.expression, n);
      }
      visitNonNullAssert(t, n) {
        this.visit(t.expression, n);
      }
      visitPropertyRead(t, n) {
        this.visit(t.receiver, n);
      }
      visitSafePropertyRead(t, n) {
        this.visit(t.receiver, n);
      }
      visitSafeKeyedRead(t, n) {
        this.visit(t.receiver, n), this.visit(t.key, n);
      }
      visitCall(t, n) {
        this.visit(t.receiver, n), this.visitAll(t.args, n);
      }
      visitSafeCall(t, n) {
        this.visit(t.receiver, n), this.visitAll(t.args, n);
      }
      visitTemplateLiteral(t, n) {
        for (let s = 0; s < t.elements.length; s++) {
          this.visit(t.elements[s], n);
          let r = s < t.expressions.length ? t.expressions[s] : null;
          r !== null && this.visit(r, n);
        }
      }
      visitTemplateLiteralElement(t, n) {
      }
      visitTaggedTemplateLiteral(t, n) {
        this.visit(t.tag, n), this.visit(t.template, n);
      }
      visitParenthesizedExpression(t, n) {
        this.visit(t.expression, n);
      }
      visitRegularExpressionLiteral(t, n) {
      }
      visitAll(t, n) {
        for (let s of t) this.visit(s, n);
      }
    };
    (function(e22) {
      e22[e22.DEFAULT = 0] = "DEFAULT", e22[e22.LITERAL_ATTR = 1] = "LITERAL_ATTR", e22[e22.LEGACY_ANIMATION = 2] = "LEGACY_ANIMATION", e22[e22.TWO_WAY = 3] = "TWO_WAY", e22[e22.ANIMATION = 4] = "ANIMATION";
    })(Tn || (Tn = {}));
    (function(e22) {
      e22[e22.Regular = 0] = "Regular", e22[e22.LegacyAnimation = 1] = "LegacyAnimation", e22[e22.TwoWay = 2] = "TwoWay", e22[e22.Animation = 3] = "Animation";
    })(bn || (bn = {}));
    (function(e22) {
      e22[e22.Property = 0] = "Property", e22[e22.Attribute = 1] = "Attribute", e22[e22.Class = 2] = "Class", e22[e22.Style = 3] = "Style", e22[e22.LegacyAnimation = 4] = "LegacyAnimation", e22[e22.TwoWay = 5] = "TwoWay", e22[e22.Animation = 6] = "Animation";
    })(M || (M = {}));
    (function(e22) {
      e22[e22.RAW_TEXT = 0] = "RAW_TEXT", e22[e22.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e22[e22.PARSABLE_DATA = 2] = "PARSABLE_DATA";
    })(An || (An = {}));
    ye = 0, as = 9, Xe = 10, Gs = 11, Xs = 12, Js = 13, os = 32, Ys = 33, ls = 34, Qs = 35, Ht = 36, Ks = 37, In = 38, cs = 39, Ae = 40, q = 41, Nn = 42, us = 43, re = 44, hs = 45, ke = 46, Ke = 47, j = 58, Te = 59, Zs = 60, b = 61, er = 62, Pn = 63, tr = 48, nr = 57, Ut = 65, sr = 69, Wt = 90, le = 91, mt = 92, G = 93, rr = 94, ot = 95, ps = 97, ir = 101, ar = 102, or = 110, lr = 114, cr = 116, ur = 117, hr = 118, fs = 122, Ze = 123, Ln = 124, ie = 125, ds = 160, Pt = 96;
    et = class e17 {
      file;
      offset;
      line;
      col;
      constructor(t, n, s, r) {
        this.file = t, this.offset = n, this.line = s, this.col = r;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(t) {
        let n = this.file.content, s = n.length, r = this.offset, i = this.line, o = this.col;
        for (; r > 0 && t < 0; ) if (r--, t++, n.charCodeAt(r) == Xe) {
          i--;
          let h = n.substring(0, r - 1).lastIndexOf(String.fromCharCode(Xe));
          o = h > 0 ? r - h : r;
        } else o--;
        for (; r < s && t > 0; ) {
          let c = n.charCodeAt(r);
          r++, t--, c == Xe ? (i++, o = 0) : o++;
        }
        return new e17(this.file, r, i, o);
      }
      getContext(t, n) {
        let s = this.file.content, r = this.offset;
        if (r != null) {
          r > s.length - 1 && (r = s.length - 1);
          let i = r, o = 0, c = 0;
          for (; o < t && r > 0 && (r--, o++, !(s[r] == `
` && ++c == n)); ) ;
          for (o = 0, c = 0; o < t && i < s.length - 1 && (i++, o++, !(s[i] == `
` && ++c == n)); ) ;
          return { before: s.substring(r, this.offset), after: s.substring(this.offset, i + 1) };
        }
        return null;
      }
    }, tt = class {
      content;
      url;
      constructor(t, n) {
        this.content = t, this.url = n;
      }
    }, nt = class {
      start;
      end;
      fullStart;
      details;
      constructor(t, n, s = t, r = null) {
        this.start = t, this.end = n, this.fullStart = s, this.details = r;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    };
    (function(e22) {
      e22[e22.WARNING = 0] = "WARNING", e22[e22.ERROR = 1] = "ERROR";
    })(st || (st = {}));
    Mt = class extends Error {
      span;
      msg;
      level;
      relatedError;
      constructor(t, n, s = st.ERROR, r) {
        super(n), this.span = t, this.msg = n, this.level = s, this.relatedError = r, Object.setPrototypeOf(this, new.target.prototype);
      }
      contextualMessage() {
        let t = this.span.start.getContext(100, 3);
        return t ? `${this.msg} ("${t.before}[${st[this.level]} ->]${t.after}")` : this.msg;
      }
      toString() {
        let t = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${t}`;
      }
    };
    (function(e22) {
      e22[e22.Inline = 0] = "Inline", e22[e22.SideEffect = 1] = "SideEffect", e22[e22.Omit = 2] = "Omit";
    })(Rn || (Rn = {}));
    (function(e22) {
      e22[e22.Global = 0] = "Global", e22[e22.Local = 1] = "Local";
    })($n || ($n = {}));
    (function(e22) {
      e22[e22.Directive = 0] = "Directive", e22[e22.Pipe = 1] = "Pipe", e22[e22.NgModule = 2] = "NgModule";
    })(Dn || (Dn = {}));
    fr = "(:(where|is)\\()?", ms = "-shadowcsshost", dr = "-shadowcsscontext", Rt = "[^)(]*", mr = `(?:\\(${Rt}\\)|${Rt})+?`, gr = `(?:\\(${mr}\\)|${Rt})+?`, qt = `(?:\\((${gr})\\))`, ii = new RegExp("(:nth-[-\\w]+)" + qt, "g"), ai = new RegExp(ms + qt + "?([^,{]*)", "gim"), vr = dr + qt + "?([^{]*)", oi = new RegExp(`${fr}(${vr})`, "gim"), xr = ms + "-no-combinator", li = new RegExp(`${xr}(?![^(]*\\))`, "g"), gs = "%COMMENT%", ci = new RegExp(gs, "g"), ui = new RegExp(`(\\s*(?:${gs}\\s*)*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))`, "g"), wr = "%COMMA_IN_PLACEHOLDER%", Sr = "%SEMI_IN_PLACEHOLDER%", Er = "%COLON_IN_PLACEHOLDER%", hi = new RegExp(wr, "g"), pi = new RegExp(Sr, "g"), fi = new RegExp(Er, "g");
    (function(e22) {
      e22[e22.ListEnd = 0] = "ListEnd", e22[e22.Statement = 1] = "Statement", e22[e22.Variable = 2] = "Variable", e22[e22.ElementStart = 3] = "ElementStart", e22[e22.Element = 4] = "Element", e22[e22.Template = 5] = "Template", e22[e22.ElementEnd = 6] = "ElementEnd", e22[e22.ContainerStart = 7] = "ContainerStart", e22[e22.Container = 8] = "Container", e22[e22.ContainerEnd = 9] = "ContainerEnd", e22[e22.DisableBindings = 10] = "DisableBindings", e22[e22.ConditionalCreate = 11] = "ConditionalCreate", e22[e22.ConditionalBranchCreate = 12] = "ConditionalBranchCreate", e22[e22.Conditional = 13] = "Conditional", e22[e22.EnableBindings = 14] = "EnableBindings", e22[e22.Text = 15] = "Text", e22[e22.Listener = 16] = "Listener", e22[e22.InterpolateText = 17] = "InterpolateText", e22[e22.Binding = 18] = "Binding", e22[e22.Property = 19] = "Property", e22[e22.StyleProp = 20] = "StyleProp", e22[e22.ClassProp = 21] = "ClassProp", e22[e22.StyleMap = 22] = "StyleMap", e22[e22.ClassMap = 23] = "ClassMap", e22[e22.Advance = 24] = "Advance", e22[e22.Pipe = 25] = "Pipe", e22[e22.Attribute = 26] = "Attribute", e22[e22.ExtractedAttribute = 27] = "ExtractedAttribute", e22[e22.Defer = 28] = "Defer", e22[e22.DeferOn = 29] = "DeferOn", e22[e22.DeferWhen = 30] = "DeferWhen", e22[e22.I18nMessage = 31] = "I18nMessage", e22[e22.DomProperty = 32] = "DomProperty", e22[e22.Namespace = 33] = "Namespace", e22[e22.ProjectionDef = 34] = "ProjectionDef", e22[e22.Projection = 35] = "Projection", e22[e22.RepeaterCreate = 36] = "RepeaterCreate", e22[e22.Repeater = 37] = "Repeater", e22[e22.TwoWayProperty = 38] = "TwoWayProperty", e22[e22.TwoWayListener = 39] = "TwoWayListener", e22[e22.DeclareLet = 40] = "DeclareLet", e22[e22.StoreLet = 41] = "StoreLet", e22[e22.I18nStart = 42] = "I18nStart", e22[e22.I18n = 43] = "I18n", e22[e22.I18nEnd = 44] = "I18nEnd", e22[e22.I18nExpression = 45] = "I18nExpression", e22[e22.I18nApply = 46] = "I18nApply", e22[e22.IcuStart = 47] = "IcuStart", e22[e22.IcuEnd = 48] = "IcuEnd", e22[e22.IcuPlaceholder = 49] = "IcuPlaceholder", e22[e22.I18nContext = 50] = "I18nContext", e22[e22.I18nAttributes = 51] = "I18nAttributes", e22[e22.SourceLocation = 52] = "SourceLocation", e22[e22.Animation = 53] = "Animation", e22[e22.AnimationString = 54] = "AnimationString", e22[e22.AnimationBinding = 55] = "AnimationBinding", e22[e22.AnimationListener = 56] = "AnimationListener", e22[e22.Control = 57] = "Control", e22[e22.ControlCreate = 58] = "ControlCreate";
    })(f || (f = {}));
    (function(e22) {
      e22[e22.LexicalRead = 0] = "LexicalRead", e22[e22.Context = 1] = "Context", e22[e22.TrackContext = 2] = "TrackContext", e22[e22.ReadVariable = 3] = "ReadVariable", e22[e22.NextContext = 4] = "NextContext", e22[e22.Reference = 5] = "Reference", e22[e22.StoreLet = 6] = "StoreLet", e22[e22.ContextLetReference = 7] = "ContextLetReference", e22[e22.GetCurrentView = 8] = "GetCurrentView", e22[e22.RestoreView = 9] = "RestoreView", e22[e22.ResetView = 10] = "ResetView", e22[e22.PureFunctionExpr = 11] = "PureFunctionExpr", e22[e22.PureFunctionParameterExpr = 12] = "PureFunctionParameterExpr", e22[e22.PipeBinding = 13] = "PipeBinding", e22[e22.PipeBindingVariadic = 14] = "PipeBindingVariadic", e22[e22.SafePropertyRead = 15] = "SafePropertyRead", e22[e22.SafeKeyedRead = 16] = "SafeKeyedRead", e22[e22.SafeInvokeFunction = 17] = "SafeInvokeFunction", e22[e22.SafeTernaryExpr = 18] = "SafeTernaryExpr", e22[e22.EmptyExpr = 19] = "EmptyExpr", e22[e22.AssignTemporaryExpr = 20] = "AssignTemporaryExpr", e22[e22.ReadTemporaryExpr = 21] = "ReadTemporaryExpr", e22[e22.SlotLiteralExpr = 22] = "SlotLiteralExpr", e22[e22.ConditionalCase = 23] = "ConditionalCase", e22[e22.ConstCollected = 24] = "ConstCollected", e22[e22.TwoWayBindingSet = 25] = "TwoWayBindingSet";
    })(ve || (ve = {}));
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.AlwaysInline = 1] = "AlwaysInline";
    })(Bn || (Bn = {}));
    (function(e22) {
      e22[e22.Context = 0] = "Context", e22[e22.Identifier = 1] = "Identifier", e22[e22.SavedView = 2] = "SavedView", e22[e22.Alias = 3] = "Alias";
    })(On || (On = {}));
    (function(e22) {
      e22[e22.Normal = 0] = "Normal", e22[e22.TemplateDefinitionBuilder = 1] = "TemplateDefinitionBuilder";
    })(Fn || (Fn = {}));
    (function(e22) {
      e22[e22.Attribute = 0] = "Attribute", e22[e22.ClassName = 1] = "ClassName", e22[e22.StyleProperty = 2] = "StyleProperty", e22[e22.Property = 3] = "Property", e22[e22.Template = 4] = "Template", e22[e22.I18n = 5] = "I18n", e22[e22.LegacyAnimation = 6] = "LegacyAnimation", e22[e22.TwoWayProperty = 7] = "TwoWayProperty", e22[e22.Animation = 8] = "Animation";
    })(R || (R = {}));
    (function(e22) {
      e22[e22.Creation = 0] = "Creation", e22[e22.Postproccessing = 1] = "Postproccessing";
    })(Vn || (Vn = {}));
    (function(e22) {
      e22[e22.I18nText = 0] = "I18nText", e22[e22.I18nAttribute = 1] = "I18nAttribute";
    })(Hn || (Hn = {}));
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.ElementTag = 1] = "ElementTag", e22[e22.TemplateTag = 2] = "TemplateTag", e22[e22.OpenTag = 4] = "OpenTag", e22[e22.CloseTag = 8] = "CloseTag", e22[e22.ExpressionIndex = 16] = "ExpressionIndex";
    })(Un || (Un = {}));
    (function(e22) {
      e22[e22.HTML = 0] = "HTML", e22[e22.SVG = 1] = "SVG", e22[e22.Math = 2] = "Math";
    })(Wn || (Wn = {}));
    (function(e22) {
      e22[e22.Idle = 0] = "Idle", e22[e22.Immediate = 1] = "Immediate", e22[e22.Timer = 2] = "Timer", e22[e22.Hover = 3] = "Hover", e22[e22.Interaction = 4] = "Interaction", e22[e22.Viewport = 5] = "Viewport", e22[e22.Never = 6] = "Never";
    })($ || ($ = {}));
    (function(e22) {
      e22[e22.RootI18n = 0] = "RootI18n", e22[e22.Icu = 1] = "Icu", e22[e22.Attr = 2] = "Attr";
    })(qn || (qn = {}));
    (function(e22) {
      e22[e22.NgTemplate = 0] = "NgTemplate", e22[e22.Structural = 1] = "Structural", e22[e22.Block = 2] = "Block";
    })(jn || (jn = {}));
    yr = Symbol("ConsumesSlot"), vs = Symbol("DependsOnSlotContext"), We = Symbol("ConsumesVars"), jt = Symbol("UsesVarOffset"), di = { [yr]: !0, numSlotsUsed: 1 }, mi = { [vs]: !0 }, gi = { [We]: !0 }, rt = class {
      strings;
      expressions;
      i18nPlaceholders;
      constructor(t, n, s) {
        if (this.strings = t, this.expressions = n, this.i18nPlaceholders = s, s.length !== 0 && s.length !== n.length) throw new Error(`Expected ${n.length} placeholders to match interpolation expression count, but got ${s.length}`);
      }
    }, xe = class extends _ {
      constructor(t = null) {
        super(null, t);
      }
    }, zn = class e18 extends xe {
      target;
      value;
      sourceSpan;
      kind = ve.StoreLet;
      [We] = !0;
      [vs] = !0;
      constructor(t, n, s) {
        super(), this.target = t, this.value = n, this.sourceSpan = s;
      }
      visitExpression() {
      }
      isEquivalent(t) {
        return t instanceof e18 && t.target === this.target && t.value.isEquivalent(this.value);
      }
      isConstant() {
        return !1;
      }
      transformInternalExpressions(t, n) {
        this.value = (this.value, void 0);
      }
      clone() {
        return new e18(this.target, this.value, this.sourceSpan);
      }
    }, Gn = class e19 extends xe {
      kind = ve.PureFunctionExpr;
      [We] = !0;
      [jt] = !0;
      varOffset = null;
      body;
      args;
      fn = null;
      constructor(t, n) {
        super(), this.body = t, this.args = n;
      }
      visitExpression(t, n) {
        this.body?.visitExpression(t, n);
        for (let s of this.args) s.visitExpression(t, n);
      }
      isEquivalent(t) {
        return !(t instanceof e19) || t.args.length !== this.args.length ? !1 : t.body !== null && this.body !== null && t.body.isEquivalent(this.body) && t.args.every((n, s) => n.isEquivalent(this.args[s]));
      }
      isConstant() {
        return !1;
      }
      transformInternalExpressions(t, n) {
        this.body !== null ? this.body = (this.body, n | $t.InChildOperation, void 0) : this.fn !== null && (this.fn = (this.fn, void 0));
        for (let s = 0; s < this.args.length; s++) this.args[s] = (this.args[s], void 0);
      }
      clone() {
        let t = new e19(this.body?.clone() ?? null, this.args.map((n) => n.clone()));
        return t.fn = this.fn?.clone() ?? null, t.varOffset = this.varOffset, t;
      }
    }, Xn = class e20 extends xe {
      target;
      targetSlot;
      name;
      args;
      kind = ve.PipeBinding;
      [We] = !0;
      [jt] = !0;
      varOffset = null;
      constructor(t, n, s, r) {
        super(), this.target = t, this.targetSlot = n, this.name = s, this.args = r;
      }
      visitExpression(t, n) {
        for (let s of this.args) s.visitExpression(t, n);
      }
      isEquivalent() {
        return !1;
      }
      isConstant() {
        return !1;
      }
      transformInternalExpressions(t, n) {
        for (let s = 0; s < this.args.length; s++) this.args[s] = (this.args[s], void 0);
      }
      clone() {
        let t = new e20(this.target, this.targetSlot, this.name, this.args.map((n) => n.clone()));
        return t.varOffset = this.varOffset, t;
      }
    }, Jn = class e21 extends xe {
      target;
      targetSlot;
      name;
      args;
      numArgs;
      kind = ve.PipeBindingVariadic;
      [We] = !0;
      [jt] = !0;
      varOffset = null;
      constructor(t, n, s, r, i) {
        super(), this.target = t, this.targetSlot = n, this.name = s, this.args = r, this.numArgs = i;
      }
      visitExpression(t, n) {
        this.args.visitExpression(t, n);
      }
      isEquivalent() {
        return !1;
      }
      isConstant() {
        return !1;
      }
      transformInternalExpressions(t, n) {
        this.args = (this.args, void 0);
      }
      clone() {
        let t = new e21(this.target, this.targetSlot, this.name, this.args.clone(), this.numArgs);
        return t.varOffset = this.varOffset, t;
      }
    };
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.InChildOperation = 1] = "InChildOperation";
    })($t || ($t = {}));
    vi = /* @__PURE__ */ new Set([f.Element, f.ElementStart, f.Container, f.ContainerStart, f.Template, f.RepeaterCreate, f.ConditionalCreate, f.ConditionalBranchCreate]);
    (function(e22) {
      e22[e22.Tmpl = 0] = "Tmpl", e22[e22.Host = 1] = "Host", e22[e22.Both = 2] = "Both";
    })(Yn || (Yn = {}));
    (function(e22) {
      e22[e22.Full = 0] = "Full", e22[e22.DomOnly = 1] = "DomOnly";
    })(Qn || (Qn = {}));
    xi = /* @__PURE__ */ new Map([[l.ariaProperty, l.ariaProperty], [l.attribute, l.attribute], [l.classProp, l.classProp], [l.element, l.element], [l.elementContainer, l.elementContainer], [l.elementContainerEnd, l.elementContainerEnd], [l.elementContainerStart, l.elementContainerStart], [l.elementEnd, l.elementEnd], [l.elementStart, l.elementStart], [l.domProperty, l.domProperty], [l.i18nExp, l.i18nExp], [l.listener, l.listener], [l.listener, l.listener], [l.property, l.property], [l.styleProp, l.styleProp], [l.syntheticHostListener, l.syntheticHostListener], [l.syntheticHostProperty, l.syntheticHostProperty], [l.templateCreate, l.templateCreate], [l.twoWayProperty, l.twoWayProperty], [l.twoWayListener, l.twoWayListener], [l.declareLet, l.declareLet], [l.conditionalCreate, l.conditionalBranchCreate], [l.conditionalBranchCreate, l.conditionalBranchCreate], [l.domElement, l.domElement], [l.domElementStart, l.domElementStart], [l.domElementEnd, l.domElementEnd], [l.domElementContainer, l.domElementContainer], [l.domElementContainerStart, l.domElementContainerStart], [l.domElementContainerEnd, l.domElementContainerEnd], [l.domListener, l.domListener], [l.domTemplate, l.domTemplate], [l.animationEnter, l.animationEnter], [l.animationLeave, l.animationLeave], [l.animationEnterListener, l.animationEnterListener], [l.animationLeaveListener, l.animationLeaveListener]]), wi = /* @__PURE__ */ new Map([["&&", u.And], [">", u.Bigger], [">=", u.BiggerEquals], ["|", u.BitwiseOr], ["&", u.BitwiseAnd], ["/", u.Divide], ["=", u.Assign], ["==", u.Equals], ["===", u.Identical], ["<", u.Lower], ["<=", u.LowerEquals], ["-", u.Minus], ["%", u.Modulo], ["**", u.Exponentiation], ["*", u.Multiply], ["!=", u.NotEquals], ["!==", u.NotIdentical], ["??", u.NullishCoalesce], ["||", u.Or], ["+", u.Plus], ["in", u.In], ["+=", u.AdditionAssignment], ["-=", u.SubtractionAssignment], ["*=", u.MultiplicationAssignment], ["/=", u.DivisionAssignment], ["%=", u.RemainderAssignment], ["**=", u.ExponentiationAssignment], ["&&=", u.AndAssignment], ["||=", u.OrAssignment], ["??=", u.NullishCoalesceAssignment]]), Si = Object.freeze([]), Ei = /* @__PURE__ */ new Map([[f.ElementEnd, [f.ElementStart, f.Element]], [f.ContainerEnd, [f.ContainerStart, f.Container]], [f.I18nEnd, [f.I18nStart, f.I18n]]]), yi = /* @__PURE__ */ new Set([f.Pipe]), _r = {}, Cr = "\uE500";
    _r.ngsp = Cr;
    (function(e22) {
      e22.HEX = "hexadecimal", e22.DEC = "decimal";
    })(Kn || (Kn = {}));
    xs = ` \f
\r	\v\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`, _i = new RegExp(`[^${xs}]`), Ci = new RegExp(`[${xs}]{2,}`, "g");
    (function(e22) {
      e22[e22.Character = 0] = "Character", e22[e22.Identifier = 1] = "Identifier", e22[e22.PrivateIdentifier = 2] = "PrivateIdentifier", e22[e22.Keyword = 3] = "Keyword", e22[e22.String = 4] = "String", e22[e22.Operator = 5] = "Operator", e22[e22.Number = 6] = "Number", e22[e22.RegExpBody = 7] = "RegExpBody", e22[e22.RegExpFlags = 8] = "RegExpFlags", e22[e22.Error = 9] = "Error";
    })(p || (p = {}));
    (function(e22) {
      e22[e22.Plain = 0] = "Plain", e22[e22.TemplateLiteralPart = 1] = "TemplateLiteralPart", e22[e22.TemplateLiteralEnd = 2] = "TemplateLiteralEnd";
    })(V || (V = {}));
    kr = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this", "typeof", "void", "in"], Ue = class {
      tokenize(t) {
        return new Dt(t).scan();
      }
    }, I = class {
      index;
      end;
      type;
      numValue;
      strValue;
      constructor(t, n, s, r, i) {
        this.index = t, this.end = n, this.type = s, this.numValue = r, this.strValue = i;
      }
      isCharacter(t) {
        return this.type === p.Character && this.numValue === t;
      }
      isNumber() {
        return this.type === p.Number;
      }
      isString() {
        return this.type === p.String;
      }
      isOperator(t) {
        return this.type === p.Operator && this.strValue === t;
      }
      isIdentifier() {
        return this.type === p.Identifier;
      }
      isPrivateIdentifier() {
        return this.type === p.PrivateIdentifier;
      }
      isKeyword() {
        return this.type === p.Keyword;
      }
      isKeywordLet() {
        return this.type === p.Keyword && this.strValue === "let";
      }
      isKeywordAs() {
        return this.type === p.Keyword && this.strValue === "as";
      }
      isKeywordNull() {
        return this.type === p.Keyword && this.strValue === "null";
      }
      isKeywordUndefined() {
        return this.type === p.Keyword && this.strValue === "undefined";
      }
      isKeywordTrue() {
        return this.type === p.Keyword && this.strValue === "true";
      }
      isKeywordFalse() {
        return this.type === p.Keyword && this.strValue === "false";
      }
      isKeywordThis() {
        return this.type === p.Keyword && this.strValue === "this";
      }
      isKeywordTypeof() {
        return this.type === p.Keyword && this.strValue === "typeof";
      }
      isKeywordVoid() {
        return this.type === p.Keyword && this.strValue === "void";
      }
      isKeywordIn() {
        return this.type === p.Keyword && this.strValue === "in";
      }
      isError() {
        return this.type === p.Error;
      }
      isRegExpBody() {
        return this.type === p.RegExpBody;
      }
      isRegExpFlags() {
        return this.type === p.RegExpFlags;
      }
      toNumber() {
        return this.type === p.Number ? this.numValue : -1;
      }
      isTemplateLiteralPart() {
        return this.isString() && this.kind === V.TemplateLiteralPart;
      }
      isTemplateLiteralEnd() {
        return this.isString() && this.kind === V.TemplateLiteralEnd;
      }
      isTemplateLiteralInterpolationStart() {
        return this.isOperator("${");
      }
      toString() {
        switch (this.type) {
          case p.Character:
          case p.Identifier:
          case p.Keyword:
          case p.Operator:
          case p.PrivateIdentifier:
          case p.String:
          case p.Error:
          case p.RegExpBody:
          case p.RegExpFlags:
            return this.strValue;
          case p.Number:
            return this.numValue.toString();
          default:
            return null;
        }
      }
    }, Ie = class extends I {
      kind;
      constructor(t, n, s, r) {
        super(t, n, p.String, 0, s), this.kind = r;
      }
    };
    Ge = new I(-1, -1, p.Character, 0, ""), Dt = class {
      input;
      tokens = [];
      length;
      peek = 0;
      index = -1;
      braceStack = [];
      constructor(t) {
        this.input = t, this.length = t.length, this.advance();
      }
      scan() {
        let t = this.scanToken();
        for (; t !== null; ) this.tokens.push(t), t = this.scanToken();
        return this.tokens;
      }
      advance() {
        this.peek = ++this.index >= this.length ? ye : this.input.charCodeAt(this.index);
      }
      scanToken() {
        let t = this.input, n = this.length, s = this.peek, r = this.index;
        for (; s <= os; ) if (++r >= n) {
          s = ye;
          break;
        } else s = t.charCodeAt(r);
        if (this.peek = s, this.index = r, r >= n) return null;
        if (Zn(s)) return this.scanIdentifier();
        if (W(s)) return this.scanNumber(r);
        let i = r;
        switch (s) {
          case ke:
            return this.advance(), W(this.peek) ? this.scanNumber(i) : _e(i, this.index, ke);
          case Ae:
          case q:
          case le:
          case G:
          case re:
          case j:
          case Te:
            return this.scanCharacter(i, s);
          case Ze:
            return this.scanOpenBrace(i, s);
          case ie:
            return this.scanCloseBrace(i, s);
          case cs:
          case ls:
            return this.scanString();
          case Pt:
            return this.advance(), this.scanTemplateLiteralPart(i);
          case Qs:
            return this.scanPrivateIdentifier();
          case us:
            return this.scanComplexOperator(i, "+", b, "=");
          case hs:
            return this.scanComplexOperator(i, "-", b, "=");
          case Ke:
            return this.isStartOfRegex() ? this.scanRegex(r) : this.scanComplexOperator(i, "/", b, "=");
          case Ks:
            return this.scanComplexOperator(i, "%", b, "=");
          case rr:
            return this.scanOperator(i, "^");
          case Nn:
            return this.scanStar(i);
          case Pn:
            return this.scanQuestion(i);
          case Zs:
          case er:
            return this.scanComplexOperator(i, String.fromCharCode(s), b, "=");
          case Ys:
          case b:
            return this.scanComplexOperator(i, String.fromCharCode(s), b, "=", b, "=");
          case In:
            return this.scanComplexOperator(i, "&", In, "&", b, "=");
          case Ln:
            return this.scanComplexOperator(i, "|", Ln, "|", b, "=");
          case ds:
            for (; pr(this.peek); ) this.advance();
            return this.scanToken();
        }
        return this.advance(), this.error(`Unexpected character [${String.fromCharCode(s)}]`, 0);
      }
      scanCharacter(t, n) {
        return this.advance(), _e(t, this.index, n);
      }
      scanOperator(t, n) {
        return this.advance(), Ce(t, this.index, n);
      }
      scanOpenBrace(t, n) {
        return this.braceStack.push("expression"), this.advance(), _e(t, this.index, n);
      }
      scanCloseBrace(t, n) {
        return this.advance(), this.braceStack.pop() === "interpolation" ? (this.tokens.push(_e(t, this.index, ie)), this.scanTemplateLiteralPart(this.index)) : _e(t, this.index, n);
      }
      scanComplexOperator(t, n, s, r, i, o) {
        this.advance();
        let c = n;
        return this.peek == s && (this.advance(), c += r), i != null && this.peek == i && (this.advance(), c += o), Ce(t, this.index, c);
      }
      scanIdentifier() {
        let t = this.index;
        for (this.advance(); es(this.peek); ) this.advance();
        let n = this.input.substring(t, this.index);
        return kr.indexOf(n) > -1 ? Ar(t, this.index, n) : Tr(t, this.index, n);
      }
      scanPrivateIdentifier() {
        let t = this.index;
        if (this.advance(), !Zn(this.peek)) return this.error("Invalid character [#]", -1);
        for (; es(this.peek); ) this.advance();
        let n = this.input.substring(t, this.index);
        return br(t, this.index, n);
      }
      scanNumber(t) {
        let n = this.index === t, s = !1;
        for (this.advance(); ; ) {
          if (!W(this.peek)) if (this.peek === ot) {
            if (!W(this.input.charCodeAt(this.index - 1)) || !W(this.input.charCodeAt(this.index + 1))) return this.error("Invalid numeric separator", 0);
            s = !0;
          } else if (this.peek === ke) n = !1;
          else if (Mr(this.peek)) {
            if (this.advance(), Rr(this.peek) && this.advance(), !W(this.peek)) return this.error("Invalid exponent", -1);
            n = !1;
          } else break;
          this.advance();
        }
        let r = this.input.substring(t, this.index);
        s && (r = r.replace(/_/g, ""));
        let i = n ? Dr(r) : parseFloat(r);
        return Ir(t, this.index, i);
      }
      scanString() {
        let t = this.index, n = this.peek;
        this.advance();
        let s = "", r = this.index, i = this.input;
        for (; this.peek != n; ) if (this.peek == mt) {
          let c = this.scanStringBackslash(s, r);
          if (typeof c != "string") return c;
          s = c, r = this.index;
        } else {
          if (this.peek == ye) return this.error("Unterminated quote", 0);
          this.advance();
        }
        let o = i.substring(r, this.index);
        return this.advance(), new Ie(t, this.index, s + o, V.Plain);
      }
      scanQuestion(t) {
        this.advance();
        let n = "?";
        return this.peek === Pn ? (n += "?", this.advance(), this.peek === b && (n += "=", this.advance())) : this.peek === ke && (n += ".", this.advance()), Ce(t, this.index, n);
      }
      scanTemplateLiteralPart(t) {
        let n = "", s = this.index;
        for (; this.peek !== Pt; ) if (this.peek === mt) {
          let i = this.scanStringBackslash(n, s);
          if (typeof i != "string") return i;
          n = i, s = this.index;
        } else if (this.peek === Ht) {
          let i = this.index;
          if (this.advance(), this.peek === Ze) return this.braceStack.push("interpolation"), this.tokens.push(new Ie(t, i, n + this.input.substring(s, i), V.TemplateLiteralPart)), this.advance(), Ce(i, this.index, this.input.substring(i, this.index));
        } else {
          if (this.peek === ye) return this.error("Unterminated template literal", 0);
          this.advance();
        }
        let r = this.input.substring(s, this.index);
        return this.advance(), new Ie(t, this.index, n + r, V.TemplateLiteralEnd);
      }
      error(t, n) {
        let s = this.index + n;
        return Nr(s, this.index, `Lexer Error: ${t} at column ${s} in expression [${this.input}]`);
      }
      scanStringBackslash(t, n) {
        t += this.input.substring(n, this.index);
        let s;
        if (this.advance(), this.peek === ur) {
          let r = this.input.substring(this.index + 1, this.index + 5);
          if (/^[0-9a-f]+$/i.test(r)) s = parseInt(r, 16);
          else return this.error(`Invalid unicode escape [\\u${r}]`, 0);
          for (let i = 0; i < 5; i++) this.advance();
        } else s = $r(this.peek), this.advance();
        return t += String.fromCharCode(s), t;
      }
      scanStar(t) {
        this.advance();
        let n = "*";
        return this.peek === Nn ? (n += "*", this.advance(), this.peek === b && (n += "=", this.advance())) : this.peek === b && (n += "=", this.advance()), Ce(t, this.index, n);
      }
      isStartOfRegex() {
        if (this.tokens.length === 0) return !0;
        let t = this.tokens[this.tokens.length - 1];
        if (t.isOperator("!")) {
          let n = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;
          return n === null || n.type !== p.Identifier && !n.isCharacter(q) && !n.isCharacter(G);
        }
        return t.type === p.Operator || t.isCharacter(Ae) || t.isCharacter(le) || t.isCharacter(re) || t.isCharacter(j);
      }
      scanRegex(t) {
        this.advance();
        let n = this.index, s = !1, r = !1;
        for (; ; ) {
          let h = this.peek;
          if (h === ye) return this.error("Unterminated regular expression", 0);
          if (s) s = !1;
          else if (h === mt) s = !0;
          else if (h === le) r = !0;
          else if (h === G) r = !1;
          else if (h === Ke && !r) break;
          this.advance();
        }
        let i = this.input.substring(n, this.index);
        this.advance();
        let o = Pr(t, this.index, i), c = this.scanRegexFlags(this.index);
        return c !== null ? (this.tokens.push(o), c) : o;
      }
      scanRegexFlags(t) {
        if (!Lt(this.peek)) return null;
        for (; Lt(this.peek); ) this.advance();
        return Lr(t, this.index, this.input.substring(t, this.index));
      }
    };
    Bt = class {
      strings;
      expressions;
      offsets;
      constructor(t, n, s) {
        this.strings = t, this.expressions = n, this.offsets = s;
      }
    }, Ot = class {
      templateBindings;
      warnings;
      errors;
      constructor(t, n, s) {
        this.templateBindings = t, this.warnings = n, this.errors = s;
      }
    };
    we = class {
      _lexer;
      _supportsDirectPipeReferences;
      constructor(t, n = !1) {
        this._lexer = t, this._supportsDirectPipeReferences = n;
      }
      parseAction(t, n, s) {
        let r = [];
        this._checkNoInterpolation(r, t, n);
        let { stripped: i } = this._stripComments(t), o = this._lexer.tokenize(i), c = new z(t, n, s, o, 1, r, 0, this._supportsDirectPipeReferences).parseChain();
        return new F(c, t, O(n), s, r);
      }
      parseBinding(t, n, s) {
        let r = [], i = this._parseBindingAst(t, n, s, r);
        return new F(i, t, O(n), s, r);
      }
      checkSimpleExpression(t) {
        let n = new Ft();
        return t.visit(n), n.errors;
      }
      parseSimpleBinding(t, n, s) {
        let r = [], i = this._parseBindingAst(t, n, s, r), o = this.checkSimpleExpression(i);
        return o.length > 0 && r.push(oe(`Host binding expression cannot contain ${o.join(" ")}`, t, "", n)), new F(i, t, O(n), s, r);
      }
      _parseBindingAst(t, n, s, r) {
        this._checkNoInterpolation(r, t, n);
        let { stripped: i } = this._stripComments(t), o = this._lexer.tokenize(i);
        return new z(t, n, s, o, 0, r, 0, this._supportsDirectPipeReferences).parseChain();
      }
      parseTemplateBindings(t, n, s, r, i) {
        let o = this._lexer.tokenize(n), c = [];
        return new z(n, s, i, o, 0, c, 0, this._supportsDirectPipeReferences).parseTemplateBindings({ source: t, span: new B(r, r + t.length) });
      }
      parseInterpolation(t, n, s, r) {
        let i = [], { strings: o, expressions: c, offsets: h } = this.splitInterpolation(t, n, i, r);
        if (c.length === 0) return null;
        let d = [];
        for (let g = 0; g < c.length; ++g) {
          let S = r?.[g * 2 + 1]?.sourceSpan, E = c[g].text, { stripped: P, hasComments: C } = this._stripComments(E), N = this._lexer.tokenize(P);
          if (C && P.trim().length === 0 && N.length === 0) {
            i.push(oe("Interpolation expression cannot only contain a comment", t, `at column ${c[g].start} in`, n));
            continue;
          }
          let H = new z(S ? E : t, S || n, s, N, 0, i, h[g], this._supportsDirectPipeReferences).parseChain();
          d.push(H);
        }
        return this.createInterpolationAst(o.map((g) => g.text), d, t, O(n), s, i);
      }
      parseInterpolationExpression(t, n, s) {
        let { stripped: r } = this._stripComments(t), i = this._lexer.tokenize(r), o = [], c = new z(t, n, s, i, 0, o, 0, this._supportsDirectPipeReferences).parseChain(), h = ["", ""];
        return this.createInterpolationAst(h, [c], t, O(n), s, o);
      }
      createInterpolationAst(t, n, s, r, i, o) {
        let c = new Y(0, s.length), h = new Vt(c, c.toAbsolute(i), t, n);
        return new F(h, s, r, i, o);
      }
      splitInterpolation(t, n, s, r) {
        let i = [], o = [], c = [], h = r ? Br(r) : null, d = 0, g = !1, S = !1, E = "{{", P = "}}";
        for (; d < t.length; ) if (g) {
          let C = d, N = C + E.length, H = this._getInterpolationEndIndex(t, P, N);
          if (H === -1) {
            g = !1, S = !0;
            break;
          }
          let nn = H + P.length, sn = t.substring(N, H);
          sn.trim().length === 0 && s.push(oe("Blank expressions are not allowed in interpolated strings", t, `at column ${d} in`, n)), o.push({ text: sn, start: C, end: nn });
          let Vs = (h?.get(C) ?? C) + E.length;
          c.push(Vs), d = nn, g = !1;
        } else {
          let C = d;
          d = t.indexOf(E, d), d === -1 && (d = t.length);
          let N = t.substring(C, d);
          i.push({ text: N, start: C, end: d }), g = !0;
        }
        if (!g) if (S) {
          let C = i[i.length - 1];
          C.text += t.substring(d), C.end = t.length;
        } else i.push({ text: t.substring(d), start: d, end: t.length });
        return new Bt(i, o, c);
      }
      wrapLiteralPrimitive(t, n, s) {
        let r = new Y(0, t == null ? 0 : t.length);
        return new F(new k(r, r.toAbsolute(s), t), t, typeof n == "string" ? n : O(n), s, []);
      }
      _stripComments(t) {
        let n = this._commentStart(t);
        return n != null ? { stripped: t.substring(0, n), hasComments: !0 } : { stripped: t, hasComments: !1 };
      }
      _commentStart(t) {
        let n = null;
        for (let s = 0; s < t.length - 1; s++) {
          let r = t.charCodeAt(s), i = t.charCodeAt(s + 1);
          if (r === Ke && i == Ke && n == null) return s;
          n === r ? n = null : n == null && Mn(r) && (n = r);
        }
        return null;
      }
      _checkNoInterpolation(t, n, s) {
        let r = -1, i = -1;
        for (let o of this._forEachUnquotedChar(n, 0)) if (r === -1) n.startsWith("{{") && (r = o);
        else if (i = this._getInterpolationEndIndex(n, "}}", o), i > -1) break;
        r > -1 && i > -1 && t.push(oe("Got interpolation ({{}}) where expression was expected", n, `at column ${r} in`, s));
      }
      _getInterpolationEndIndex(t, n, s) {
        for (let r of this._forEachUnquotedChar(t, s)) {
          if (t.startsWith(n, r)) return r;
          if (t.startsWith("//", r)) return t.indexOf(n, r);
        }
        return -1;
      }
      *_forEachUnquotedChar(t, n) {
        let s = null, r = 0;
        for (let i = n; i < t.length; i++) {
          let o = t[i];
          Mn(t.charCodeAt(i)) && (s === null || s === o) && r % 2 === 0 ? s = s === null ? o : null : s === null && (yield i), r = o === "\\" ? r + 1 : 0;
        }
      }
    };
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.Writable = 1] = "Writable";
    })(ae || (ae = {}));
    ts = /* @__PURE__ */ new Set(["d", "g", "i", "m", "s", "u", "v", "y"]), z = class {
      input;
      parseSourceSpan;
      absoluteOffset;
      tokens;
      parseFlags;
      errors;
      offset;
      supportsDirectPipeReferences;
      rparensExpected = 0;
      rbracketsExpected = 0;
      rbracesExpected = 0;
      context = ae.None;
      sourceSpanCache = /* @__PURE__ */ new Map();
      index = 0;
      constructor(t, n, s, r, i, o, c, h) {
        this.input = t, this.parseSourceSpan = n, this.absoluteOffset = s, this.tokens = r, this.parseFlags = i, this.errors = o, this.offset = c, this.supportsDirectPipeReferences = h;
      }
      peek(t) {
        let n = this.index + t;
        return n < this.tokens.length ? this.tokens[n] : Ge;
      }
      get next() {
        return this.peek(0);
      }
      get atEOF() {
        return this.index >= this.tokens.length;
      }
      get inputIndex() {
        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
      }
      get currentEndIndex() {
        return this.index > 0 ? this.peek(-1).end + this.offset : this.tokens.length === 0 ? this.input.length + this.offset : this.next.index + this.offset;
      }
      get currentAbsoluteOffset() {
        return this.absoluteOffset + this.inputIndex;
      }
      span(t, n) {
        let s = this.currentEndIndex;
        if (n !== void 0 && n > this.currentEndIndex && (s = n), t > s) {
          let r = s;
          s = t, t = r;
        }
        return new Y(t, s);
      }
      sourceSpan(t, n) {
        let s = `${t}@${this.inputIndex}:${n}`;
        return this.sourceSpanCache.has(s) || this.sourceSpanCache.set(s, this.span(t, n).toAbsolute(this.absoluteOffset)), this.sourceSpanCache.get(s);
      }
      advance() {
        this.index++;
      }
      withContext(t, n) {
        this.context |= t;
        let s = n();
        return this.context ^= t, s;
      }
      consumeOptionalCharacter(t) {
        return this.next.isCharacter(t) ? (this.advance(), !0) : !1;
      }
      peekKeywordLet() {
        return this.next.isKeywordLet();
      }
      peekKeywordAs() {
        return this.next.isKeywordAs();
      }
      expectCharacter(t) {
        this.consumeOptionalCharacter(t) || this.error(`Missing expected ${String.fromCharCode(t)}`);
      }
      consumeOptionalOperator(t) {
        return this.next.isOperator(t) ? (this.advance(), !0) : !1;
      }
      isAssignmentOperator(t) {
        return t.type === p.Operator && y.isAssignmentOperation(t.strValue);
      }
      expectOperator(t) {
        this.consumeOptionalOperator(t) || this.error(`Missing expected operator ${t}`);
      }
      prettyPrintToken(t) {
        return t === Ge ? "end of input" : `token ${t}`;
      }
      expectIdentifierOrKeyword() {
        let t = this.next;
        return !t.isIdentifier() && !t.isKeyword() ? (t.isPrivateIdentifier() ? this._reportErrorForPrivateIdentifier(t, "expected identifier or keyword") : this.error(`Unexpected ${this.prettyPrintToken(t)}, expected identifier or keyword`), null) : (this.advance(), t.toString());
      }
      expectIdentifierOrKeywordOrString() {
        let t = this.next;
        return !t.isIdentifier() && !t.isKeyword() && !t.isString() ? (t.isPrivateIdentifier() ? this._reportErrorForPrivateIdentifier(t, "expected identifier, keyword or string") : this.error(`Unexpected ${this.prettyPrintToken(t)}, expected identifier, keyword, or string`), "") : (this.advance(), t.toString());
      }
      parseChain() {
        let t = [], n = this.inputIndex;
        for (; this.index < this.tokens.length; ) {
          let s = this.parsePipe();
          if (t.push(s), this.consumeOptionalCharacter(Te)) for (this.parseFlags & 1 || this.error("Binding expression cannot contain chained expression"); this.consumeOptionalCharacter(Te); ) ;
          else if (this.index < this.tokens.length) {
            let r = this.index;
            if (this.error(`Unexpected token '${this.next}'`), this.index === r) break;
          }
        }
        if (t.length === 0) {
          let s = this.offset, r = this.offset + this.input.length;
          return new A(this.span(s, r), this.sourceSpan(s, r));
        }
        return t.length == 1 ? t[0] : new Le(this.span(n), this.sourceSpan(n), t);
      }
      parsePipe() {
        let t = this.inputIndex, n = this.parseExpression();
        if (this.consumeOptionalOperator("|")) {
          this.parseFlags & 1 && this.error("Cannot have a pipe in an action expression");
          do {
            let s = this.inputIndex, r = this.expectIdentifierOrKeyword(), i, o;
            r !== null ? i = this.sourceSpan(s) : (r = "", o = this.next.index !== -1 ? this.next.index : this.input.length + this.offset, i = new Y(o, o).toAbsolute(this.absoluteOffset));
            let c = [];
            for (; this.consumeOptionalCharacter(j); ) c.push(this.parseExpression());
            let h;
            if (this.supportsDirectPipeReferences) {
              let d = r.charCodeAt(0);
              h = d === ot || d >= Ut && d <= Wt ? be.ReferencedDirectly : be.ReferencedByName;
            } else h = be.ReferencedByName;
            n = new Re(this.span(t), this.sourceSpan(t, o), n, r, c, h, i);
          } while (this.consumeOptionalOperator("|"));
        }
        return n;
      }
      parseExpression() {
        return this.parseConditional();
      }
      parseConditional() {
        let t = this.inputIndex, n = this.parseLogicalOr();
        if (this.consumeOptionalOperator("?")) {
          let s = this.parsePipe(), r;
          if (this.consumeOptionalCharacter(j)) r = this.parsePipe();
          else {
            let i = this.inputIndex, o = this.input.substring(t, i);
            this.error(`Conditional expression ${o} requires all 3 expressions`), r = new A(this.span(t), this.sourceSpan(t));
          }
          return new Me(this.span(t), this.sourceSpan(t), n, s, r);
        } else return n;
      }
      parseLogicalOr() {
        let t = this.inputIndex, n = this.parseLogicalAnd();
        for (; this.consumeOptionalOperator("||"); ) {
          let s = this.parseLogicalAnd();
          n = new y(this.span(t), this.sourceSpan(t), "||", n, s);
        }
        return n;
      }
      parseLogicalAnd() {
        let t = this.inputIndex, n = this.parseNullishCoalescing();
        for (; this.consumeOptionalOperator("&&"); ) {
          let s = this.parseNullishCoalescing();
          n = new y(this.span(t), this.sourceSpan(t), "&&", n, s);
        }
        return n;
      }
      parseNullishCoalescing() {
        let t = this.inputIndex, n = this.parseEquality();
        for (; this.consumeOptionalOperator("??"); ) {
          let s = this.parseEquality();
          n = new y(this.span(t), this.sourceSpan(t), "??", n, s);
        }
        return n;
      }
      parseEquality() {
        let t = this.inputIndex, n = this.parseRelational();
        for (; this.next.type == p.Operator; ) {
          let s = this.next.strValue;
          switch (s) {
            case "==":
            case "===":
            case "!=":
            case "!==":
              this.advance();
              let r = this.parseRelational();
              n = new y(this.span(t), this.sourceSpan(t), s, n, r);
              continue;
          }
          break;
        }
        return n;
      }
      parseRelational() {
        let t = this.inputIndex, n = this.parseAdditive();
        for (; this.next.type == p.Operator || this.next.isKeywordIn; ) {
          let s = this.next.strValue;
          switch (s) {
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "in":
              this.advance();
              let r = this.parseAdditive();
              n = new y(this.span(t), this.sourceSpan(t), s, n, r);
              continue;
          }
          break;
        }
        return n;
      }
      parseAdditive() {
        let t = this.inputIndex, n = this.parseMultiplicative();
        for (; this.next.type == p.Operator; ) {
          let s = this.next.strValue;
          switch (s) {
            case "+":
            case "-":
              this.advance();
              let r = this.parseMultiplicative();
              n = new y(this.span(t), this.sourceSpan(t), s, n, r);
              continue;
          }
          break;
        }
        return n;
      }
      parseMultiplicative() {
        let t = this.inputIndex, n = this.parseExponentiation();
        for (; this.next.type == p.Operator; ) {
          let s = this.next.strValue;
          switch (s) {
            case "*":
            case "%":
            case "/":
              this.advance();
              let r = this.parseExponentiation();
              n = new y(this.span(t), this.sourceSpan(t), s, n, r);
              continue;
          }
          break;
        }
        return n;
      }
      parseExponentiation() {
        let t = this.inputIndex, n = this.parsePrefix();
        for (; this.next.type == p.Operator && this.next.strValue === "**"; ) {
          (n instanceof J || n instanceof K || n instanceof Z || n instanceof ee) && this.error("Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence"), this.advance();
          let s = this.parseExponentiation();
          n = new y(this.span(t), this.sourceSpan(t), "**", n, s);
        }
        return n;
      }
      parsePrefix() {
        if (this.next.type == p.Operator) {
          let t = this.inputIndex, n = this.next.strValue, s;
          switch (n) {
            case "+":
              return this.advance(), s = this.parsePrefix(), J.createPlus(this.span(t), this.sourceSpan(t), s);
            case "-":
              return this.advance(), s = this.parsePrefix(), J.createMinus(this.span(t), this.sourceSpan(t), s);
            case "!":
              return this.advance(), s = this.parsePrefix(), new K(this.span(t), this.sourceSpan(t), s);
          }
        } else if (this.next.isKeywordTypeof()) {
          this.advance();
          let t = this.inputIndex, n = this.parsePrefix();
          return new Z(this.span(t), this.sourceSpan(t), n);
        } else if (this.next.isKeywordVoid()) {
          this.advance();
          let t = this.inputIndex, n = this.parsePrefix();
          return new ee(this.span(t), this.sourceSpan(t), n);
        }
        return this.parseCallChain();
      }
      parseCallChain() {
        let t = this.inputIndex, n = this.parsePrimary();
        for (; ; ) if (this.consumeOptionalCharacter(ke)) n = this.parseAccessMember(n, t, !1);
        else if (this.consumeOptionalOperator("?.")) this.consumeOptionalCharacter(Ae) ? n = this.parseCall(n, t, !0) : n = this.consumeOptionalCharacter(le) ? this.parseKeyedReadOrWrite(n, t, !0) : this.parseAccessMember(n, t, !0);
        else if (this.consumeOptionalCharacter(le)) n = this.parseKeyedReadOrWrite(n, t, !1);
        else if (this.consumeOptionalCharacter(Ae)) n = this.parseCall(n, t, !1);
        else if (this.consumeOptionalOperator("!")) n = new Be(this.span(t), this.sourceSpan(t), n);
        else if (this.next.isTemplateLiteralEnd()) n = this.parseNoInterpolationTaggedTemplateLiteral(n, t);
        else if (this.next.isTemplateLiteralPart()) n = this.parseTaggedTemplateLiteral(n, t);
        else return n;
      }
      parsePrimary() {
        let t = this.inputIndex;
        if (this.consumeOptionalCharacter(Ae)) {
          this.rparensExpected++;
          let n = this.parsePipe();
          return this.consumeOptionalCharacter(q) || (this.error("Missing closing parentheses"), this.consumeOptionalCharacter(q)), this.rparensExpected--, new Fe(this.span(t), this.sourceSpan(t), n);
        } else {
          if (this.next.isKeywordNull()) return this.advance(), new k(this.span(t), this.sourceSpan(t), null);
          if (this.next.isKeywordUndefined()) return this.advance(), new k(this.span(t), this.sourceSpan(t), void 0);
          if (this.next.isKeywordTrue()) return this.advance(), new k(this.span(t), this.sourceSpan(t), !0);
          if (this.next.isKeywordFalse()) return this.advance(), new k(this.span(t), this.sourceSpan(t), !1);
          if (this.next.isKeywordIn()) return this.advance(), new k(this.span(t), this.sourceSpan(t), "in");
          if (this.next.isKeywordThis()) return this.advance(), new It(this.span(t), this.sourceSpan(t));
          if (this.consumeOptionalCharacter(le)) {
            this.rbracketsExpected++;
            let n = this.parseExpressionList(G);
            return this.rbracketsExpected--, this.expectCharacter(G), new $e(this.span(t), this.sourceSpan(t), n);
          } else {
            if (this.next.isCharacter(Ze)) return this.parseLiteralMap();
            if (this.next.isIdentifier()) return this.parseAccessMember(new Q(this.span(t), this.sourceSpan(t)), t, !1);
            if (this.next.isNumber()) {
              let n = this.next.toNumber();
              return this.advance(), new k(this.span(t), this.sourceSpan(t), n);
            } else {
              if (this.next.isTemplateLiteralEnd()) return this.parseNoInterpolationTemplateLiteral();
              if (this.next.isTemplateLiteralPart()) return this.parseTemplateLiteral();
              if (this.next.isString() && this.next.kind === V.Plain) {
                let n = this.next.toString();
                return this.advance(), new k(this.span(t), this.sourceSpan(t), n);
              } else return this.next.isPrivateIdentifier() ? (this._reportErrorForPrivateIdentifier(this.next, null), new A(this.span(t), this.sourceSpan(t))) : this.next.isRegExpBody() ? this.parseRegularExpressionLiteral() : this.index >= this.tokens.length ? (this.error(`Unexpected end of expression: ${this.input}`), new A(this.span(t), this.sourceSpan(t))) : (this.error(`Unexpected token ${this.next}`), new A(this.span(t), this.sourceSpan(t)));
            }
          }
        }
      }
      parseExpressionList(t) {
        let n = [];
        do
          if (!this.next.isCharacter(t)) n.push(this.parsePipe());
          else break;
        while (this.consumeOptionalCharacter(re));
        return n;
      }
      parseLiteralMap() {
        let t = [], n = [], s = this.inputIndex;
        if (this.expectCharacter(Ze), !this.consumeOptionalCharacter(ie)) {
          this.rbracesExpected++;
          do {
            let r = this.inputIndex, i = this.next.isString(), o = this.expectIdentifierOrKeywordOrString(), c = { key: o, quoted: i };
            if (t.push(c), i) this.expectCharacter(j), n.push(this.parsePipe());
            else if (this.consumeOptionalCharacter(j)) n.push(this.parsePipe());
            else {
              c.isShorthandInitialized = !0;
              let h = this.span(r), d = this.sourceSpan(r);
              n.push(new X(h, d, d, new Q(h, d), o));
            }
          } while (this.consumeOptionalCharacter(re) && !this.next.isCharacter(ie));
          this.rbracesExpected--, this.expectCharacter(ie);
        }
        return new De(this.span(s), this.sourceSpan(s), t, n);
      }
      parseAccessMember(t, n, s) {
        let r = this.inputIndex, i = this.withContext(ae.Writable, () => {
          let c = this.expectIdentifierOrKeyword() ?? "";
          return c.length === 0 && this.error("Expected identifier for property access", t.span.end), c;
        }), o = this.sourceSpan(r);
        if (s) return this.isAssignmentOperator(this.next) ? (this.advance(), this.error("The '?.' operator cannot be used in the assignment"), new A(this.span(n), this.sourceSpan(n))) : new ce(this.span(n), this.sourceSpan(n), o, t, i);
        if (this.isAssignmentOperator(this.next)) {
          let c = this.next.strValue;
          if (!(this.parseFlags & 1)) return this.advance(), this.error("Bindings cannot contain assignments"), new A(this.span(n), this.sourceSpan(n));
          let h = new X(this.span(n), this.sourceSpan(n), o, t, i);
          this.advance();
          let d = this.parseConditional();
          return new y(this.span(n), this.sourceSpan(n), c, h, d);
        } else return new X(this.span(n), this.sourceSpan(n), o, t, i);
      }
      parseCall(t, n, s) {
        let r = this.inputIndex;
        this.rparensExpected++;
        let i = this.parseCallArguments(), o = this.span(r, this.inputIndex).toAbsolute(this.absoluteOffset);
        this.expectCharacter(q), this.rparensExpected--;
        let c = this.span(n), h = this.sourceSpan(n);
        return s ? new pe(c, h, t, i, o) : new Oe(c, h, t, i, o);
      }
      parseCallArguments() {
        if (this.next.isCharacter(q)) return [];
        let t = [];
        do
          t.push(this.parsePipe());
        while (this.consumeOptionalCharacter(re));
        return t;
      }
      expectTemplateBindingKey() {
        let t = "", n = !1, s = this.currentAbsoluteOffset;
        do
          t += this.expectIdentifierOrKeywordOrString(), n = this.consumeOptionalOperator("-"), n && (t += "-");
        while (n);
        return { source: t, span: new B(s, s + t.length) };
      }
      parseTemplateBindings(t) {
        let n = [];
        for (n.push(...this.parseDirectiveKeywordBindings(t)); this.index < this.tokens.length; ) {
          let s = this.parseLetBinding();
          if (s) n.push(s);
          else {
            let r = this.expectTemplateBindingKey(), i = this.parseAsBinding(r);
            i ? n.push(i) : (r.source = t.source + r.source.charAt(0).toUpperCase() + r.source.substring(1), n.push(...this.parseDirectiveKeywordBindings(r)));
          }
          this.consumeStatementTerminator();
        }
        return new Ot(n, [], this.errors);
      }
      parseKeyedReadOrWrite(t, n, s) {
        return this.withContext(ae.Writable, () => {
          this.rbracketsExpected++;
          let r = this.parsePipe();
          if (r instanceof A && this.error("Key access cannot be empty"), this.rbracketsExpected--, this.expectCharacter(G), this.isAssignmentOperator(this.next)) {
            let i = this.next.strValue;
            if (s) this.advance(), this.error("The '?.' operator cannot be used in the assignment");
            else {
              let o = new ue(this.span(n), this.sourceSpan(n), t, r);
              this.advance();
              let c = this.parseConditional();
              return new y(this.span(n), this.sourceSpan(n), i, o, c);
            }
          } else return s ? new he(this.span(n), this.sourceSpan(n), t, r) : new ue(this.span(n), this.sourceSpan(n), t, r);
          return new A(this.span(n), this.sourceSpan(n));
        });
      }
      parseDirectiveKeywordBindings(t) {
        let n = [];
        this.consumeOptionalCharacter(j);
        let s = this.getDirectiveBoundTarget(), r = this.currentAbsoluteOffset, i = this.parseAsBinding(t);
        i || (this.consumeStatementTerminator(), r = this.currentAbsoluteOffset);
        let o = new B(t.span.start, r);
        return n.push(new He(o, t, s)), i && n.push(i), n;
      }
      getDirectiveBoundTarget() {
        if (this.next === Ge || this.peekKeywordAs() || this.peekKeywordLet()) return null;
        let t = this.parsePipe(), { start: n, end: s } = t.span, r = this.input.substring(n, s);
        return new F(t, r, O(this.parseSourceSpan), this.absoluteOffset + n, this.errors);
      }
      parseAsBinding(t) {
        if (!this.peekKeywordAs()) return null;
        this.advance();
        let n = this.expectTemplateBindingKey();
        this.consumeStatementTerminator();
        let s = new B(t.span.start, this.currentAbsoluteOffset);
        return new ge(s, n, t);
      }
      parseLetBinding() {
        if (!this.peekKeywordLet()) return null;
        let t = this.currentAbsoluteOffset;
        this.advance();
        let n = this.expectTemplateBindingKey(), s = null;
        this.consumeOptionalOperator("=") && (s = this.expectTemplateBindingKey()), this.consumeStatementTerminator();
        let r = new B(t, this.currentAbsoluteOffset);
        return new ge(r, n, s);
      }
      parseNoInterpolationTaggedTemplateLiteral(t, n) {
        let s = this.parseNoInterpolationTemplateLiteral();
        return new fe(this.span(n), this.sourceSpan(n), t, s);
      }
      parseNoInterpolationTemplateLiteral() {
        let t = this.next.strValue, n = this.inputIndex;
        this.advance();
        let s = this.span(n), r = this.sourceSpan(n);
        return new de(s, r, [new me(s, r, t)], []);
      }
      parseTaggedTemplateLiteral(t, n) {
        let s = this.parseTemplateLiteral();
        return new fe(this.span(n), this.sourceSpan(n), t, s);
      }
      parseTemplateLiteral() {
        let t = [], n = [], s = this.inputIndex;
        for (; this.next !== Ge; ) {
          let r = this.next;
          if (r.isTemplateLiteralPart() || r.isTemplateLiteralEnd()) {
            let i = this.inputIndex;
            if (this.advance(), t.push(new me(this.span(i), this.sourceSpan(i), r.strValue)), r.isTemplateLiteralEnd()) break;
          } else if (r.isTemplateLiteralInterpolationStart()) {
            this.advance(), this.rbracesExpected++;
            let i = this.parsePipe();
            i instanceof A ? this.error("Template literal interpolation cannot be empty") : n.push(i), this.rbracesExpected--;
          } else this.advance();
        }
        return new de(this.span(s), this.sourceSpan(s), t, n);
      }
      parseRegularExpressionLiteral() {
        let t = this.next;
        if (this.advance(), !t.isRegExpBody()) return new A(this.span(this.inputIndex), this.sourceSpan(this.inputIndex));
        let n = null;
        if (this.next.isRegExpFlags()) {
          n = this.next, this.advance();
          let i = /* @__PURE__ */ new Set();
          for (let o = 0; o < n.strValue.length; o++) {
            let c = n.strValue[o];
            ts.has(c) ? i.has(c) ? this.error(`Duplicate regular expression flag "${c}"`, n.index + o) : i.add(c) : this.error(`Unsupported regular expression flag "${c}". The supported flags are: ` + Array.from(ts, (h) => `"${h}"`).join(", "), n.index + o);
          }
        }
        let s = t.index, r = n ? n.end : t.end;
        return new Ve(this.span(s, r), this.sourceSpan(s, r), t.strValue, n ? n.strValue : null);
      }
      consumeStatementTerminator() {
        this.consumeOptionalCharacter(Te) || this.consumeOptionalCharacter(re);
      }
      error(t, n = this.index) {
        this.errors.push(oe(t, this.input, this.getErrorLocationText(n), this.parseSourceSpan)), this.skip();
      }
      getErrorLocationText(t) {
        return t < this.tokens.length ? `at column ${this.tokens[t].index + 1} in` : "at the end of the expression";
      }
      _reportErrorForPrivateIdentifier(t, n) {
        let s = `Private identifiers are not supported. Unexpected private identifier: ${t}`;
        n !== null && (s += `, ${n}`), this.error(s);
      }
      skip() {
        let t = this.next;
        for (; this.index < this.tokens.length && !t.isCharacter(Te) && !t.isOperator("|") && (this.rparensExpected <= 0 || !t.isCharacter(q)) && (this.rbracesExpected <= 0 || !t.isCharacter(ie)) && (this.rbracketsExpected <= 0 || !t.isCharacter(G)) && (!(this.context & ae.Writable) || !this.isAssignmentOperator(t)); ) this.next.isError() && this.errors.push(oe(this.next.toString(), this.input, this.getErrorLocationText(this.next.index), this.parseSourceSpan)), this.advance(), t = this.next;
      }
    };
    Ft = class extends Nt {
      errors = [];
      visitPipe() {
        this.errors.push("pipes");
      }
    };
    Or = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex", "aria-activedescendant": "ariaActiveDescendantElement", "aria-atomic": "ariaAtomic", "aria-autocomplete": "ariaAutoComplete", "aria-busy": "ariaBusy", "aria-checked": "ariaChecked", "aria-colcount": "ariaColCount", "aria-colindex": "ariaColIndex", "aria-colindextext": "ariaColIndexText", "aria-colspan": "ariaColSpan", "aria-controls": "ariaControlsElements", "aria-current": "ariaCurrent", "aria-describedby": "ariaDescribedByElements", "aria-description": "ariaDescription", "aria-details": "ariaDetailsElements", "aria-disabled": "ariaDisabled", "aria-errormessage": "ariaErrorMessageElements", "aria-expanded": "ariaExpanded", "aria-flowto": "ariaFlowToElements", "aria-haspopup": "ariaHasPopup", "aria-hidden": "ariaHidden", "aria-invalid": "ariaInvalid", "aria-keyshortcuts": "ariaKeyShortcuts", "aria-label": "ariaLabel", "aria-labelledby": "ariaLabelledByElements", "aria-level": "ariaLevel", "aria-live": "ariaLive", "aria-modal": "ariaModal", "aria-multiline": "ariaMultiLine", "aria-multiselectable": "ariaMultiSelectable", "aria-orientation": "ariaOrientation", "aria-owns": "ariaOwnsElements", "aria-placeholder": "ariaPlaceholder", "aria-posinset": "ariaPosInSet", "aria-pressed": "ariaPressed", "aria-readonly": "ariaReadOnly", "aria-required": "ariaRequired", "aria-roledescription": "ariaRoleDescription", "aria-rowcount": "ariaRowCount", "aria-rowindex": "ariaRowIndex", "aria-rowindextext": "ariaRowIndexText", "aria-rowspan": "ariaRowSpan", "aria-selected": "ariaSelected", "aria-setsize": "ariaSetSize", "aria-sort": "ariaSort", "aria-valuemax": "ariaValueMax", "aria-valuemin": "ariaValueMin", "aria-valuenow": "ariaValueNow", "aria-valuetext": "ariaValueText" })), ki = Array.from(Or).reduce((e22, [t, n]) => (e22.set(t, n), e22), /* @__PURE__ */ new Map()), Ti = new we(new Ue());
    bi = [{ test: D(f.StyleMap), transform: it }, { test: D(f.ClassMap), transform: it }, { test: D(f.StyleProp) }, { test: D(f.ClassProp) }, { test: Ne(f.Attribute, !0) }, { test: Ne(f.Property, !0) }, { test: Fr }, { test: Ne(f.Attribute, !1) }], Ai = [{ test: Ne(f.DomProperty, !0) }, { test: Ne(f.DomProperty, !1) }, { test: D(f.Attribute) }, { test: D(f.StyleMap), transform: it }, { test: D(f.ClassMap), transform: it }, { test: D(f.StyleProp) }, { test: D(f.ClassProp) }], Ii = /* @__PURE__ */ new Set([f.Listener, f.TwoWayListener, f.AnimationListener, f.StyleMap, f.ClassMap, f.StyleProp, f.ClassProp, f.Property, f.TwoWayProperty, f.DomProperty, f.Attribute, f.Animation]);
    Ni = /* @__PURE__ */ new Map([[$.Idle, { none: l.deferOnIdle, prefetch: l.deferPrefetchOnIdle, hydrate: l.deferHydrateOnIdle }], [$.Immediate, { none: l.deferOnImmediate, prefetch: l.deferPrefetchOnImmediate, hydrate: l.deferHydrateOnImmediate }], [$.Timer, { none: l.deferOnTimer, prefetch: l.deferPrefetchOnTimer, hydrate: l.deferHydrateOnTimer }], [$.Hover, { none: l.deferOnHover, prefetch: l.deferPrefetchOnHover, hydrate: l.deferHydrateOnHover }], [$.Interaction, { none: l.deferOnInteraction, prefetch: l.deferPrefetchOnInteraction, hydrate: l.deferHydrateOnInteraction }], [$.Viewport, { none: l.deferOnViewport, prefetch: l.deferPrefetchOnViewport, hydrate: l.deferHydrateOnViewport }], [$.Never, { none: l.deferHydrateNever, prefetch: l.deferHydrateNever, hydrate: l.deferHydrateNever }]]), Pi = [l.pipeBind1, l.pipeBind2, l.pipeBind3, l.pipeBind4], Li = { constant: [l.interpolate, l.interpolate1, l.interpolate2, l.interpolate3, l.interpolate4, l.interpolate5, l.interpolate6, l.interpolate7, l.interpolate8], variable: l.interpolateV, mapping: (e22) => {
      if (e22 % 2 === 0) throw new Error("Expected odd number of arguments");
      return (e22 - 1) / 2;
    } }, Mi = /* @__PURE__ */ new Map([["window", l.resolveWindow], ["document", l.resolveDocument], ["body", l.resolveBody]]), Ri = /* @__PURE__ */ new Map([[L.HTML, l.sanitizeHtml], [L.RESOURCE_URL, l.sanitizeResourceUrl], [L.SCRIPT, l.sanitizeScript], [L.STYLE, l.sanitizeStyle], [L.URL, l.sanitizeUrl], [L.ATTRIBUTE_NO_BINDING, l.validateAttribute]]), $i = /* @__PURE__ */ new Map([[L.HTML, l.trustConstantHtml], [L.RESOURCE_URL, l.trustConstantResourceUrl]]);
    (function(e22) {
      e22[e22.None = 0] = "None", e22[e22.ViewContextRead = 1] = "ViewContextRead", e22[e22.ViewContextWrite = 2] = "ViewContextWrite", e22[e22.SideEffectful = 4] = "SideEffectful";
    })(ns || (ns = {}));
    Di = /* @__PURE__ */ new Map([[M.Property, R.Property], [M.TwoWay, R.TwoWayProperty], [M.Attribute, R.Attribute], [M.Class, R.ClassName], [M.Style, R.StyleProperty], [M.LegacyAnimation, R.LegacyAnimation], [M.Animation, R.Animation]]), Bi = Symbol("queryAdvancePlaceholder");
    (function(e22) {
      e22[e22.NG_CONTENT = 0] = "NG_CONTENT", e22[e22.STYLE = 1] = "STYLE", e22[e22.STYLESHEET = 2] = "STYLESHEET", e22[e22.SCRIPT = 3] = "SCRIPT", e22[e22.OTHER = 4] = "OTHER";
    })(ss || (ss = {}));
    (function(e22) {
      e22.IDLE = "idle", e22.TIMER = "timer", e22.INTERACTION = "interaction", e22.IMMEDIATE = "immediate", e22.HOVER = "hover", e22.VIEWPORT = "viewport", e22.NEVER = "never";
    })(rs || (rs = {}));
    ws = "%COMP%", Oi = `_nghost-${ws}`, Fi = `_ngcontent-${ws}`;
    (function(e22) {
      e22[e22.Extract = 0] = "Extract", e22[e22.Merge = 1] = "Merge";
    })(is || (is = {}));
    Vi = new At("21.0.2");
    Hr = (e22) => we.prototype._commentStart(e22);
    Ss = je((e22, t) => t.parseBinding(e22, qe(), 0)), Wr = je((e22, t) => t.parseSimpleBinding(e22, qe(), 0)), Es = je((e22, t) => t.parseAction(e22, qe(), 0)), ys = je((e22, t) => t.parseInterpolationExpression(e22, qe(), 0)), _s = je((e22, t) => t.parseTemplateBindings("", e22, qe(), 0, 0), !1), Cs = (e22, t) => (n, s, ...r) => n | 1 && s == null ? void 0 : (t.call(s) ?? s[e22]).apply(s, r);
    jr = Cs("at", function() {
      if (Array.isArray(this) || typeof this == "string") return qr;
    }), lt = jr, ks = class {
      text;
      constructor(e22) {
        this.text = e22;
      }
      getCharacterIndex(e22, t) {
        return hn(this.text, e22, t);
      }
      getCharacterLastIndex(e22, t) {
        return un(this.text, e22, t);
      }
      transformSpan(e22, { stripSpaces: t = !1, hasParentParens: n = !1 } = {}) {
        if (!t) return Ee(e22);
        let { outerSpan: s, innerSpan: r, hasParens: i } = ln(e22, this.text, n), o = Ee(r);
        return i && (o.extra = { parenthesized: !0, parenStart: s.start, parenEnd: s.end }), o;
      }
      createNode(e22, { stripSpaces: t = !0, hasParentParens: n = !1 } = {}) {
        let { type: s, start: r, end: i } = e22, o = { ...e22, ...this.transformSpan({ start: r, end: i }, { stripSpaces: t, hasParentParens: n }) };
        switch (s) {
          case "NumericLiteral":
          case "StringLiteral":
          case "RegExpLiteral": {
            let c = this.text.slice(o.start, o.end), { value: h } = o;
            o.extra = { ...o.extra, raw: c, rawValue: h };
            break;
          }
          case "ObjectProperty": {
            let { shorthand: c } = o;
            c && (o.extra = { ...o.extra, shorthand: c });
            break;
          }
        }
        return o;
      }
    };
    Gt = class extends ks {
      #r;
      #n;
      constructor(e22, t) {
        super(t), this.#r = e22, this.#n = t;
      }
      get node() {
        return this.#t(this.#r);
      }
      transformNode(e22) {
        return this.#s(e22);
      }
      #e(e22, { stripSpaces: t = !0, hasParentParens: n = !1 } = {}) {
        return this.createNode(e22, { stripSpaces: t, hasParentParens: n });
      }
      #i(e22, t, { computed: n, optional: s, hasParentParens: r = !1 }) {
        let { receiver: i } = e22;
        if (Ts(i, this.#n) || i.sourceSpan.start === t.start) return t;
        let o = this.#t(i), c = zt(o);
        return this.#e({ type: s || c ? "OptionalMemberExpression" : "MemberExpression", object: o, property: t, computed: n, ...s ? { optional: !0 } : c ? { optional: !1 } : void 0, ...e22.sourceSpan }, { hasParentParens: r });
      }
      #t(e22, t) {
        return this.#s(e22, t);
      }
      #s(e22, t) {
        let { isInParentParens: n } = { isInParentParens: !1, ...t };
        if (e22 instanceof Vt) {
          let { expressions: s } = e22;
          if (s.length !== 1) throw new Error("Unexpected 'Interpolation'");
          return this.#t(s[0]);
        }
        if (e22 instanceof J) return this.#e({ type: "UnaryExpression", prefix: !0, argument: this.#t(e22.expr), operator: e22.operator, ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof y) {
          let { left: s, operation: r, right: i } = e22, o = this.#t(s), c = this.#t(i), h = { left: o, right: c, start: te(o), end: ne(c) };
          return r === "&&" || r === "||" || r === "??" ? this.#e({ ...h, type: "LogicalExpression", operator: r }, { hasParentParens: n }) : y.isAssignmentOperation(r) ? this.#e({ ...h, type: "AssignmentExpression", left: o, operator: r, ...e22.sourceSpan }, { hasParentParens: n }) : this.#e({ ...h, type: "BinaryExpression", operator: r }, { hasParentParens: n });
        }
        if (e22 instanceof Re) {
          let { exp: s, name: r, args: i } = e22, o = this.#t(s), c = te(o), h = ne(o), d = this.getCharacterIndex(/\S/, this.getCharacterIndex("|", h) + 1), g = this.#e({ type: "Identifier", name: r, start: d, end: d + r.length }), S = i.map((E) => this.#t(E));
          return this.#e({ type: "NGPipeExpression", left: o, right: g, arguments: S, start: c, end: ne(S.length === 0 ? g : lt(0, S, -1)) }, { hasParentParens: n });
        }
        if (e22 instanceof Le) return this.#e({ type: "NGChainedExpression", expressions: e22.expressions.map((s) => this.#t(s)), ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof Me) {
          let { condition: s, trueExp: r, falseExp: i } = e22, o = this.#t(s), c = this.#t(r), h = this.#t(i);
          return this.#e({ type: "ConditionalExpression", test: o, consequent: c, alternate: h, start: te(o), end: ne(h) }, { hasParentParens: n });
        }
        if (e22 instanceof A) return this.#e({ type: "NGEmptyExpression", ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof Q) return this.#e({ type: "ThisExpression", ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof $e) return this.#e({ type: "ArrayExpression", elements: e22.expressions.map((s) => this.#t(s)), ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof De) {
          let { keys: s, values: r } = e22, i = r.map((c) => this.#t(c)), o = s.map(({ key: c, quoted: h }, d) => {
            let g = i[d], S = te(g), E = ne(g), P = this.getCharacterIndex(/\S/, d === 0 ? e22.sourceSpan.start + 1 : this.getCharacterIndex(",", ne(i[d - 1])) + 1), C = { start: P, end: S === P ? E : this.getCharacterLastIndex(/\S/, this.getCharacterLastIndex(":", S - 1) - 1) + 1 }, N = h ? this.#e({ type: "StringLiteral", value: c, ...C }) : this.#e({ type: "Identifier", name: c, ...C }), H = N.end < N.start || P === S;
            return this.#e({ type: "ObjectProperty", key: N, value: g, shorthand: H, computed: !1, start: te(N), end: E });
          });
          return this.#e({ type: "ObjectExpression", properties: o, ...e22.sourceSpan }, { hasParentParens: n });
        }
        if (e22 instanceof k) {
          let { value: s } = e22;
          switch (typeof s) {
            case "boolean":
              return this.#e({ type: "BooleanLiteral", value: s, ...e22.sourceSpan }, { hasParentParens: n });
            case "number":
              return this.#e({ type: "NumericLiteral", value: s, ...e22.sourceSpan }, { hasParentParens: n });
            case "object":
              return this.#e({ type: "NullLiteral", ...e22.sourceSpan }, { hasParentParens: n });
            case "string":
              return this.#e({ type: "StringLiteral", value: s, ...e22.sourceSpan }, { hasParentParens: n });
            case "undefined":
              return this.#e({ type: "Identifier", name: "undefined", ...e22.sourceSpan }, { hasParentParens: n });
            default:
              throw new Error(`Unexpected LiteralPrimitive value type ${typeof s}`);
          }
        }
        if (e22 instanceof Ve) return this.#e({ type: "RegExpLiteral", pattern: e22.body, flags: e22.flags ?? "", ...e22.sourceSpan }, { hasParentParens: n });
        if (e22 instanceof Oe || e22 instanceof pe) {
          let s = e22 instanceof pe, { receiver: r, args: i } = e22, o = i.length === 1 ? [this.#t(i[0], { isInParentParens: !0 })] : i.map((g) => this.#t(g)), c = this.#t(r), h = zt(c), d = s || h ? "OptionalCallExpression" : "CallExpression";
          return this.#e({ type: d, callee: c, arguments: o, ...d === "OptionalCallExpression" ? { optional: s } : void 0, start: te(c), end: e22.sourceSpan.end }, { hasParentParens: n });
        }
        if (e22 instanceof Be) {
          let s = this.#t(e22.expression);
          return this.#e({ type: "TSNonNullExpression", expression: s, start: te(s), end: e22.sourceSpan.end }, { hasParentParens: n });
        }
        if (e22 instanceof K || e22 instanceof Z || e22 instanceof ee) {
          let s = e22 instanceof K ? "!" : e22 instanceof Z ? "typeof" : e22 instanceof ee ? "void" : void 0;
          if (!s) throw new Error("Unexpected expression.");
          let { start: r } = e22.sourceSpan;
          if (s === "typeof" || s === "void") {
            let o = this.text.lastIndexOf(s, r);
            if (o === -1) throw new Error(`Cannot find operator '${s}' from index ${r} in ${JSON.stringify(this.text)}`);
            r = o;
          }
          let i = this.#t(e22.expression);
          return this.#e({ type: "UnaryExpression", prefix: !0, operator: s, argument: i, start: r, end: ne(i) }, { hasParentParens: n });
        }
        if (e22 instanceof ue || e22 instanceof he) return this.#i(e22, this.#t(e22.key), { computed: !0, optional: e22 instanceof he, hasParentParens: n });
        if (e22 instanceof X || e22 instanceof ce) {
          let { receiver: s, name: r } = e22, i = this.#e({ type: "Identifier", name: r, ...e22.nameSpan }, Ts(s, this.#n) ? { hasParentParens: n } : {});
          return this.#i(e22, i, { computed: !1, optional: e22 instanceof ce, hasParentParens: n });
        }
        if (e22 instanceof fe) return this.#e({ type: "TaggedTemplateExpression", tag: this.#t(e22.tag), quasi: this.#t(e22.template), ...e22.sourceSpan });
        if (e22 instanceof de) {
          let { elements: s, expressions: r } = e22;
          return this.#e({ type: "TemplateLiteral", quasis: s.map((i) => this.#t(i, { parent: e22 })), expressions: r.map((i) => this.#t(i)), ...e22.sourceSpan });
        }
        if (e22 instanceof me) {
          let { elements: s } = t.parent, r = s.indexOf(e22), i = r === 0, o = r === s.length - 1, c = e22.sourceSpan.end - (o ? 1 : 0), h = e22.sourceSpan.start + (i ? 1 : 0), d = this.text.slice(h, c);
          return this.#e({ type: "TemplateElement", value: { cooked: e22.text, raw: d }, start: h, end: c, tail: o }, { stripSpaces: !1 });
        }
        if (e22 instanceof Fe) return this.#s(e22.expression);
        throw new Error(`Unexpected node type '${e22.constructor.name}'`);
      }
    };
    zr = (Ns = class extends Gt {
      constructor(t, n) {
        super(void 0, n), ze(this, m), ze(this, Se), ze(this, se), dt(this, Se, t), dt(this, se, n);
        for (let s of t) x(this, m, Ls).call(this, s);
      }
      get expressions() {
        return x(this, m, Rs).call(this);
      }
    }, Se = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakSet(), Ps = function() {
      return U(this, Se)[0].key;
    }, T = function(t, { stripSpaces: n = !0 } = {}) {
      return this.createNode(t, { stripSpaces: n });
    }, Xt = function(t) {
      return this.transformNode(t);
    }, Jt = function(t) {
      return pn(t.slice(U(this, m, Ps).source.length));
    }, Yt = function(t) {
      let n = U(this, se);
      if (n[t.start] !== '"' && n[t.start] !== "'") return;
      let s = n[t.start], r = !1;
      for (let i = t.start + 1; i < n.length; i++) switch (n[i]) {
        case s:
          if (!r) {
            t.end = i + 1;
            return;
          }
        default:
          r = !1;
          break;
        case "\\":
          r = !r;
          break;
      }
    }, Ls = function(t) {
      x(this, m, Yt).call(this, t.key.span), Is(t) && t.value && x(this, m, Yt).call(this, t.value.span);
    }, Ms = function(t) {
      if (!t.value || t.value.source) return t.value;
      let n = this.getCharacterIndex(/\S/, t.sourceSpan.start);
      return { source: "$implicit", span: { start: n, end: n } };
    }, Rs = function() {
      let t = U(this, Se), [n] = t, s = U(this, se).slice(n.sourceSpan.start, n.sourceSpan.end).trim().length === 0 ? t.slice(1) : t, r = [], i = null;
      for (let [o, c] of s.entries()) {
        if (i && As(i) && Is(c) && c.value && c.value.source === i.key.source) {
          let h = x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: c.key.source, ...c.key.span }), d = (E, P) => ({ ...E, ...this.transformSpan({ start: E.start, end: P }) }), g = (E) => ({ ...d(E, h.end), alias: h }), S = r.pop();
          if (S.type === "NGMicrosyntaxExpression") r.push(g(S));
          else if (S.type === "NGMicrosyntaxKeyedExpression") {
            let E = g(S.expression);
            r.push(d({ ...S, expression: E }, E.end));
          } else throw new Error(`Unexpected type ${S.type}`);
        } else r.push(x(this, m, $s).call(this, c, o));
        i = c;
      }
      return x(this, m, T).call(this, { type: "NGMicrosyntax", body: r, ...r.length === 0 ? t[0].sourceSpan : { start: r[0].start, end: lt(0, r, -1).end } });
    }, $s = function(t, n) {
      if (As(t)) {
        let { key: s, value: r } = t;
        return r ? n === 0 ? x(this, m, T).call(this, { type: "NGMicrosyntaxExpression", expression: x(this, m, Xt).call(this, r.ast), alias: null, ...r.sourceSpan }) : x(this, m, T).call(this, { type: "NGMicrosyntaxKeyedExpression", key: x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: x(this, m, Jt).call(this, s.source), ...s.span }), expression: x(this, m, T).call(this, { type: "NGMicrosyntaxExpression", expression: x(this, m, Xt).call(this, r.ast), alias: null, ...r.sourceSpan }), start: s.span.start, end: r.sourceSpan.end }) : x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: x(this, m, Jt).call(this, s.source), ...s.span });
      } else {
        let { key: s, sourceSpan: r } = t;
        if (/^let\s$/.test(U(this, se).slice(r.start, r.start + 4))) {
          let { value: i } = t;
          return x(this, m, T).call(this, { type: "NGMicrosyntaxLet", key: x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: s.source, ...s.span }), value: i ? x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: i.source, ...i.span }) : null, start: r.start, end: i ? i.span.end : s.span.end });
        } else {
          let i = x(this, m, Ms).call(this, t);
          return x(this, m, T).call(this, { type: "NGMicrosyntaxAs", key: x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: i.source, ...i.span }), alias: x(this, m, T).call(this, { type: "NGMicrosyntaxKey", name: s.source, ...s.span }), start: i.span.start, end: s.span.end });
        }
      }
    }, Ns);
    Qt = (e22) => ut(Ss(e22)), Kt = (e22) => ut(ys(e22)), ht = (e22) => ut(Es(e22)), Zt = (e22) => Bs(_s(e22));
    Gr = pt(ht), Xr = pt(Qt), Jr = pt(Kt), Yr = pt(Zt);
  }
});
init_angular();
export {
  Fs as default,
  tn as parsers
};
//# sourceMappingURL=angular-Z5FPQPLR.js.map
